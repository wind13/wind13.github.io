<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wind13&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wind13.github.io/"/>
  <updated>2019-09-18T03:27:21.000Z</updated>
  <id>http://wind13.github.io/</id>
  
  <author>
    <name>Simon J S Wind13 Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>functional-programming-ref</title>
    <link href="http://wind13.github.io/2019/09/18/functional-programming-ref/"/>
    <id>http://wind13.github.io/2019/09/18/functional-programming-ref/</id>
    <published>2019-09-18T03:27:21.000Z</published>
    <updated>2019-09-18T03:27:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html" target="_blank" rel="noopener">函数式编程入门教程（阮一峰）</a> 回答了为什么要用函数式编程思维？</li><li><a href="https://www.jdon.com/functional.html" target="_blank" rel="noopener">面向函数范式编程(Functional programming)</a> 说明了对面向对象编程的区别的关系，是可以互补共用的。</li><li><a href="https://www.jianshu.com/p/4bf39816e786" target="_blank" rel="noopener">Kotlin极简教程：第8章 函数式编程</a> 其中 Y组合子(Y - Combinator) ——匿名递归函数，解决匿名函数如何递归的问题。以及很多 Kotlin 的函数式编程语法。</li><li>强烈推荐以下两本书：<ul><li><a href="https://leanpub.com/javascript-allonge" target="_blank" rel="noopener">《JavaScript Allonge》</a> by Reginald Braithwaite</li><li><a href="http://shop.oreilly.com/product/0636920028857.do" target="_blank" rel="noopener">《Functional JavaScript》</a> by Michael Fogus</li></ul></li></ul><h2 id="TypeScript-JavaScript"><a href="#TypeScript-JavaScript" class="headerlink" title="TypeScript/JavaScript"></a>TypeScript/JavaScript</h2><ul><li><a href="http://swannodette.github.io/mori/" target="_blank" rel="noopener">mori</a> A library for using ClojureScript’s persistent data structures and supporting API from the comfort of vanilla JavaScript.</li><li><a href="https://linux.cn/article-7842-1.html" target="_blank" rel="noopener">函数式 TypeScript</a></li><li><a href="https://gcanti.github.io/fp-ts" target="_blank" rel="noopener">fp-ts</a><ul><li><a href="https://gcanti.github.io/fp-ts/recipes/ramda" target="_blank" rel="noopener">Migrate from Ramda</a></li><li><a href="https://gcanti.github.io/fp-ts/type-classes.svg" target="_blank" rel="noopener">fp-ts type classes svg</a></li></ul></li><li><a href="https://rxmarbles.com/" target="_blank" rel="noopener">rxmarbles</a></li><li><a href="http://www.cnblogs.com/android-blogs/p/5586395.html" target="_blank" rel="noopener">响应式编程，是明智的选择</a></li><li><a href="https://juejin.im/entry/5a4313ef5188255de57e0a18" target="_blank" rel="noopener">掘金——响应式编程，是明智的选择</a></li></ul><h2 id="ClojureScript"><a href="#ClojureScript" class="headerlink" title="ClojureScript"></a>ClojureScript</h2><ul><li><a href="https://cursive-ide.com/" target="_blank" rel="noopener">Cursive</a> The Clojure(Script) IDE that understands your code.</li><li><a href="https://github.com/anmonteiro/lumo" target="_blank" rel="noopener">lumo</a> Fast, cross-platform, standalone ClojureScript environment</li><li><a href="http://shadow-cljs.org/" target="_blank" rel="noopener">shadow-cljs</a> ClojureScript compilation made easy!</li><li><a href="http://cljs-book.clj.im/" target="_blank" rel="noopener">ClojureScript 入门指南</a></li><li><a href="https://github.com/omcljs/om" target="_blank" rel="noopener">Om</a> A ClojureScript UI framework and client/server architecture over Facebook’s React.</li></ul><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2><h3 id="Using"><a href="#Using" class="headerlink" title="Using"></a>Using</h3><ul><li><a href="https://github.com/moriyalb/lamda" target="_blank" rel="noopener">Lamda</a></li><li><a href="https://github.com/bjornbytes/RxLua" target="_blank" rel="noopener">bjornbytes/RxLua</a><ul><li><a href="https://github.com/bjornbytes/RxLua/blob/master/tests/observable.lua" target="_blank" rel="noopener">example of observable</a></li></ul></li></ul><h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><ul><li><a href="http://yonaba.github.io/Moses/" target="_blank" rel="noopener">Moses</a> Utility library for functional programming in Lua. Like Lodash of Lua.</li><li><a href="https://github.com/lxsmnsyc/rxlua" target="_blank" rel="noopener">lxsmnsyc/RxLua</a> Not ready for production.</li><li><a href="https://github.com/mrunderhill89/bacon.lua" target="_blank" rel="noopener">bacon.lua</a></li><li><a href="http://lua-users.org/" target="_blank" rel="noopener">lua-users</a></li></ul><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ul><li><a href="https://github.com/agiledragon/gomonkey" target="_blank" rel="noopener">gomonkey</a> is a library to make monkey patching in unit tests easy. 单元测试打桩框架</li><li><a href="http://www.minetest.net/" target="_blank" rel="noopener">minetest</a> 我的世界开发框架<ul><li><a href="https://github.com/davisonio/bacon" target="_blank" rel="noopener">Bacon</a> mod for Minetest</li></ul></li></ul><h2 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h2><p>Java 8 才算是真的提高到函数式编程语言了，见以下这些资料：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">Java 8 中的 Streams API 详解</a></li><li><a href="http://winterbe.com/posts/2014/07/31/java8-stream-tutorial-examples/" target="_blank" rel="noopener">Java 8 Stream Tutorial</a></li></ul><h3 id="fn-rx"><a href="#fn-rx" class="headerlink" title="fn + rx"></a>fn + rx</h3><ul><li><a href="https://medium.com/@ome450901/rxjava2-%E4%BA%8C%E4%B8%89%E5%9B%9B%E4%BA%94%E5%85%AD%E8%A8%AA-29b6ab624ab2" target="_blank" rel="noopener">Rxjava2 二三四五六訪</a></li><li><a href="https://www.functionaljava.org/" target="_blank" rel="noopener">Functional Java</a> is an open source library facilitating functional programming in Java.</li><li><a href="https://blog.csdn.net/u011200604/article/details/70208756" target="_blank" rel="noopener">用RxJava实现Rxbus替换EventBus事件总线</a></li></ul><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030136026784" target="_blank" rel="noopener">Python 2.7 函数式编程（廖雪峰）</a></li></ul><h2 id="Rx-js"><a href="#Rx-js" class="headerlink" title="Rx.js"></a>Rx.js</h2><ul><li><a href="https://medium.com/@jvdheijden/rxjs-throttletime-debouncetime-and-audittime-explained-in-examples-c393178458f3" target="_blank" rel="noopener">RxJS throttleTime, debounceTime and auditTime explained in examples</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html
      
    
    </summary>
    
    
    
      <category term="函数式编程" scheme="http://wind13.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>当日笔记-20080925</title>
    <link href="http://wind13.github.io/2018/09/25/daily-note-20080925/"/>
    <id>http://wind13.github.io/2018/09/25/daily-note-20080925/</id>
    <published>2018-09-25T08:25:28.000Z</published>
    <updated>2018-09-26T03:24:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul><li><a href="https://github.com/lcxfs1991/blog/issues/28" target="_blank" rel="noopener">小程序的全栈开发新时代</a></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li><a href="https://mp.weixin.qq.com/s/rlUUXVEinbeH4aQ0g2SGXA" target="_blank" rel="noopener">读懂世纪难题“黎曼猜想”和其历史</a></li><li><a href="https://mp.weixin.qq.com/s/LKu7wWcpwbzBTU5t72m9Dw" target="_blank" rel="noopener">黎曼猜想仍旧，素数依然孤独</a></li><li><a href="https://zhuanlan.zhihu.com/p/25055731" target="_blank" rel="noopener">黎曼猜想，及其解释（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/25222934" target="_blank" rel="noopener">黎曼猜想，及其解释（下）</a></li></ul><h3 id="神奇而有趣的素数"><a href="#神奇而有趣的素数" class="headerlink" title="神奇而有趣的素数"></a>神奇而有趣的素数</h3><ul><li><p>素数（质数）就是除了 1 和自身，不能再被其他整数整除的数字。</p></li><li><p>第一个问题：下一个素数的规律是什么？</p></li><li><p>2 的倍数即是所有偶数。</p></li><li><p>3 的倍数，其数字相加能被 3 整除。</p></li><li><p>5 的倍数，结尾不是 5 就是 0，即见到这两个数字结尾的整数就能被 5 整除。</p></li><li><p>7 的倍数是第一个比较没规律的素数集合，而 7 = 2 * 3 + 1，即前两个素数相乘后再加 1 即可。</p></li><li><p>11 = 2 * 5 + 1，13 = 2 * 2 * 3 + 1，欧几里得在公元前 300 年证明了素数有无限个。如果是有限个，那假设它们的乘积为 P ，而 Q = P + 1，那么 Q 应该是一个合数，即可被其中某个素数 p 整除，而 p 又可以整除 P，那么 Q - P 也应该能被 p 整除，但是 Q - P = 1，1 显然不能被 p 整除，只能被 1 整除，所以不存在这样有限个素数的情况。</p></li></ul><h3 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h3><p>$$H_r = \sum_{r=1}^\infin \frac{1}{r} = 1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} + …$$</p><ul><li>谐波：高于基音基本频率的泛音，该和式被奥雷斯姆证明是不收敛的（即不存在极限，不接近/趋向于任何特定的数字，而是一直增长到无穷大）。</li></ul><h3 id="Zeta-函数"><a href="#Zeta-函数" class="headerlink" title="Zeta 函数"></a>Zeta 函数</h3><p>$$\zeta(n)=\sum_{r=1}^\infin \frac{1}{r^n}=1 + \frac{1}{2^n} + \frac{1}{3^n} + \frac{1}{4^n} + …$$</p><p>若将 n = 1 代入，就会得到调和级数，它是发散的。然而对于 n &gt; 1 的所有值, 该级数是收敛的，这意味着当 r 递增时，其和趋向于某些数，即它不会增长到无穷大。</p><h3 id="欧拉乘积公式"><a href="#欧拉乘积公式" class="headerlink" title="欧拉乘积公式"></a>欧拉乘积公式</h3><p>zeta 函数和素数间的第一个联系是由欧拉发现的，当时他发现了 n 和 p 两个自然数（大于零的整数）之间的关系，其中 p 为素数：</p><p>$$\zeta(n)=\sum_{r=1}^\infin\frac1{r^n}=\prod_p\frac1{1-p^{-s}}=(1-\frac1{1-\frac1{2^s}})\times(1-\frac1{1-\frac1{3^s}})\times(1-\frac1{1-\frac1{5^s}})\times(1-\frac1{1-\frac1{7^s}})\times(1-\frac1{1-\frac1{11^s}})\times…$$</p><p>欧拉乘积公式，其中 n，p 均为大于零的数字且 p 为素数</p><h2 id="简易思考"><a href="#简易思考" class="headerlink" title="简易思考"></a>简易思考</h2><ul><li><input disabled type="checkbox"> 100 以内有多少个素数？<ul><li><a href="https://plus.ooclab.com/note/article/1189" target="_blank" rel="noopener">golang-daisy-chain</a> 利用信道菊花链筛法求某一个整数范围的素数</li></ul></li><li><input disabled type="checkbox"> 100 以后第一个素数是多少？</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><ul><li><a href="https://www.mathjax.org/" target="_blank" rel="noopener">MathJax</a> Beautiful math in all browsers</li><li><a href="https://www.liuguogy.com/archives/markdown-mathjax-grammar.html" target="_blank" rel="noopener">Markdown 中的 MathJax 数学公式语法整理</a></li><li><a href="https://www.jianshu.com/p/a0aa94ef8ab2" target="_blank" rel="noopener">在Markdown中输入数学公式(MathJax)</a></li><li><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax basic tutorial and quick reference</a></li></ul><h2 id="Hugo-theme"><a href="#Hugo-theme" class="headerlink" title="Hugo theme"></a>Hugo theme</h2><ul><li><a href="https://www.zeolearn.com/magazine/develop-a-theme-for-hugo" target="_blank" rel="noopener">Develop a Theme for Hugo</a></li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><a href="https://godoc.org/github.com/azbshiri/ramda?import-graph" target="_blank" rel="noopener">ramda deps graph</a></li><li><a href="https://go-search.org" target="_blank" rel="noopener">Go Search</a></li><li><a href="http://labix.org/pipe" target="_blank" rel="noopener">Unix-like pipelines for Go</a> <a href="https://gopkg.in/pipe.v2" target="_blank" rel="noopener">Doc</a></li><li><a href="https://github.com/lennon-guan/pipe" target="_blank" rel="noopener">lennon-guan/pipe</a> A golang library that makes operations on slice easilier 局限于 Slice 数据</li><li><a href="https://godoc.org/github.com/choleraehyq/gofunctools/functools" target="_blank" rel="noopener">gofunctools</a> <a href="https://github.com/choleraehyq/gofunctools" target="_blank" rel="noopener">Github</a></li><li><a href="https://github.com/Mparaiso/go-tiger" target="_blank" rel="noopener">Go TIGER</a> Web 微框架，包含一些工具<ul><li><a href="https://godoc.org/github.com/Mparaiso/tiger-go-framework/funcs" target="_blank" rel="noopener">Make funcs</a> Package funcs provides utilities to enable functional programming with Go.</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;小程序&quot;&gt;&lt;a href=&quot;#小程序&quot; class=&quot;headerlink&quot; title=&quot;小程序&quot;&gt;&lt;/a&gt;小程序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lcxfs1991/blog/issues/28&quot; target
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>当日笔记-20080922</title>
    <link href="http://wind13.github.io/2018/09/22/daily-note-20080922/"/>
    <id>http://wind13.github.io/2018/09/22/daily-note-20080922/</id>
    <published>2018-09-22T01:53:04.000Z</published>
    <updated>2018-09-25T09:03:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hugo-研究"><a href="#Hugo-研究" class="headerlink" title="Hugo 研究"></a>Hugo 研究</h2><p>对 Hugo 有点着迷了，看到了 <a href="https://www.youtube.com/watch?list=PLLAZ4kZ9dFpOnyRlyS-liKL5ReHDcj4G3&v=qtIqKaDlqXo" target="_blank" rel="noopener">Youtube 上面的教程</a>，非常详细而直观，同时还可以练习英语听力，看自己感兴趣的英语视频内容应该是学英语最佳的途径之一了。</p><p>然后发现了这个 <a href="https://www.netlify.com" target="_blank" rel="noopener">netlify 网站</a> ，号称：Everything you need to deploy your project. 在静态网站的基础上，扩展很多功能 Auth/Form/Lamda 等，包括部署 CI/CD 等，单人免费，<a href="https://www.netlify.com/pricing/" target="_blank" rel="noopener">多人收费</a>。考虑到结合 Hugo, google AWP, netlify, AWS lamda 和 facebook Fauna 无服务数据库，就可以做很牛的网站和 App 服务了。 未来技术的发展会进一步简化人们提供服务的能力，从人人可以发 Blog，到人人可以提供应用服务，甚至到人人可以搭平台……</p><h2 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h2><p>发现了<a href="https://www.youtube.com/watch?v=FrMSSQRYS6I" target="_blank" rel="noopener">这个</a>视频 How to learn any language in six months Chris Lonsdale at TEDxLingnanUniversity，5 个原则和 7 个行动，超级棒的学习心法！而且在电视上看到这人的英语学习视频，准备购买了来学，似乎感觉自己真正找到了学习英语的法门。</p><ul><li><p><a href="https://v.youku.com/v_show/id_XNjkyODIyMDYw.html" target="_blank" rel="noopener">Ted——6个月掌握外语学习方法（英语字幕）</a></p></li><li><p>[<a href="https://v.qq.com/x/page/x0603lw682d.html" target="_blank" rel="noopener">TED经典视频：6个月掌握流利的外语学习方法</a>]</p></li><li><p><a href="https://list.youku.com/star/show/uid_UMzYzMzc0MA==.html" target="_blank" rel="noopener">龙飞虎</a></p></li><li><p><a href="https://v.youku.com/v_show/id_XMTM3NTg1OTk0NA==.html" target="_blank" rel="noopener">英语学习方法 6个月从0学英语 语法是你的朋友</a></p></li><li><p><a href="https://piccdn.igetget.com/img/201708/21/201708211714508672282465.jpg" target="_blank" rel="noopener">得到招聘赠书</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Hugo-研究&quot;&gt;&lt;a href=&quot;#Hugo-研究&quot; class=&quot;headerlink&quot; title=&quot;Hugo 研究&quot;&gt;&lt;/a&gt;Hugo 研究&lt;/h2&gt;&lt;p&gt;对 Hugo 有点着迷了，看到了 &lt;a href=&quot;https://www.youtube.com/
      
    
    </summary>
    
    
    
      <category term="hugo" scheme="http://wind13.github.io/tags/hugo/"/>
    
      <category term="netlify" scheme="http://wind13.github.io/tags/netlify/"/>
    
  </entry>
  
  <entry>
    <title>当日笔记-20080921</title>
    <link href="http://wind13.github.io/2018/09/21/daily-note-20080921/"/>
    <id>http://wind13.github.io/2018/09/21/daily-note-20080921/</id>
    <published>2018-09-21T10:25:07.000Z</published>
    <updated>2018-09-25T08:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备做的事"><a href="#准备做的事" class="headerlink" title="准备做的事"></a>准备做的事</h2><ul><li><input checked disabled type="checkbox"> <p>尝试使用 Hugo；</p><ul><li>目录结构：<ul><li>archetypes：包括内容类型，在创建新内容时自动生成内容的配置</li><li>content：包括网站内容，全部使用markdown格式</li><li>layouts：包括了网站的模版，决定内容如何呈现</li><li>static：包括了css, js, fonts, media等，决定网站的外观</li></ul></li><li>常用命令：<ul><li><code>hugo server -t hyde --buildDrafts</code> 其中 <code>-t</code> 指 theme 主题， <code>--buildDrafts</code> 指草稿也渲染。</li></ul></li></ul></li><li><input disabled type="checkbox"> <p>尝试将 Blog 从 Hexo 转到 Hugo；</p><ul><li>用 Hexo 生成目前的 Blog 需要 36 秒，够慢的，看换了 Hugo 后会是多快？</li><li>找到 <a href="https://github.com/wd/hexo2hugo" target="_blank" rel="noopener">hexo2hugo</a> 尝试一下。基本可用，但仅能将 _posts 目录下的 md 文件转换一下格式，所以仍存在的问题如下：<ul><li><input disabled type="checkbox"> 并不能转换其他的配置功能，如搜索、回复、赞赏、分享等功能；</li><li><input disabled type="checkbox"> 转换时未能处理命名为 <code>index.md</code> 的问题；</li><li><input disabled type="checkbox"> 转换时未能处理无 <code>title</code> 的 meta data 问题，导致显示列表中没有标题链接；</li><li><input disabled type="checkbox"> 转换时未处理摘要的问题，导致列表中显示大段文字的情况；</li></ul></li><li>找到 <a href="https://danielfree.net/archives/migrate-from-hugo-to-hugo/" target="_blank" rel="noopener">Migrate from Hexo to Hugo</a> 看一下。 还有 <a href="https://www.babaei.net/blog/migrating-from-hexo-to-hugo/" target="_blank" rel="noopener">Migrating From Hexo To Hugo</a> 提到了 <a href="https://www.getgutenberg.io/" target="_blank" rel="noopener">Gutenburg</a> (written in <a href="https://www.rust-lang.org/" target="_blank" rel="noopener">Rust</a>)</li></ul></li><li><input disabled type="checkbox"> <p>尝试将转换过程写成自动化脚本，开放为开源项目；</p></li><li><input checked disabled type="checkbox"> <p>想继续使用 Next 主题，找到了：</p><ul><li><a href="https://github.com/leopku/hugo-theme-next" target="_blank" rel="noopener">NeXT</a> is a fast and clean theme for <a href="http://gohugo.io/" target="_blank" rel="noopener">Hugo</a>. which was inspired by a Hexo theme named <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>.</li><li>考虑有些需要的功能可以 fork 后提 pull request 支持项目。</li></ul></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>Python2 和 Python3 共存，尝试运行 pip 安装 pytoml，结果用 python 运行时，仍然提示未安装，通过 <code>which python</code> 和 <code>which pip</code>  两个命令才发现，python 指向 python2 的版本，而 pip 指向 pip3 的版本，测试后发现当两个版本共存时，最好在使用具体命令时，要用 2 版本就用 <code>python2</code> 和 <code>pip2</code> ，要用 3 版本时，就用 <code>python3</code> 和 <code>pip3</code> ，这样就能明确区别开了。</li><li>尝试 <a href="https://github.com/gucheen/HexoConvertToHugo" target="_blank" rel="noopener">HexoConvertToHugo</a> 失败，不太好用，文档也不清楚，测试后报错，暂时放弃。</li><li>使用 hexo2hugo，开始的时候报错，以为是 <code>datetime</code> 库没安装，但安装后仍然报错，结果试了一下 python3 居然成功了，说明这个脚本是用 Python3 语法写的，Python 的这两个版本区别还真是麻烦，应该在脚本的最前面加上注释才对，或者直接改一下后缀名： xxx.py3 就清楚了。</li><li>使用 hexo2hugo，遇到第一行不是 <code>---</code> 的文档会报错，找不到 meta 信息，看了一眼程序逻辑比较固化，暂不修改了，直接修改文档匹配规则。</li><li>添加 next 主题，全新的站点，只添加一个文章，但在首页上看不到，能看到 <code>next</code> 的主题起作用了。换用 <code>ananke</code> 主题就显示正常了。一批批转移文件倒是可以，怀疑可能是 <code>index.md</code> 文件命名的问题，至少会导致 <code>All Posts</code> 链接被覆盖。</li></ul><h2 id="灵感记录"><a href="#灵感记录" class="headerlink" title="灵感记录"></a>灵感记录</h2><ul><li>互联网时代，每个人都可能成为扫地僧，整个互联网就象是少林寺的藏经阁，要学什么、怎么学，就要看你自己怎么把握了。<ul><li>萧峰和慕荣的爹都练走火了，为什么扫地僧没练走火？因为扫地僧不急功近利，有雄厚的佛法心法。</li><li>什么是互联网的修炼心法？终身学习！</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备做的事&quot;&gt;&lt;a href=&quot;#准备做的事&quot; class=&quot;headerlink&quot; title=&quot;准备做的事&quot;&gt;&lt;/a&gt;准备做的事&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;input checked disabled type=&quot;checkbox&quot;&gt; &lt;p&gt;尝试使用 Hug
      
    
    </summary>
    
    
    
      <category term="hexo" scheme="http://wind13.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://wind13.github.io/tags/blog/"/>
    
      <category term="hugo" scheme="http://wind13.github.io/tags/hugo/"/>
    
      <category term="next" scheme="http://wind13.github.io/tags/next/"/>
    
      <category term="python" scheme="http://wind13.github.io/tags/python/"/>
    
      <category term="灵感" scheme="http://wind13.github.io/tags/%E7%81%B5%E6%84%9F/"/>
    
  </entry>
  
  <entry>
    <title>在得到 App 上听书《知识的边界》和《走近2050》感悟</title>
    <link href="http://wind13.github.io/2018/09/21/book-comprehend/"/>
    <id>http://wind13.github.io/2018/09/21/book-comprehend/</id>
    <published>2018-09-21T05:58:46.000Z</published>
    <updated>2018-09-21T05:58:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>人类已经进入互联网时代，互联网对人类的很多方面产生了巨大而深远的影响，有些方面在商业和科技的促进下转变得比较快，比如电子商务、信息搜索、出行交通等，但有些方面就显得相对落后，如：政府效能、教育培训、人才评定等，通常受阻于政策、传统、观念、制度等。</p><p>特别是教育培训方面，目前的学校教育依然延续着工业时代的教学方式和考试制度，延续着数年甚至数十年不变的课程和教材，很多细节上都缺乏深思与变通。</p><p>早期中国人在竹签上刻字，后来用毛笔写字，现在还需要吗？在电脑时代，更多的文字创作将由电脑输入产生，是不是更应该学习的是打字或语音输入呢？而现在的学校教育依然是使用铅笔、钢笔写字，也许在不久的将来，回想起来才会发现这些细节的迟滞和落后。</p><p>如果你去问十个小学生，通常有九个都不喜欢写字，我认为写字这种方式未来并不会绝迹，就象毛笔字一样会变为一门艺术，只有少数对它情有独钟的人去练习和创作，而这通常会是在十多岁的少年时期才会有些人有兴趣去钻研的事，当然也可能象钢琴那样会成为少数人从小就开始苦练的一门手艺，不过考虑到硬笔书法的艺术性和难度，估计这种可能性不大，毕竟电脑设计领域已经可以将很多的优秀手写字体转化到电脑中了，只需要打字后切换一下字体就可以输出漂亮的硬笔书法体的文章了。</p><p>另一个方面就是教学方式了，互联网时代，知识的边界已经极大地扩展，人们基于兴趣可以在网上冲浪，可以通过一个个链接通向全新的领域和世界，未来的人才不再如工业时代那样统一和标准化，更加人性化、多样化、奇葩化，很多人基于自己的兴趣，可能会身兼数个你无法想象的技能组合，而这样的多样性才会给世界带来很多全新的创新思想和科技。因此我们的教学方式也应该变得更加符合这种发展的自然状态，也许：</p><ul><li>不再有课堂，而是一个自由上网、自由交流、自由合作的俱乐部；</li><li>不再有课程，而是遇到什么问题，解决什么问题，遇到什么兴趣，再观看什么教学视频，俱乐部的系统会记录学生的学习路径，适时地推送恰当的学习资料、视频和测试题等；</li><li>不再有专职的老师，而是集体学习、互相进步的社群，可以结伴前行，可以搭配协作，可以远程互助等，没有老师，所有人都在其中自学，同时又可能是每个人都是老师，在必要的时候教授别人相应的知识，解答别人相应的困惑，记录下自己的学习经验和感悟供他人参考……</li></ul><p>未来人类更加不需要顾虑物质生活的限制了，而人类会逐渐发现对物质生活追求而获得的满足感将会非常有限，毕竟一个人整天吃喝玩乐也持续不了多久，终归会落入空虚和无聊之中，而对于未知世界的探索将会填补这些需求，也就是人们会更倾向于对精神生活的追求，而精神世界的追求则是有无限的想象空间的，随着科技的发展，人们可以更随心所欲地发展个人的兴趣爱好，多数时间感觉更象是在玩耍中不断扩展自己的知识边界，也就是传统意义上的学习和提升，同时也会不断涉及到社会的高级工作中，因为低级工作通常已经被机器智能所代替了，人们在这些工作中创造出更多更灿烂的文化和科技等，使得人类文明进一步繁荣和发展……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;人类已经进入互联网时代，互联网对人类的很多方面产生了巨大而深远的影响，有些方面在商业和科技的促进下转变得比较快，比如电子商务、信息搜索、出行交通等，但有些方面就显得相对落后，如：政府效能、教育培训、人才评定等，通常受阻于政策、传统、观念、制度等。&lt;/p&gt;
&lt;p&gt;特别是教育培
      
    
    </summary>
    
    
    
      <category term="得到 App" scheme="http://wind13.github.io/tags/%E5%BE%97%E5%88%B0-App/"/>
    
      <category term="互联网时代" scheme="http://wind13.github.io/tags/%E4%BA%92%E8%81%94%E7%BD%91%E6%97%B6%E4%BB%A3/"/>
    
      <category term="教育" scheme="http://wind13.github.io/tags/%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>go 语言学习</title>
    <link href="http://wind13.github.io/2018/09/19/go-learn/"/>
    <id>http://wind13.github.io/2018/09/19/go-learn/</id>
    <published>2018-09-19T09:56:00.000Z</published>
    <updated>2018-11-10T16:55:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装、升级、卸载等"><a href="#安装、升级、卸载等" class="headerlink" title="安装、升级、卸载等"></a>安装、升级、卸载等</h2><ul><li><a href="https://golang.org/" target="_blank" rel="noopener">官网</a></li><li><a href="https://tour.go-zh.org/welcome/1" target="_blank" rel="noopener">中文官网教程</a></li><li><a href="https://wuyin.io/2018/06/11/golang-cheat-sheet/" target="_blank" rel="noopener">Golang 速查表</a></li><li>安装简单，按官网的说明来就好了，macOS 上就是下载个 pkg 的包双击安装即可。</li><li>卸载也简单，删除那个 <code>/usr/local/go</code> 的目录即可。</li><li>升级官网上没提，搜了一下基本就是先卸载再安装，我试了一下直接安装最新下载的也可以，会提示发现旧版本，确定后会自动卸载再安装。</li></ul><h2 id="国际惯例：Hello-world"><a href="#国际惯例：Hello-world" class="headerlink" title="国际惯例：Hello world!"></a>国际惯例：Hello world!</h2><ul><li>参考：<a href="http://www.cnblogs.com/ghj1976/archive/2013/03/24/2979668.html" target="_blank" rel="noopener">Go安装的设置问题：GOROOT，GOPATH</a></li><li>学习项目：<a href="https://github.com/wind13/golang-learn" target="_blank" rel="noopener">Learn golang notes</a></li></ul><h2 id="名词概念"><a href="#名词概念" class="headerlink" title="名词概念"></a>名词概念</h2><ul><li>程序实体：变量、常量、函数、结构体和接口等的统称。</li><li>标识符：各个程序实体的名字。可以是任何 Unicode 编码可以表示的字母字符（甚至中文，但不推荐）、数字以及下划线等，但首字母不能是数字。</li><li>命令源码文件：可以被直接运行，也包含程序实体。</li><li>库源码文件：不可以被直接运行，仅用于存放程序实体。</li><li>GOPATH：Go 语言的源码文件都需要存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。</li><li><code>*string</code> 是字符串的指针类型，而不是字符串类型。</li><li><code>:=</code> 是重定义变量类型并赋值，可以改变外部变量类型和值，而 <code>=</code> 只能赋给相同类型的值，类型不对时编译期会报错。</li><li>类似 toString() 方法的接口：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Channel and go routines, 同一时间只允许一个 go routine 访问 channel，所以可以用这个机制来进行安全稳定的 concurrency 并发编程。</li><li><code>go run -race main.go</code> Running with race detector. 使用竞跑模式运行，各 goroutine 会争抢优先级，方便发现一些隐藏的多 goroutine 运行时冲突问题。</li></ul><h2 id="初学者入门"><a href="#初学者入门" class="headerlink" title="初学者入门"></a>初学者入门</h2><p>极客时间的那个 《Go语言核心 36 讲》 显然不是针对初学者的，所以要先看看以下内容：</p><ul><li><a href="https://tour.golang.org" target="_blank" rel="noopener">官方教程</a></li></ul><h2 id="高级内容"><a href="#高级内容" class="headerlink" title="高级内容"></a>高级内容</h2><ul><li><a href="https://www.youtube.com/watch?v=QDDwwePbDtw" target="_blank" rel="noopener">Advanced Go Concurrency Patterns</a> 介绍了 goroutine 编程的一些高级模式和技巧，如： <ul><li>for select 循环</li><li>select nil channel case</li><li>run race detector</li><li>service channel, reply channels(chan chan error)</li></ul></li></ul><h2 id="Web-Framework"><a href="#Web-Framework" class="headerlink" title="Web Framework"></a>Web Framework</h2><ul><li><a href="https://iris-go.com/" target="_blank" rel="noopener">iris</a> 号称最快的 web 框架，因为基于fasthttp性能非常的好，需要考虑的是如果选它做web框架，你的代码将难以迁移到别的框架上,因为它实现了和标准库net/http不一样的接口。 看了一下文档，相当全面。</li><li><a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> The world’s fastest framework for building websites 静态网站生成器<ul><li><a href="https://jimmysong.io/posts/building-github-pages-with-hugo/" target="_blank" rel="noopener">零基础使用Hugo和GitHub Pages创建自己的博客</a> 非常专业的博客</li><li><a href="https://gohugo.io/getting-started/usage/" target="_blank" rel="noopener">Basic Usage</a> 基础使用方法介绍</li><li><a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/" target="_blank" rel="noopener">Host on GitHub</a> 官方文档</li></ul></li><li><a href="https://echo.labstack.com/" target="_blank" rel="noopener">Echo</a> 最流行的框架，功能、文档齐全</li><li><a href="http://revel.github.io/" target="_blank" rel="noopener">Revel</a> 全栈框架，但<a href="https://github.com/diyan/go-web-framework-comparsion" target="_blank" rel="noopener">据说</a>不太合 golang 的语法习惯。 借鉴的java和scala语言的 play框架 的很多想法。</li><li><a href="https://github.com/go-martini/martini" target="_blank" rel="noopener">Martini</a> <a href="https://www.restapiexample.com/rest-api-tutorial/golang-tutorial/popular-golang-web-framework-2017/" target="_blank" rel="noopener">据说</a>是最易用的 web 框架，是一个强大为了编写模块化Web应用而生的GO语言框架。</li><li><a href="https://github.com/urfave/negroni" target="_blank" rel="noopener">Negroni</a> 不是一个框架，它是为了方便使用 net/http 而设计的一个库而已。</li><li><a href="https://beego.me/" target="_blank" rel="noopener">Beego</a> 国人开发的一个使用 Go 的思维来帮助您构建并开发 Go 应用程序的开源框架</li><li><a href="https://www.do1618.com/archives/819/golang-web-framework/" target="_blank" rel="noopener">Golang Web FrameWork 比较</a></li><li><a href="http://fuxiaohei.me/2014/3/13/go-web-framework.html" target="_blank" rel="noopener">Go语言的Web框架</a></li><li><a href="https://colobu.com/2016/04/06/the-fastest-golang-web-framework/" target="_blank" rel="noopener">谁是最快的Go Web框架</a></li><li><a href="http://www.cnblogs.com/sunshine-anycall/p/4967432.html" target="_blank" rel="noopener">使用Golang（Margini）+Mongodb打造你的第一个站点</a></li></ul><h2 id="GraphQL"><a href="#GraphQL" class="headerlink" title="GraphQL"></a>GraphQL</h2><ul><li><a href="https://linux.cn/article-8524-1.html" target="_blank" rel="noopener">GraphQL 用例：使用 Golang 和 PostgreSQL 构建一个博客引擎 API</a></li><li><a href="https://github.com/nilstgmd/graphql-starter-kit" target="_blank" rel="noopener">GraphQL Starter Kit for GoLang</a> A GraphQL server example written in GoLang integrating with Cassandra and MongoDB.</li><li><a href="https://github.com/graphql-go/graphql" target="_blank" rel="noopener">graphql-go/graphql</a> An implementation of GraphQL for Go / Golang</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h3><ul><li>遇到 <code>no new variables on left side of :=</code> 报错，说明左边的变量被重复定义了，去上面的代码中找同名的变量，一定有，解决方法就是换个变量名。</li></ul><h3 id="通道锁死"><a href="#通道锁死" class="headerlink" title="通道锁死"></a>通道锁死</h3><ul><li><code>fatal error: all goroutines are asleep - deadlock!</code></li><li>一般发生在通道中没内容，而不断从通道取值时，另一种情况是向通道送值，但没放在单独的 goroutine 中。</li><li>解决思路，一个是将通道送值放在 go func 即 goroutine 中，另外就是取值用 for select 后要有退出机制，在恰当的条件时 return 就可以退出，实在没有合适的条件，可以用 time.After 设置超时退出。</li></ul><h2 id="文件组织规则"><a href="#文件组织规则" class="headerlink" title="文件组织规则"></a>文件组织规则</h2><ul><li>同目录的代码包声明要一致；</li><li>代码包声明可以与目录名称不同；</li><li>名称首字母大写的程序实体才可以被包外引用，否则只能被包内引用。</li><li>internal 代码包仅能被当前模块的其他代码引用，即模块级私有。</li><li>同目录中只能有一个入口函数 main，否则会被（vscode）警告，算是最佳实践吧。</li></ul><h2 id="Go-相关项目"><a href="#Go-相关项目" class="headerlink" title="Go 相关项目"></a>Go 相关项目</h2><ul><li><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 容器</li><li><a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">Cobra Cli</a> 开发命令行工具的工具，Go 语言的牛 X 工具。</li><li><a href="https://github.com/spf13/viper" target="_blank" rel="noopener">Viper</a> Go configuration with fangs! 管理配置文件的工具。</li><li><a href="https://github.com/spf13/afero" target="_blank" rel="noopener">Afero</a> A FileSystem Abstraction System for Go</li><li><a href="https://github.com/go-vgo/robotgo/blob/master/README_zh.md" target="_blank" rel="noopener">Robotgo</a> Golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听 </li></ul><h2 id="练习题：Web-Crawler"><a href="#练习题：Web-Crawler" class="headerlink" title="练习题：Web Crawler"></a>练习题：<a href="https://tour.golang.org/concurrency/10" target="_blank" rel="noopener">Web Crawler</a></h2><p>终于完成了整个学习，最后这道题记录如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Fetcher <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Fetch returns the body of URL and</span></span><br><span class="line"><span class="comment">// a slice of URLs found on that page.</span></span><br><span class="line">Fetch(url <span class="keyword">string</span>) (body <span class="keyword">string</span>, urls []<span class="keyword">string</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TIMEOUT = <span class="number">3</span></span><br><span class="line"><span class="keyword">const</span> MAX_DEPTH = <span class="number">4</span></span><br><span class="line"><span class="keyword">var</span> queue = <span class="built_in">make</span>(<span class="keyword">chan</span> Job)</span><br><span class="line"><span class="keyword">var</span> successes = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> errors = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">var</span> history = History&#123;h: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Job)&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">url   <span class="keyword">string</span></span><br><span class="line">depth <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// History is safe to use concurrently.</span></span><br><span class="line"><span class="keyword">type</span> History <span class="keyword">struct</span> &#123;</span><br><span class="line">h   <span class="keyword">map</span>[<span class="keyword">string</span>]Job</span><br><span class="line">mux sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inc increments the history</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *History)</span> <span class="title">Add</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">c.mux.Lock()</span><br><span class="line"><span class="comment">// Lock so only one goroutine at a time can access the map c.h.</span></span><br><span class="line">_, exist := c.h[url]</span><br><span class="line"><span class="keyword">if</span> !exist &#123;</span><br><span class="line">c.h[url] = Job&#123;url, depth&#125;</span><br><span class="line">queue &lt;- Job&#123;url, depth&#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mux.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchWeb</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> depth &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">body, uris, err := fetcher.Fetch(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// fmt.Println(err)</span></span><br><span class="line">errors &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;url: err.Error()&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fmt.Printf("found: %s %q\n", url, body)</span></span><br><span class="line">successes &lt;- <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;url: body&#125;</span><br><span class="line"><span class="keyword">for</span> _, u := <span class="keyword">range</span> uris &#123;</span><br><span class="line">history.Add(u, depth<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Crawl uses fetcher to recursively crawl</span></span><br><span class="line"><span class="comment">// pages starting with url, to a maximum of depth.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Crawl</span><span class="params">(url <span class="keyword">string</span>, depth <span class="keyword">int</span>, fetcher Fetcher)</span></span> &#123;</span><br><span class="line">quit := time.After(TIMEOUT * time.Second) <span class="comment">// Timeout</span></span><br><span class="line"><span class="comment">// Fetch URLs in parallel.</span></span><br><span class="line"><span class="comment">// Don't fetch the same URL twice.</span></span><br><span class="line"><span class="comment">// This implementation doesn't do either:</span></span><br><span class="line"><span class="keyword">go</span> history.Add(<span class="string">"https://golang.org/"</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> q := &lt;-queue:</span><br><span class="line"><span class="comment">// fmt.Println(q)</span></span><br><span class="line"><span class="keyword">go</span> fetchWeb(q.url, q.depth, fetcher)</span><br><span class="line"><span class="keyword">case</span> s := &lt;-successes:</span><br><span class="line"><span class="keyword">for</span> url, body := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(url, body)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> e := &lt;-errors:</span><br><span class="line"><span class="keyword">for</span> url, err := <span class="keyword">range</span> e &#123;</span><br><span class="line">fmt.Println(url, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Crawl(<span class="string">"https://golang.org/"</span>, MAX_DEPTH, fetcher)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fakeFetcher is Fetcher that returns canned results.</span></span><br><span class="line"><span class="keyword">type</span> fakeFetcher <span class="keyword">map</span>[<span class="keyword">string</span>]*fakeResult</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fakeResult <span class="keyword">struct</span> &#123;</span><br><span class="line">body <span class="keyword">string</span></span><br><span class="line">urls []<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fakeFetcher)</span> <span class="title">Fetch</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> res, ok := f[url]; ok &#123;</span><br><span class="line"><span class="keyword">return</span> res.body, res.urls, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"not found: %s"</span>, url)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetcher is a populated fakeFetcher.</span></span><br><span class="line"><span class="keyword">var</span> fetcher = fakeFetcher&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"The Go Programming Language"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Packages"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/cmd/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/fmt/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package fmt"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"https://golang.org/pkg/os/"</span>: &amp;fakeResult&#123;</span><br><span class="line"><span class="string">"Package os"</span>,</span><br><span class="line">[]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"https://golang.org/"</span>,</span><br><span class="line"><span class="string">"https://golang.org/pkg/"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装、升级、卸载等&quot;&gt;&lt;a href=&quot;#安装、升级、卸载等&quot; class=&quot;headerlink&quot; title=&quot;安装、升级、卸载等&quot;&gt;&lt;/a&gt;安装、升级、卸载等&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://golang.org/&quot; target
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>再见了 Redux （翻译）</title>
    <link href="http://wind13.github.io/2018/09/05/goodbye-redux-cn/"/>
    <id>http://wind13.github.io/2018/09/05/goodbye-redux-cn/</id>
    <published>2018-09-05T09:35:11.000Z</published>
    <updated>2018-09-05T10:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>作者：<a href="https://medium.com/@jackrobertscott" target="_blank" rel="noopener">Jack Scott</a> </p><p><a href="https://medium.com/@jackrobertscott/goodbye-redux-26e6a27b3a0b" target="_blank" rel="noopener">原文（英语）</a>  国内网可能访问不到……大致翻译如下：</p><p>本文主要分析了一下我们过去为什么需要 Redux，而为什么以后又不再需要了。</p><p><img src="https://upload-images.jianshu.io/upload_images/3664876-14f4fcccb131ca0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Goodbye Redux"></p><p>在过去的几年里，互联网技术已经转向用前端 JavaScript 框架来实现网站和手机应用，以达到更好的用户体验。这非常棒 🔥 ，我个人很欣赏这些框架提供的灵活性。</p><blockquote><p>但是灵活得是否有些过头了……</p></blockquote><p>为了能更好地理解这个问题，让我们把时钟拨回到 JavaScript 框架出现以前，看看我们是怎么开发应用的。</p><h2 id="⏳-JavaScript-以前的大陆-A-Land-Before-JavaScript…"><a href="#⏳-JavaScript-以前的大陆-A-Land-Before-JavaScript…" class="headerlink" title="⏳ JavaScript 以前的大陆 A Land Before JavaScript…"></a>⏳ JavaScript 以前的大陆 A Land Before JavaScript…</h2><p>在前几个前端框架（最值得注意的是AngularJS、Backbone和Ember）出现之前，我们只是在服务器上渲染模板，然后将完整的HTML页面发送到浏览器。当时流行的框架包括：</p><p><img src="https://upload-images.jianshu.io/upload_images/3664876-519ee7773ccf33c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sf, django, rails"></p><ul><li>Django (Python)——2005年7月21日发布 ~13 年前</li><li>Ruby on Rails —— 2005年12月13日发布 ~13 年前</li><li>Symphony (PHP) —— 2005年10月22日发布 ~13 年前</li></ul><p>这些框架主要是围绕了 MVC 概念也就是 Model-View-Controller 来开发的，Model 表示数据的模型，View 表示怎么显示这些数据，而 Controller 则连接这两部分。</p><blockquote><p>我的意思是说，这其中也有 JavaScript，但我们更多的时候是在说 jQuery 做的滑动条和一些完全没必要的动态网页效果</p></blockquote><p>在这些框架上编写的应用有一些问题，但总得来说还不错，直到有一天 Ryan Dahl 有了一个很棒的主意，他开发了第一版的 Node.js，可以让开发人员写服务端程序，而不止是用 JavaScript 做些愚蠢的动画。</p><ul><li>Node.js ——2009年5月27日发布 ~9 年前</li></ul><p>猛然间人们似乎看到了 JavaScript 的无限可能性，用一丁点儿的代码就能做很多事儿，这充分打开了其他开发人员的想象力，人们不仅创建更多强大的 Node.js 工具，还开始创建有趣的前端框架，在接下来的几年里，JavaScript 就象滚雪球一样高速发展起来：</p><p><img src="https://upload-images.jianshu.io/upload_images/3664876-f415e7981f12340a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AngularJS, Backbone.js, Ember.js"></p><ul><li>Express.js（后端）——2010年11月16日发布 ~8 年前</li><li>Backbone.js（前端）——2010年10月12日发布 ~8 年前</li><li>AngularJS（前端）——2010年10月20日发布 ~8 年前</li><li>Ember.js（前端）——2011年12月8日发布 ~8 年前</li></ul><p>这就开始了应用开发模式的重大转变。之前由服务端直接处理的 MVC 模式被分拆为两部分：一个服务端的 MC 和一个客户端的 V(MC)，客户端使用的就是上述的前端框架。在早期的这些框架中，还包含 Model 和 Controller 层在 View 中。两份 Model 和 Controller，前端也有一份 MC，这样看来是要写更多的代码了。</p><h2 id="🤦‍-脸书有个头疼的问题-Facebook-Had-A-Problem"><a href="#🤦‍-脸书有个头疼的问题-Facebook-Had-A-Problem" class="headerlink" title="🤦‍ 脸书有个头疼的问题 Facebook Had A Problem"></a>🤦‍ 脸书有个头疼的问题 Facebook Had A Problem</h2><p>正当所有人开心地使用上述方案的时候，Facebook 来了，随着它的迅速崛起，Facebook 变成了最大的网页应用，而为了解决页头上即时消息的数量显示问题（实际上这个小问题在海量用户使用的场景下是比较复杂的），旧的方案也并不能很好地应对……</p><p><img src="https://upload-images.jianshu.io/upload_images/3664876-6275231c73de14d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Facebook head aches"></p><p>于是他们推出了 React：</p><ul><li>React（前端） ——2013年 三月发布 ~5 年前</li></ul><p>而 React 只管 View 层，于是又有了 Flux，之后是 Redux（Redo Flux），有兴趣了解详情的可以看这个视频：</p><p><a href="https://v.youku.com/v_show/id_XMTU1MDg5OTQ1Ng==.html" target="_blank" rel="noopener">Youku视频</a>  <a href="https://v.qq.com/x/page/g0189w2yt1r.html" target="_blank" rel="noopener">QQ视频</a></p><h2 id="🍐-……于是这东西变得象个鸭梨-…Then-Things-Started-to-Go-Pear-Shaped"><a href="#🍐-……于是这东西变得象个鸭梨-…Then-Things-Started-to-Go-Pear-Shaped" class="headerlink" title="🍐 ……于是这东西变得象个鸭梨 …Then Things Started to Go Pear Shaped"></a>🍐 ……于是这东西变得象个鸭梨 …Then Things Started to Go Pear Shaped</h2><p>Redux 的工作方式是把一个应用中几乎所有的动态信息都保存在一个 JavaScript 对象中。这样不管你在应用的哪个地方看到的数据都来自同一个地方，也就能保持一致，这样也就解决了 Facebook 所头疼的问题。</p><p>于是突然又来了一种新框架：React + Redux 解决方案，Facebook 用它来解决问题，而从此以后所有人都过上了幸福的生活……对吗？</p><h2 id="✋-不尽然-Not-quite"><a href="#✋-不尽然-Not-quite" class="headerlink" title="✋ 不尽然 Not quite."></a>✋ 不尽然 Not quite.</h2><p>问题在于人们（包括我）开始用一个对象保存所有信息，其中的每一部分都是由服务端获得，没错这可以保证数据的及时更新，但同时也存在 3 个缺点：</p><ol><li>这需要大量的多余的代码才能很好地运行，这很浪费时间。</li><li>因为所有代码放在一处，这可能带来“旧数据”的问题，也就是说你可能在应用中见到一些来自之前状态的不想要的数据。</li><li>对于新的开发人员学习曲线太高，继而使得前端Web开发很难被新的开发人员采用。</li></ol><p>我们有一个向用户显示数据的相对简单的老式 MVC 框架应用，其中也就是几个简单的模板，在2005年，我们成功地将它转换为一个单页面应用，它的前端代码通常是后端代码的 10 倍。例如：我最近开发了一个简单的应用，然后我用 <a href="https://wakatime.com/" target="_blank" rel="noopener">WakaTime</a> 来衡量我在编码上的耗时情况，以下是测量结果：</p><ul><li>React Redux 前端代码库—— 32 小时.</li><li>Express + Mongoose 后端代码库——4 小时.</li></ul><h2 id="🤯-你当真？Are-you-serious"><a href="#🤯-你当真？Are-you-serious" class="headerlink" title="🤯 你当真？Are you serious??"></a>🤯 你当真？Are you serious??</h2><p>我花了 8 倍的时间在前端？让我们看看原因吧，下面是一个示例，一个很普通的取数据（例如取得所有用户）到前端的流程：</p><blockquote><p>🚧 警告：下面的步骤描述非常技术化，如果你看不太懂没关系。Warning: the following steps are super techy so don’t worry if you get lost.</p></blockquote><ol><li>创建一个组件来显示用户列表（这一步没啥问题）；</li><li>创建一个 <code>fetch</code> 请求到后端接口；</li><li>在 <code>state</code> 中添加一个新字段；</li><li>添加一个 <code>action</code> 用来更新 <code>state</code> 的数据；</li><li>添加一个 <code>thunk</code> 方法来运行 <code>fetch</code> 请求，然后使用新的 <code>action</code> 来更新 <code>state</code> 状态；</li><li>使用 <code>connect()</code> 将这个 <code>thunk</code> 方法加到组件中的 <code>dispatch</code> 方法中；</li><li>再次使用 <code>connect()</code> 从 <code>state</code> 中提取数据；</li><li>在组件的 <code>prop types</code> 属性类型中声明 <code>thunk</code> 方法和提取的数据字段；</li><li>在 <code>componentDidMount()</code> 方法中调用 <code>thunk</code> 方法；</li><li>最后，渲染数据到界面；</li></ol><p>我的天……10步，回到 Ruby on Rails 的时代，我只需要把数据放到 HTML 的模板中就完事儿了，达到的效果差不多，我想这中间肯定有什么问题吧？！</p><h2 id="☝️-一条新的路径-A-New-Approach"><a href="#☝️-一条新的路径-A-New-Approach" class="headerlink" title="☝️ 一条新的路径 A New Approach"></a>☝️ 一条新的路径 A New Approach</h2><p>Redux 只是解决了前端数据的一致性，但它也带来了如前所述的问题，那么它的价值到底是什么？</p><blockquote><p>基本上我们重写了整个前端只是解决了屈指可数的几个小问题。</p></blockquote><p>Facebook 也意识到了这个问题，启动了一个新项目叫 GraphQL，GraphQL 目前还是个技术名词，我不确定大家是否知道它为什么酷？</p><p>GraphQL 完全不同于 Redux，Facebook 又创造了一个大神级的产品，但却没指出这宝贝为什么这么重要，这也是为什么我花时间写此文的原因。</p><blockquote><p>简言之，如果说 Redux 是一匹马的话，GraphQL 就是一辆车。</p></blockquote><h3 id="什么？怎么-Redux-成了一匹马？"><a href="#什么？怎么-Redux-成了一匹马？" class="headerlink" title="什么？怎么 Redux 成了一匹马？"></a>什么？怎么 Redux 成了一匹马？</h3><p>我之所以把它们比做一匹马和一辆车，原因是这俩完全是两个物种，一个是有四条腿的马动物，一个是有四个轮子的机器。然而，它们的作用是一样的，都是把人运到想去的地方。虽然它们各自有不同的适合场景，但通常来说，汽车会更快些。</p><h3 id="那么，GraphQL-到底是什么？"><a href="#那么，GraphQL-到底是什么？" class="headerlink" title="那么，GraphQL 到底是什么？"></a>那么，GraphQL 到底是什么？</h3><p>官方文档是这样说的：“GraphQL 是一种 APIs 接口的查询语言”，感觉不清不楚的，其实他们所谓的查询语言基本上一个就可以替代上百个 HTTP 接口，因为这个技术还很新，所以文档和支持的技术还有点难懂，有一定的学习曲线。这儿给你一个例子看是否有帮助：</p><p>GraphQL 可以替代类似这样的接口：</p><ul><li>GET /users/1234567890</li><li>POST /cars</li><li>PUT /example/endpoints</li></ul><p>只查询你需要的字段，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  user(id: <span class="string">"1234567890"</span>) &#123;</span><br><span class="line">    name,</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;Luke Skywalker&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;luke@iamyourfather.com&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等一下——<strong>自定义的查询</strong>……这可是需要点儿时间去实现的，也许你这么认为~</p><p>但实际上不用，原因在于：由于只请求需要的数据，突然你不需要那么多服务端请求了，也就是说你不需要写那么多代码去处理那么多服务端请求了，于是，你就节省了大量不需要实现的代码和时间。</p><h2 id="🤷‍-但这就能替代-Redux-了吗？But-how-does-this-replace-Redux"><a href="#🤷‍-但这就能替代-Redux-了吗？But-how-does-this-replace-Redux" class="headerlink" title="🤷‍ 但这就能替代 Redux 了吗？But how does this replace Redux?"></a>🤷‍ 但这就能替代 Redux 了吗？But how does this replace Redux?</h2><p>问得好！简单地说，<strong>不能</strong>。不过，它鼓励你不要象 Redux 那样把所有信息存在一个单独的对象中，因为每个查询只针对应用的一小部分，而不是整个应用。在一整个应用的数据源中只关注一小部分，这应该算是个 <code>anti-pattern</code> 反模式、反常识（甚至是有点不合逻辑）的。</p><blockquote><p>通过使用 GraphQL 你就可以摆脱对 Redux 的依赖从而省掉大量的代码。</p></blockquote><p>还有一点要注意：Redux 和 GraphQL 是可以共存的，这样你可以平滑地过渡，这儿有一些关于两者整合的文章：</p><p><a href="https://s3.amazonaws.com/apollo-docs-1.x/redux.html" target="_blank" rel="noopener">Integrating with Redux | Apollo React Docs</a></p><p>用不用 Redux 变成一种选择。是用它解决一些小任务而面对头疼的问题，还是换一种方法完成那些任务？</p><h3 id="那么，你会怎么选择？"><a href="#那么，你会怎么选择？" class="headerlink" title="那么，你会怎么选择？"></a>那么，你会怎么选择？</h3><p>Redux 在当时确实解决了问题，但就在同时，Web 开发行业又在 <code>Web sockets</code> 领域有了巨大的进步。</p><p>Web sockets 是在服务端和客户端建立持续的连接，服务端就可以通知客户端何时更新。你猜怎么着？GraphQL 用一种叫 <code>subscriptions</code> 的订阅技术直接就能支持 web sockets，我们可以用这种 <code>subscriptions</code> 的订阅机制来更新应用中想保持同步的部分。</p><p>核心的区别在于：与其让客户端（用 Redux）告诉我们哪里要更新，不如让服务端直接通知客户端更新。结果是一样的，这儿有一些例子是怎么用 MongoDB 或 Mongoose 实现 Web socket 和 <code>subscriptions</code> 的。</p><p><a href="http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-change-streams.html" target="_blank" rel="noopener">A Node.js Perspective on MongoDB 3.6: Change Streams</a></p><p><a href="https://mongoosejs.com/docs/api.html#model_Model.watch" target="_blank" rel="noopener">Mongoose v5.2.12: API — Model.watch()</a></p><h2 id="🚀-未来很精彩！The-Future-Looks-Awesome"><a href="#🚀-未来很精彩！The-Future-Looks-Awesome" class="headerlink" title="🚀 未来很精彩！The Future Looks Awesome!"></a>🚀 未来很精彩！The Future Looks Awesome!</h2><p>GraphQL 开发没多久，但眼下也可以用在产品上了。我不想撒谎，官方文档确实能把人搞晕，需要对 JavaScript 和 服务端运行机制有很强的理解才行。然而如果你还没那么强，但想了解更多，这有一个很流行的教程：</p><p><a href="https://graphql.org/learn/" target="_blank" rel="noopener">GraphQL: A query language for APIs.</a></p><p>还有很多有用的库可以帮你逐步地整合 GraphQL 到已有产品中。不用担心，你不用一次弄完，这些库可以帮你轻松地、慢慢地改善你的应用。Apollo 就是一家做这事儿的公司。</p><p><a href="https://www.apollographql.com/" target="_blank" rel="noopener">Apollo GraphQL</a></p><p>好了，我希望这篇文章可以对阐明一些复杂的概念有帮助。</p><p>如果你喜欢这篇文章，请点赞——这对我来说是很大的鼓励——或者有问题请留言。</p><p>谢谢！🙌 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：&lt;a href=&quot;https://medium.com/@jackrobertscott&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jack Scott&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@jackr
      
    
    </summary>
    
    
    
      <category term="react" scheme="http://wind13.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://wind13.github.io/tags/redux/"/>
    
      <category term="graphql" scheme="http://wind13.github.io/tags/graphql/"/>
    
  </entry>
  
  <entry>
    <title>在 vscode 的 vi 模式下，按中文标点移动光标的方法</title>
    <link href="http://wind13.github.io/2018/08/27/vscode-vi-segment-chinese-punctuation/"/>
    <id>http://wind13.github.io/2018/08/27/vscode-vi-segment-chinese-punctuation/</id>
    <published>2018-08-27T10:03:51.000Z</published>
    <updated>2018-08-27T10:07:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>首先，vscode 是目前最好的编程工具，未来前途也无可限量，其次 vi 的快捷键模式也是最高效的键盘输入模式，在 vscode 中可以添加 vi 快捷键的支持（在首选项-按键映射扩展中可以安装 Vim 即可，或在插件商店搜索：<code>@recommended:keymaps</code> 也能添加）。</p><p>但是在编辑中文时会有一个问题：</p><p>因为英文单词是由空格隔开的，所以在 vi 模式时按 w 键天然是能按单词移动的，而中文字句是连在一起的，所以会在移动光标时，整段中文字直接跳过，非常不符合使用的习惯。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 vscode 的用户设置（在 macOS 中按 Cmd + , 编辑）中添加这两项即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;editor.wordSeparators&quot;: &quot;`~!@#$%^&amp;*()-=+[&#123;]&#125;\\|;:&apos;\&quot;,.&lt;&gt;/?，。；、：“”！？《》【】……￥&quot;,</span><br><span class="line">&quot;vim.iskeyword&quot;: &quot;/\\()\&quot;&apos;:,.;&lt;&gt;~!@#$%^&amp;*|+=[]&#123;&#125;`?-，。；、：“”！？《》（）【】……￥&quot;,</span><br></pre></td></tr></table></figure><p>前面都是默认的，后面只是添加上了中文的标点符号，这样就不会整段移动，而是在中文标点处停止再继续，基本符合使用的习惯了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;首先，vscode 是目前最好的编程工具，未来前途也无可限量，其次 vi 的快捷键模式也是最高效的键盘输入模式，在 vsco
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>如何保持专注高效地工作</title>
    <link href="http://wind13.github.io/2018/07/31/how-to-focus-work/"/>
    <id>http://wind13.github.io/2018/07/31/how-to-focus-work/</id>
    <published>2018-07-31T10:19:58.000Z</published>
    <updated>2018-07-31T10:19:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题和现象"><a href="#问题和现象" class="headerlink" title="问题和现象"></a>问题和现象</h2><p>小张喜欢做运维技术研究，特别是最新的 k8s 技术，在应聘时选择了一家公司，就是因为这家公司有相关的 k8s 方面的技术栈，然而到了这家公司一段时间后，感觉最近工作越来越压力大，越来越不顺利。</p><p>具体的一个事例是这样的，公司需要安装一套监控系统，小张本来是会直接部署服务器的，然而对技术的热爱，让他想去尝试用 docker 来实现部署，于是选择了用这个方案开始尝试，然而因为懂这方面技术的同事并不多，他只能一个人研究摸索，在这期间遇到很多技术难题，有些解决了，有些迟迟解决不了，也没有人可以讨论沟通，一个人在网上搜寻答案效率非常低。 同时公司其他同事还会因为各类大小不同的软硬件故障、系统问题时不时来打扰他，他也基本都热心去帮助解决，小张是一个遇到技术问题就想去解决的偏执狂，但这样也就会占用很多的工作时间，一转眼两周时间过去了，公司领导问监控系统的情况，得知居然还没有完成时，非常不满意，责令他当天必须完成，此时，小张感受到了无限的压力还有一肚子的委屈，却又不知道跟谁说理去，可谓“身心俱疲”啊！</p><p>分析以上情况，我给予两方面的建议如下：</p><h2 id="一、怎么安排好重要的工作？"><a href="#一、怎么安排好重要的工作？" class="headerlink" title="一、怎么安排好重要的工作？"></a>一、怎么安排好重要的工作？</h2><p>在接到公司安排的工作后，要做如下思考：</p><ol><li>公司为什么要做这个？对公司的意义在哪里？</li><li>预期的完成时间大概是什么时间？</li><li>预期的完成状态是什么样子？</li></ol><p>比如上例中，可能的答案是这样的：</p><ol><li>监控系统，这事对公司挺重要，即便技术上没什么难度，但多了决策的依据，所以对公司业务分析和决策很有意义，或者对于把控服务器的状态有很大的帮助，作为运维环节，监控系统也是必不可少的。</li><li>预期的完成时间，最长是一周，如果不顺利两周内怎么说也是要完成的。同时也可以跟公司沟通一下具体的期望完成时间。</li><li>预期完成的状态，其实要求并不高，只要先有一个监控数据界面就好了，后面有机会可以不断优化。公司并没有强调是不是用 docker 来容器化。</li></ol><p>通过沟通和分析得到以上问题的答案后，就可以将这件事安排到自己的工作面板中了，工作面板分为四列：Backlog（任务池）、待处理、处理中和已完成。</p><ol><li>Backlog（任务池）： 这里通常堆了一堆想要做的事情、别人安排的事情，但是目前一定还没有开始的事情。</li><li>待处理： 这里通常是近期准备开始的事情，相应的解决方案、配套资源都已经到位，都知道详细的需求了，没有什么阻碍和问题了，只差的是具体的执行和操作了，通常这里的任务是要有预估完成时间、具体的执行人员安排以及优先次序的排列的。</li><li>处理中： 这里通常一个人只有一件正在做的事，也就是当下优先级最高的事情，可以按一定的周期（如：每天）更新完成状态（如：完成35%，或 2/5 表示共有5个子步骤/任务，已经完成 2 个。）</li><li>已完成： 已经交出结果，并通过验收的任务，没什么好说的，可以记录下实际的完成时间，未来可用于复盘或与预计完成时间对比和参考，不断调整预估的准确性。</li></ol><p>如果有些重要的工作环节比较多比较复杂，就需要拆分成多个任务放在上面的面板中，通常一个任务持续时间不要超过两天，但也不要短过半小时（即一个番茄钟的时间）。</p><h2 id="二、怎么处理干扰多的情况？"><a href="#二、怎么处理干扰多的情况？" class="headerlink" title="二、怎么处理干扰多的情况？"></a>二、怎么处理干扰多的情况？</h2><p>在公司工作，难免会有同事之间的协作，也就难免出现同事来打扰说事儿，首先不要在情绪上反感和讨厌这类打扰，通常来说这类打扰都是一次很好的机会，什么机会呢？</p><ol><li>了解公司问题、现状、同事的困难、业务的阻碍等；</li><li>表现你解决问题的能力、掌握的技术等的机会；</li><li>同事加强协作的机会，现在你帮他，也许哪天你也需要他帮你；</li></ol><p>如果哪一天你发现，再也没人来打扰你了，估计反倒是个危险的信号，你可能要离开这家公司了，同事们已经不再需要你了。</p><p>那么干扰太多又会占用很多时间，影响正常的工作进度怎么办？以下列出处理的具体步骤：</p><ol><li>当前是否在番茄工作中，如果是，礼貌地告知来访同事正在忙，大概15分钟后去找他；</li><li>如果不在番茄工作中，或者番茄工作完后，就主动去找来访同事，花10分钟了解问题缘由；</li><li>如果预估 5 分钟内可以解决，那就现场解决；</li><li>如果预估比较麻烦或者尝试了 5 分钟后仍不能解决，就给同事说明情况，告知问题的处理现状和可能原因，但要解决也许需要更多的时间和资源，需要另行安排。</li><li>在 4 的情况时，就要把问题和事情记录下来，也就是添加到 Backlog 一栏中，同时与当前手头的工作（即进行中那一栏的工作，通常只能有一件事）比较一下优先级，如果优先级不高，就继续手头的工作。</li><li>Backlog 中的工作最好也能排出优先级，最好能有预估的时间，初期可以给自己稍微宽松一些的期限设定，按照自己的工作时间来排程，比如：明天上午完成 A 事件，明天下午完成 B 事件，后天一天完成 C 事件的一半，大后天彻底完成 C 等。这样，你就可以给相应的同事或领导回报你的安排，如：“张总，您说的 C 事件，按我手头工作的排序，预计在后天开始，大后天完成，到时候需要您配合给我一台测试的电脑……您看怎么样？”，如果张总觉得不行，后天太迟，你可以把你当前的安排呈现给他，跟他沟通：“张总，您看，这是李总安排的 A 事件，还有王总安排的 B 事件，我预估顺利的话，明天一天也是要被占用的，如果您这事更急，可能需要您跟李总和王总一起商量一下，看我这边最优先做哪件。”</li><li>一旦最终商讨后定下了新的计划，就可以把新的时间安排以适当的形式（如：邮件、或公司的工作平台等）通知相关人员。</li></ol><p>相信以上思路可以给出一些启发性的思路，具体的工作还要具体分析，但总的原则要抓住，那些影响高效专注工作的问题，都是有办法解决的，不急不燥，保持自律（戒除“贪、嗔、痴”，哈哈……），总是能够解决的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题和现象&quot;&gt;&lt;a href=&quot;#问题和现象&quot; class=&quot;headerlink&quot; title=&quot;问题和现象&quot;&gt;&lt;/a&gt;问题和现象&lt;/h2&gt;&lt;p&gt;小张喜欢做运维技术研究，特别是最新的 k8s 技术，在应聘时选择了一家公司，就是因为这家公司有相关的 k8s 方面的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Ant Design React 使用记录</title>
    <link href="http://wind13.github.io/2018/07/26/Ant-Design-React-Note/"/>
    <id>http://wind13.github.io/2018/07/26/Ant-Design-React-Note/</id>
    <published>2018-07-26T09:22:11.000Z</published>
    <updated>2018-07-27T01:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="Table-组件的服务端分页问题"><a href="#Table-组件的服务端分页问题" class="headerlink" title="Table 组件的服务端分页问题"></a>Table 组件的服务端分页问题</h3><ul><li><a href="http://09x.ant.design/components/table/" target="_blank" rel="noopener">Table 表格</a></li></ul><p>仔细看了一下，虽然 mock 中的数据是全部数据集，但是是模拟远程数据库的概念的，每次返回到客户端的数据还是单个页面的数据，所以这里可以理解为本身的设计就是支持服务端分页的。</p><h3 id="路由带参数问题"><a href="#路由带参数问题" class="headerlink" title="路由带参数问题"></a>路由带参数问题</h3><ul><li><a href="https://reacttraining.com/react-router/web/api/Route/route-props" target="_blank" rel="noopener">Route props - match</a></li></ul><h3 id="下载-Excel-模板的问题"><a href="#下载-Excel-模板的问题" class="headerlink" title="下载 Excel 模板的问题"></a>下载 Excel 模板的问题</h3><ul><li><a href="http://www.hacksparrow.com/using-node-js-to-download-files.html" target="_blank" rel="noopener">Using Node.js to download files</a></li></ul><h3 id="后端文档路径：-http-jp-open-service-thinkmacro-cn-swagger-ui-html"><a href="#后端文档路径：-http-jp-open-service-thinkmacro-cn-swagger-ui-html" class="headerlink" title="后端文档路径： http://jp-open-service.thinkmacro.cn/swagger-ui.html"></a>后端文档路径： <a href="http://jp-open-service.thinkmacro.cn/swagger-ui.html" target="_blank" rel="noopener">http://jp-open-service.thinkmacro.cn/swagger-ui.html</a></h3><h3 id="Form-相关参考：-http-react-component-github-io-form"><a href="#Form-相关参考：-http-react-component-github-io-form" class="headerlink" title="Form 相关参考： http://react-component.github.io/form/"></a>Form 相关参考： <a href="http://react-component.github.io/form/" target="_blank" rel="noopener">http://react-component.github.io/form/</a></h3><h3 id="Post-提交跨域问题："><a href="#Post-提交跨域问题：" class="headerlink" title="Post 提交跨域问题："></a>Post 提交跨域问题：</h3><ul><li>遇到 <code>Failed to load http://jp-open-service.thinkmacro.cn/login: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested</code></li><li>post 请求后，得到这个返回，是不是又是跨域问题？</li><li>发现问题，接口是用 query 传参的</li><li>又发现：如果密码正确，就有那项，如果密码不对，报500错就没有了。</li><li>估计是抛出异常时走了不同的代码逻辑。</li></ul><h3 id="解决向-route-子组件统一传参的问题："><a href="#解决向-route-子组件统一传参的问题：" class="headerlink" title="解决向 route 子组件统一传参的问题："></a>解决向 route 子组件统一传参的问题：</h3><ul><li><a href="https://stackoverflow.com/questions/32370994/how-to-pass-props-to-this-props-children" target="_blank" rel="noopener">How to pass props to {this.props.children}</a></li><li><a href="https://stackoverflow.com/questions/31862839/passing-props-to-react-router-children-routes" target="_blank" rel="noopener">Passing props to React Router children routes</a></li></ul><h3 id="解决子组件中定义-meta-属性的需求："><a href="#解决子组件中定义-meta-属性的需求：" class="headerlink" title="解决子组件中定义 meta 属性的需求："></a>解决子组件中定义 meta 属性的需求：</h3><ul><li><a href="https://github.com/nfl/react-helmet" target="_blank" rel="noopener">react-helmet</a> A document head manager for React</li><li><a href="https://github.com/kodyl/react-document-meta" target="_blank" rel="noopener">React Document Meta</a> HTML meta tags for React-based apps.</li></ul><h2 id="相关文档资料"><a href="#相关文档资料" class="headerlink" title="相关文档资料"></a>相关文档资料</h2><ul><li><a href="http://reactkungfu.com/2016/03/dive-into-react-codebase-handling-state-changes/" target="_blank" rel="noopener">Dive into React codebase: Handling state changes</a> 深入了解 React 的状态变化机制</li><li><a href="https://www.jianshu.com/p/4784216b8194" target="_blank" rel="noopener">React组件生命周期小结</a></li><li><a href="https://github.com/AlanWei/blog/issues/10" target="_blank" rel="noopener">React v16.3 版本新生命周期函数浅析及升级方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;遇到的问题&quot;&gt;&lt;a href=&quot;#遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;遇到的问题&quot;&gt;&lt;/a&gt;遇到的问题&lt;/h2&gt;&lt;h3 id=&quot;Table-组件的服务端分页问题&quot;&gt;&lt;a href=&quot;#Table-组件的服务端分页问题&quot; class=&quot;
      
    
    </summary>
    
    
    
      <category term="antd" scheme="http://wind13.github.io/tags/antd/"/>
    
      <category term="react" scheme="http://wind13.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://wind13.github.io/tags/redux/"/>
    
      <category term="react-route" scheme="http://wind13.github.io/tags/react-route/"/>
    
  </entry>
  
  <entry>
    <title>白话理解 Node.js 异步单线程</title>
    <link href="http://wind13.github.io/2018/05/22/baihua-async/"/>
    <id>http://wind13.github.io/2018/05/22/baihua-async/</id>
    <published>2018-05-22T10:37:39.000Z</published>
    <updated>2018-05-23T03:30:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 和 Node.js 都是多进程单线程的。它通过事件轮询（event loop <a href="http://www.runoob.com/nodejs/nodejs-event-loop.html" target="_blank" rel="noopener">Node.js 事件循环</a>）来实现并行操作，因此，我们要尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。参考 <a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/" target="_blank" rel="noopener">Understanding the node.js event loop</a></p><p>主线程和子线程，这里说的单线程，是说主线程只有一个，所以要把阻塞的运算处理分拆到子线程中去运行。</p><ul><li>使用回调函数</li><li>以非阻塞操作进行请求响应</li></ul><h2 id="几种可能的响应网络请求的方式："><a href="#几种可能的响应网络请求的方式：" class="headerlink" title="几种可能的响应网络请求的方式："></a>几种可能的响应网络请求的方式：</h2><ul><li>同步；最简单，但一个访问会阻塞其他访问；</li><li>分出新进程；还算简单，但大量的访问请求意味着大量的进程，会占用大量内存资源；</li><li>多线程；比较复杂，有些机器不支持线程，随着线程的增加，编程复杂度的增加也是很可怕的，很快就不知道怎么控制线程间的共享资源了。另外，线程占用内存会随请求数量增加快速增加，这也是为什么 Apache 比 Nginx 响应同样数量请求时占用更多的内存的原因。</li><li>单线程异步回调；也算简单，通过异步调用将主线程的任务分派到子线程中，通过回调函数来实现任务完成后的通知主线程及执行后续任务。</li></ul><h2 id="白话理解"><a href="#白话理解" class="headerlink" title="白话理解"></a>白话理解</h2><p>假设我们想做机器人卖米线的生意，我们要给机器人编程序，有煮米线的程序、收钱找钱的程序、擦桌子收碗的程序、端盘上饭的程序等。</p><p>同步的程序是最容易编写的，就是一件一件地做，一项一项地完成，一个步骤一个步骤地操作等。</p><p>那么同步的方式会带来什么问题呢？就是每来一个顾客请求，我们就开始处理这个请求，不理其他顾客甚至当前顾客的其他请求，如果当前的事情是比较费时的，比如煮米线，那么就会阻塞其他所有请求和顾客，这显然是不能接受的。</p><p>那么新进程的方式是什么意思呢？就好比复制多开了很多个米线摊，其他顾客的请求自然可以由其他米线摊来处理，但显然这很浪费资源，只有在需要开分店的时候才比较合适，那就是分布式架构加负载均衡所解决的问题了。但我们不能在一个店还没开好（高效运转）的时候就去搞连锁，那样会亏死的，所以先要把一个店的运转高效起来再说。</p><p>那么多线程的方式呢？可以想象就是一个摊儿或店，但雇佣了多个人，有人收钱，有人煮米线，但每个服务仍是同步单线程状态、即初级机器人水平，也就是说只专心做手头的事，做完一件事才做下一件事。</p><p>单线程异步回调的方式呢？就好像来了一个灵活的（机器）人（主线程），他来操作其他机器人，他接受请求，再命令其他专业的机器人做，然后他就又接受下一个请求……</p><p>这样就需要其他机器人是可以接受命令的，而煮米线机器人原来的方法是同步的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 口味: 大/小份,</span></span><br><span class="line"><span class="comment"> * 份量: 麻辣/三鲜</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">煮米线(口味, 份量) &#123;</span><br><span class="line">  花 <span class="number">5</span> 分钟煮一碗 此口味 此份量 的米线;</span><br><span class="line">  <span class="keyword">return</span> 米线；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需求参数：</span></span><br><span class="line"><span class="comment"> *  口味: 大/小份,</span></span><br><span class="line"><span class="comment"> *  份量: 麻辣/三鲜</span></span><br><span class="line"><span class="comment"> * 完事儿干啥：</span></span><br><span class="line"><span class="comment"> *  callback 回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">煮米线(&#123;需求参数&#125;, 完事儿干啥) &#123;</span><br><span class="line">  花 <span class="number">5</span> 分钟煮一碗 需求参数.此口味 需求参数.此份量 的米线;</span><br><span class="line">  call 完事儿干啥();</span><br><span class="line">&#125;</span><br><span class="line">下单米线(某口味, 某份量, 服务员) &#123;</span><br><span class="line">  煮米线(&#123;口味: 某口味, 份量:某份量&#125;, 服务员.上菜);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下单米线(三鲜, 小份, 服务员A);</span><br><span class="line">下单米线(麻辣, 大份, 服务员B);</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">煮一碗 小份 三鲜 米线</span><br><span class="line">服务员A 端给客人</span><br></pre></td></tr></table></figure><h2 id="For-循环也要注意阻塞问题"><a href="#For-循环也要注意阻塞问题" class="headerlink" title="For 循环也要注意阻塞问题"></a>For 循环也要注意阻塞问题</h2><h3 id="以下示例证明-for-循环较大时会是个阻塞操作，同时证明-Node-js-是单线程的。"><a href="#以下示例证明-for-循环较大时会是个阻塞操作，同时证明-Node-js-是单线程的。" class="headerlink" title="以下示例证明 for 循环较大时会是个阻塞操作，同时证明 Node.js 是单线程的。"></a>以下示例证明 for 循环较大时会是个阻塞操作，同时证明 Node.js 是单线程的。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proveSingleBlock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now();<span class="comment">//获取当前时间戳</span></span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000000</span>; i++)&#123;<span class="comment">//执行长循环</span></span><br><span class="line">      n = n+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 Node.js 中就需要将如下的耗时较长的 for 循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">block</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> x = <span class="number">0</span> ; x &lt; <span class="number">1000000000</span>; x++)&#123;</span><br><span class="line">    <span class="comment">//do something crazy.</span></span><br><span class="line">    n = n+x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写为下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noblock</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = block();</span><br><span class="line">    <span class="keyword">if</span> (callback) &#123; callback(r); &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> start = <span class="built_in">Date</span>.now();<span class="comment">//获取当前时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// block version</span></span><br><span class="line"><span class="built_in">console</span>.log(block());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Block version:'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// no block setTimeout version</span></span><br><span class="line"><span class="built_in">console</span>.log(noblock(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(r);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'No block version:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Main end:'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.now() - start);</span><br></pre></td></tr></table></figure><h2 id="使用-ES6-的-Promise-实现异步"><a href="#使用-ES6-的-Promise-实现异步" class="headerlink" title="使用 ES6 的 Promise 实现异步"></a>使用 ES6 的 Promise 实现异步</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#link'</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Enter"</span>);</span><br><span class="line">    <span class="keyword">var</span> asyncFunct = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">'#link'</span>).animate(&#123; <span class="attr">width</span>: <span class="number">200</span> &#125;, <span class="number">2000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"finished"</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    asyncFunct.then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Exit"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>还有 async/await, generator/yield 等</p><h2 id="多线程方案"><a href="#多线程方案" class="headerlink" title="多线程方案"></a>多线程方案</h2><h3 id="用-libuv-库来支持多线程"><a href="#用-libuv-库来支持多线程" class="headerlink" title="用 libuv 库来支持多线程"></a>用 libuv 库来支持多线程</h3><p>如果我们非要让 Node.js 支持多线程，还是提倡使用官方的做法，利用 libuv 库来实现。</p><blockquote><p>libuv是一个跨平台的异步I/O库，它主要用于 Node.js 的开发，同时他也被Mozilla’s Rust language, Luvit, Julia, pyuv等使用。它主要包括了Event loops事件循环， Filesystem 文件系统， Networking 网络支持， Threads 线程， Processes 进程， Utilities 其他工具。</p></blockquote><h3 id="tagg2模块-threads-a-gogo-库"><a href="#tagg2模块-threads-a-gogo-库" class="headerlink" title="tagg2模块 threads_a_gogo 库"></a>tagg2模块 <a href="https://github.com/xk/node-threads-a-gogo" target="_blank" rel="noopener">threads_a_gogo</a> 库</h3><p><a href="https://cnodejs.org/topic/518b679763e9f8a5424406e9" target="_blank" rel="noopener">threads_a_gogo 实现 nodejs 多线程，真正的非阻塞</a></p><h2 id="多进程方案"><a href="#多进程方案" class="headerlink" title="多进程方案"></a>多进程方案</h2><p>在支持 html5 的浏览器里，我们可以使用 webworker 来将一些耗时的计算丢入 worker 进程中执行，这样主进程就不会阻塞，用户也就不会有卡顿的感觉了。在 Node.js 中是否也可以使用这类技术，保证主线程的通畅呢？</p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h3><p>cluster可以用来让 Node.js 充分利用多核 cpu 的性能，同时也可以让 Node.js 程序更加健壮，官网上的 cluster 示例已经告诉我们如何重新启动一个因为异常而崩溃的子进程。</p><h3 id="webworker"><a href="#webworker" class="headerlink" title="webworker"></a>webworker</h3><p>想要像在浏览器端那样启动 worker 进程，我们需要利用 Node.js 核心 api 里的 child_process 模块。 child_process 模块提供了 fork 的方法，可以启动一个 Node.js 文件，将它作为 worker 进程，当 worker 进程工作完毕，把结果通过 send 方法传递给主进程，然后自动退出，这样我们就利用了多进程来解决主线程阻塞的问题。</p><h2 id="多进程和多线程"><a href="#多进程和多线程" class="headerlink" title="多进程和多线程"></a>多进程和多线程</h2><p>大部分多线程解决 cpu 密集型任务的方案都可以用我们之前讨论的多进程方案来替代，但是有一些比较特殊的场景多线程的优势就发挥出来了，比如 http web 服务器响应静态文件的例子。</p><p>以 express 处理小型静态文件为例，大致的处理流程如下：</p><ol><li>首先获取文件状态，判断文件的修改时间或者判断 etag 来确定是否响应 304 给客户端，让客户端继续使用本地缓存。</li><li>如果缓存已经失效或者客户端没有缓存，就需要获取文件的内容到 buffer 中，为响应作准备。</li><li>然后判断文件的 MIME 类型，如果是类似 html, js, css 等静态资源，还需要 gzip 压缩之后传输给客户端。</li><li>最后将 gzip 压缩完成的静态文件响应给客户端。</li></ol><p>用 ifile 包能得到 10 倍的速度和效率，不过 express 的作者TJ 说：</p><blockquote><p>请牢记你可能不需要这么高等级吞吐率的系统，就算是每月百万级别下载量的 npm 网站，也仅仅每秒处理 17 个请求而已，这样的压力甚至于 PHP 也可以处理掉（又黑了一把 php ）。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单线程的 Node.js 给我们编码带来了太多的便利和乐趣，我们应该时刻保持清醒的头脑，在写 Node.js 代码中切不可与 PHP 混淆，任何一个隐藏的问题都可能击溃整个线上正在运行的 Node.js 程序。</p><p>单线程异步的 Node.js 不代表不会阻塞，在主线程做过多的任务可能会导致主线程的卡死，影响整个程序的性能，所以我们要非常小心的处理大量的循环，字符串拼接和浮点运算等 cpu 密集型任务，合理的利用各种技术把任务丢给子线程或子进程去完成，保持 Node.js 主线程的畅通。</p><p>线程/进程的使用并不是没有开销的，尽可能减少创建和销毁线程/进程的次数，可以提升我们系统整体的性能和出错的概率。</p><p>最后请不要一味的追求高性能和高并发，因为我们可能不需要系统具有那么大的吞吐率。高效，敏捷，低成本的开发才是项目所需要的，这也是为什么 Node.js 能够在众多开发语言中脱颖而出的关键。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://www.jianshu.com/p/1887d9b446b2" target="_blank" rel="noopener">js的单线程和多进程</a></li><li><a href="https://github.com/DoubleSpout/threadAndPackage/blob/master/chapter.7.thread_and_process.md" target="_blank" rel="noopener">Node.js的线程和进程</a></li><li><a href="https://stackoverflow.com/questions/9516900/how-can-i-create-an-asynchronous-function-in-javascript" target="_blank" rel="noopener">How can I create an Asynchronous function in Javascript?</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx 和 Node.js 都是多进程单线程的。它通过事件轮询（event loop &lt;a href=&quot;http://www.runoob.com/nodejs/nodejs-event-loop.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GraphQL 学习</title>
    <link href="http://wind13.github.io/2018/05/03/GraphQL-learning/"/>
    <id>http://wind13.github.io/2018/05/03/GraphQL-learning/</id>
    <published>2018-05-03T08:55:25.000Z</published>
    <updated>2018-06-27T09:15:55.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li><a href="https://www.compose.com/articles/using-graphql-with-mongodb/" target="_blank" rel="noopener">Using GraphQL with MongoDB</a></li><li><a href="https://medium.com/entria/testing-a-graphql-server-using-jest-4e00d0e4980e" target="_blank" rel="noopener">Testing a GraphQL Server using Jest</a></li><li><a href="https://github.com/gajus/gajus.com-blog/blob/master/posts/using-dataloader-to-batch-requests/index.md" target="_blank" rel="noopener">using-dataloader-to-batch-requests</a></li><li><a href="https://hackernoon.com/how-graphql-replaces-redux-3fff8289221d" target="_blank" rel="noopener">How GraphQL Replaces Redux</a></li><li><a href="https://www.apollographql.com/client/" target="_blank" rel="noopener">js Client</a> Bind GraphQL data to your UI with one function call.</li></ul><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><ul><li><a href="http://graphql.cn/" target="_blank" rel="noopener">GraphQL CN</a> A query language for APIs. 一种用于 API 的查询语言。</li><li><a href="http://graphql.cn/learn/best-practices/" target="_blank" rel="noopener">GraphQL 最佳实践</a></li><li><a href="https://github.com/chentsulin/awesome-graphql" target="_blank" rel="noopener">awesome-graphql</a></li><li><a href="https://www.howtographql.com/" target="_blank" rel="noopener">The Fullstack Tutorial for GraphQL</a> Youtube 视频教程</li><li><a href="https://github.com/graphql/graphiql" target="_blank" rel="noopener">GraphiQL</a> A graphical interactive in-browser GraphQL IDE. <a href="http://graphql.org/swapi-graphql" target="_blank" rel="noopener">Live demo</a></li><li><a href="https://lacinia.readthedocs.io/en/latest/" target="_blank" rel="noopener">Lacinia</a> - GraphQL for Clojure，<a href="https://github.com/walmartlabs/lacinia" target="_blank" rel="noopener">Github Repo</a> 一套 GraphQL 规范的完整实现，致力于维护对规范的外部兼容。</li><li><a href="https://github.com/alumbra/alumbra" target="_blank" rel="noopener">alumbra</a> Simple &amp; Elegant GraphQL for Clojure!</li><li><a href="https://github.com/tendant/graphql-clj" target="_blank" rel="noopener">graphql-clj</a> A Clojure library designed to provide GraphQL implementation.</li><li><a href="http://graphql.cn/code" target="_blank" rel="noopener">流行的服务端框架、客户端库、服务</a></li><li><a href="https://dev-blog.apollodata.com/getting-started-with-typescript-and-apollo-a9aa2c7dcf87" target="_blank" rel="noopener">Getting started with TypeScript and Apollo</a></li><li><a href="https://facebook.github.io/relay/" target="_blank" rel="noopener">Relay</a> A JavaScript framework for building data-driven React applications</li><li><a href="https://github.com/swannodette/om-datascript" target="_blank" rel="noopener">Om Next w/ DataScript</a></li><li>Node.js 实现：<ul><li><a href="https://www.apollographql.com/docs/apollo-server/" target="_blank" rel="noopener">Apollo Server</a> is a flexible, community driven, production-ready HTTP GraphQL middleware for Express, Hapi, Koa, and more.</li><li><a href="https://github.com/graphql/express-graphql" target="_blank" rel="noopener">express-graphql</a></li></ul></li><li>以下内容部分摘自微信文章：<a href="https://mp.weixin.qq.com/s/g5zHRLFSBvHWaKLLhedtvQ" target="_blank" rel="noopener">微服务下使用GraphQL构建BFF的实践</a></li></ul><h2 id="微服务架构的优势-virtue-："><a href="#微服务架构的优势-virtue-：" class="headerlink" title="微服务架构的优势(virtue)："></a>微服务架构的优势(virtue)：</h2><p>简单说来，微服务是一种架构风格。通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。微服务中的每个服务都是很小的应用，这些应用服务相互独立并且可部署。微服务通过对复杂应用的拆分，达到简化应用的目的，而这些耦合度较低的服务则通过 API 形式进行通信，所以服务之间对外暴露的都是 API，不管是对资源的获取还是修改。</p><ul><li>Isolation 隔离状态</li><li>Autonomy 自治</li></ul><h2 id="BFF-前端的中间层后端"><a href="#BFF-前端的中间层后端" class="headerlink" title="BFF 前端的中间层后端"></a>BFF 前端的中间层后端</h2><p>Backend for Frontends(以下简称 BFF) 顾名思义，是为前端而存在的后端 (服务) 中间层。引用了 BFF 之后，前端应用将直接和 BFF 通信，BFF 再和后端进行 API 通信，所以本质上来说，BFF 更像是一种“中间层”服务。</p><h3 id="BFF-其实是一种-API-Gateway-实现模式"><a href="#BFF-其实是一种-API-Gateway-实现模式" class="headerlink" title="BFF 其实是一种 API Gateway 实现模式"></a>BFF 其实是一种 API Gateway 实现模式</h3><h4 id="API-Gateway-的三种实现："><a href="#API-Gateway-的三种实现：" class="headerlink" title="API Gateway 的三种实现："></a>API Gateway 的三种实现：</h4><ul><li>一个 API Gateway 对所有客户端提供同一种 API，例：<code>/api/users</code></li><li>一个 API Gateway 通过 Router 对每种客户端提供分别的 API，例：<code>/mobile/api/users</code> 和 <code>/web/api/users</code></li><li>多个 API Gateway 分别对每种客户端提供分别的 API，例：如上，但两个 Gateway 分别为 Mobile Gateway 和 Web Gateway。</li></ul><p>BFF 其实是 API Gateway 的其中一种实现模式，即 BFF 更类似于第三种 API Gateway 实现，通常一个 BFF 对应一种客户端，再由 BFF 去调用后端的实际 API。</p><h2 id="GraphQL-与-REST-对比"><a href="#GraphQL-与-REST-对比" class="headerlink" title="GraphQL 与 REST 对比"></a>GraphQL 与 REST 对比</h2><h3 id="相比于-REST-风格，GraphQL-具有如下特性："><a href="#相比于-REST-风格，GraphQL-具有如下特性：" class="headerlink" title="相比于 REST 风格，GraphQL 具有如下特性："></a>相比于 REST 风格，GraphQL 具有如下特性：</h3><ol><li>定义数据模型：按需获取</li><li>数据分层</li><li>强类型</li><li>协议而非存储</li><li>无须版本化</li></ol><h3 id="对于-GraphQL-和-REST-之间的对比，主要有如下不同："><a href="#对于-GraphQL-和-REST-之间的对比，主要有如下不同：" class="headerlink" title="对于 GraphQL 和 REST 之间的对比，主要有如下不同："></a>对于 GraphQL 和 REST 之间的对比，主要有如下不同：</h3><ul><li>数据获取：REST 缺乏可扩展性， GraphQL 能够按需获取。GraphQL API 调用时，payload 是可以扩展的 ;</li><li>API 调用：REST 针对每种资源的操作都是一个 endpoint, GraphQL 只需要一个 endpoint( /graphql), 只是 post body 不一样 ;</li><li>复杂数据请求：REST 对于嵌套的复杂数据需要多次调用，GraphQL 一次调用, 减少网络开销；</li><li>错误码处理：REST 能够精确返回 HTTP 错误码，GraphQL 统一返回 200，对错误信息进行包装；</li><li>版本号：REST 通过 v1/v2 实现，GraphQL 通过 Schema 扩展实现；</li></ul><h2 id="微服务-GraphQL-BFF-实践"><a href="#微服务-GraphQL-BFF-实践" class="headerlink" title="微服务 + GraphQL + BFF 实践"></a>微服务 + GraphQL + BFF 实践</h2><p>在微服务下基于 GraphQL 构建 BFF，例如在项目对应的业务场景下，微服务后台有近 10 个微服务，客户端包括针对不同角色的 4 个 App 以及一个 Web 端。对于每种类型的 App，都有一个 BFF 与之对应。每种 BFF 只服务于这个 App。BFF 解析到客户端请求之后，会通过 BFF 端的服务发现，去对应的微服务后台通过 CQRS 的方式进行数据查询或修改。</p><p>使用 GraphQL-express 框架构建项目的 BFF 端，然后通过 Docker 进行部署。BFF 和微服务后台之间，还是通过 registrator 和 Consul 进行服务注册和发现。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/aaVJqS7LaMLClPic6l1HLPZAEorehByj4Lg18e9bbBrEm61icnjq8xs5jz81PJLIuWVPo7ZdXW7iab9dicAIQdQzzw/640" alt="整体技术架构"></p><p>三个 App 客户端分别使用 GraphQL 的形式请求对应的 BFF。BFF 层再通过 Consul 服务发现和后端通信。</p><h3 id="关于系统中的鉴权问题"><a href="#关于系统中的鉴权问题" class="headerlink" title="关于系统中的鉴权问题"></a>关于系统中的鉴权问题</h3><p>用户登录后，App 直接访问 KeyCloak 服务获取到 id_token，然后通过 id_token 透传访问 auth-api 服务获取到 access_token, access_token 以 JWT (Json Web Token) 的形式放置到后续 http 请求的头信息中。</p><p>在我们这个系统中 BFF 层并不做鉴权服务，所有的鉴权过程全部由各自的微服务模块负责。BFF 只提供中转的功能。BFF 是否需要集成鉴权认证，主要看各系统自己的设计，并不是一个标准的实践。</p><h3 id="BFF-is-pary-of-Application-BFF-就是客户端的一部分"><a href="#BFF-is-pary-of-Application-BFF-就是客户端的一部分" class="headerlink" title="BFF is pary of Application, BFF 就是客户端的一部分"></a>BFF is pary of Application, BFF 就是客户端的一部分</h3><ul><li>BFF 中定义的数据结构，就是客户端所真正关心的。</li><li>BFF 就是为客户端而生，是客户端的一部分。</li><li>需要说明的是，对于“业务的关注”并不是说，BFF 会处理所有的业务逻辑，业务逻辑还是应该由微服务关心，BFF 关注的是客户端需要什么。</li></ul><h3 id="GraphQL-Mutation-与-CQRS"><a href="#GraphQL-Mutation-与-CQRS" class="headerlink" title="GraphQL Mutation 与 CQRS"></a>GraphQL Mutation 与 CQRS</h3><p>不同于 query，所有 mutation 都会调用后端的 API，而后端的 API 对于资源的修改也是通过 SpringBoot EventListener 实现的 CQRS 模式。</p><h3 id="新架构的测试"><a href="#新架构的测试" class="headerlink" title="新架构的测试"></a>新架构的测试</h3><p>在引入了 BFF 的项目，我们的测试仍然使用金字塔原理，只是在客户端和后台之间，需要添加对 BFF 的测试。</p><ul><li>Client 的 integration-test 关心的是 App 访问 BFF 的连通性，App 中所有访问 BFF 的请求都需要进行测试；</li><li>BFF 的 integration-test 测试的是 BFF 到微服务 API 的连通性，BFF 中依赖的所有 API 都应该有集成测试的保障；</li><li>API 的 integration-test 关注的是这个服务对外暴露的所有 API，通常测试所有的 Controller 中的 API。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实践&quot;&gt;&lt;a href=&quot;#实践&quot; class=&quot;headerlink&quot; title=&quot;实践&quot;&gt;&lt;/a&gt;实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.compose.com/articles/using-graphql-with-mon
      
    
    </summary>
    
    
    
      <category term="TypeScript" scheme="http://wind13.github.io/tags/TypeScript/"/>
    
      <category term="React" scheme="http://wind13.github.io/tags/React/"/>
    
      <category term="GraphQL" scheme="http://wind13.github.io/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>一图看懂 AntD 的结构</title>
    <link href="http://wind13.github.io/2018/03/29/one-pic-know-antd/"/>
    <id>http://wind13.github.io/2018/03/29/one-pic-know-antd/</id>
    <published>2018-03-29T03:07:53.000Z</published>
    <updated>2018-05-03T08:34:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/antd-one-pic-bw.gif" alt="一图看懂 AntD 的结构"></p><p>个人理解，仅供参考！</p><p>在开发时，仅需关注图中的那些 <code>*.js</code> 文件即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/antd-one-pic-bw.gif&quot; alt=&quot;一图看懂 AntD 的结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;个人理解，仅供参考！&lt;/p&gt;
&lt;p&gt;在开发时，仅需关注图中的那些 &lt;code&gt;*.js&lt;/code&gt; 文件即可。&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="AntD" scheme="http://wind13.github.io/tags/AntD/"/>
    
      <category term="一图" scheme="http://wind13.github.io/tags/%E4%B8%80%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>2018年3月23日这期“歌手”听后感</title>
    <link href="http://wind13.github.io/2018/03/24/2018-3-23-singer-feeling/"/>
    <id>http://wind13.github.io/2018/03/24/2018-3-23-singer-feeling/</id>
    <published>2018-03-24T07:49:23.000Z</published>
    <updated>2018-03-29T02:50:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2018年3月23日这期“歌手”听后感"><a href="#2018年3月23日这期“歌手”听后感" class="headerlink" title="2018年3月23日这期“歌手”听后感"></a>2018年3月23日这期“歌手”听后感</h1><p>这一期两位歌手都唱了崔健的歌，腾格尔唱《从头再来》，华晨宇唱《假行僧》，可见崔健中国摇滚之父的称号不是虚的。</p><p>从1993年大学时听过崔健的歌后，就将他奉为中国甚至世界摇滚中最为独特另类的一个，后来在几十年中，偶尔再听还是那么独特，不管时代如何变迁，他的音乐依然在每次听到的时候都有特殊的感觉。</p><p>这期“歌手”再次证明了这一点，崔健的摇滚即使在今天这个信息智能时代听起来依然是最新潮、最牛逼的！</p><p>不过相对来说，我更欣赏华晨宇的改编，是新一代音乐人用自己的灵魂对崔健《假行僧》的自我诠释，中间一度听得我两眼含泪，华晨宇是个可怜孩子，心灵的孤独和寂苦在小时候长时间无人知道、无人理解、无人关爱，好在自己在音乐中找到了表达，从而也造就了今天的新一代音乐天才和新星。有过童年悲伤经历的人们应该能感受到音乐中那种透达心底的孤寂，也应该更能理解这表面有些怪异的音乐和演唱方式所传达的空灵宇宙间的无奈和无所谓……</p><p>腾格尔的演唱基本是崔健摇滚的原本风格，没太多新的创新，当然也没有崔健原版的风格独特和反抗精神。嗯，再去找崔健的原版演唱会看一下……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;2018年3月23日这期“歌手”听后感&quot;&gt;&lt;a href=&quot;#2018年3月23日这期“歌手”听后感&quot; class=&quot;headerlink&quot; title=&quot;2018年3月23日这期“歌手”听后感&quot;&gt;&lt;/a&gt;2018年3月23日这期“歌手”听后感&lt;/h1&gt;&lt;p&gt;这一
      
    
    </summary>
    
    
    
      <category term="歌手" scheme="http://wind13.github.io/tags/%E6%AD%8C%E6%89%8B/"/>
    
      <category term="崔健" scheme="http://wind13.github.io/tags/%E5%B4%94%E5%81%A5/"/>
    
      <category term="华晨宇" scheme="http://wind13.github.io/tags/%E5%8D%8E%E6%99%A8%E5%AE%87/"/>
    
  </entry>
  
  <entry>
    <title>为什么说一个全新的操作系统是必要的？</title>
    <link href="http://wind13.github.io/2018/03/05/why-new-os-zh/"/>
    <id>http://wind13.github.io/2018/03/05/why-new-os-zh/</id>
    <published>2018-03-05T04:12:25.000Z</published>
    <updated>2018-03-05T04:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>注：此文是 OSv 官网介绍的文章，感觉对于理解 OSv 很有帮助，特翻译如下，<a href="http://osv.io/why-new-os/" target="_blank" rel="noopener">原文地址</a></p><p>Today’s cloud-based applications run a heavyweight stack: the hypervisor, which divides the hardware resources among virtual machines; the operating system, which divides the virtual machine’s resources among applications; and the application server, which divides the application’s resources among the end users.</p><p>当今的云应用都运行在一个非常重的技术栈上： Hypervisor (虚拟机管理程序) ，要将硬件资源从虚拟机中分离； OS 操作系统，要将虚拟机从应用中分离； App Server 应用服务，要将应用资源从终端用户处分离。</p><p>Clearly, there is a lot of duplication going on. Each layer adds its own overhead in an attempt to abstract away and hide the problems caused by the lower layer. The result is inefficient and complex.</p><p>很明显，这中间有很多的重复。每一层都添加了额外的开销用来抽象和隐藏低一层所产生的问题。结果是低效和复杂的。</p><p>Enter OSv - the operating system for the cloud. On the one hand, designed and optimized to run on a hypervisor. On the other hand, designed to run an application stack without getting in the way. Designed for the cloud.</p><p>来到 OSv —— 专为云而生的操作系统。一方面，它是专为虚拟机管理而设计和优化的。另一方面，专为无障碍地运行整个应用（包括 OS 系统）。专为云设计。</p><h2 id="It’s-cloudy-out-there-and-we-love-it"><a href="#It’s-cloudy-out-there-and-we-love-it" class="headerlink" title="It’s cloudy out there and we love it"></a>It’s cloudy out there and we love it</h2><h2 id="它就在云上，我们喜欢它！"><a href="#它就在云上，我们喜欢它！" class="headerlink" title="它就在云上，我们喜欢它！"></a>它就在云上，我们喜欢它！</h2><p>The public cloud era opens new horizons and opportunities for hi-tech businesses. Virtualization is dominant, resources are evergreen and agility is the key. The role of the OS in this form changes. The need to massively scale out forces developers to run multiple copies of identical Virtual Machines (VMs). VMs are the new process that needs to be lightweight, blazing fast, scalable and cheap. DevOps and PaaS solutions bypass the OS and allow developers to deploy their code directly to the cloud. All these goodies are rapidly penetrating the enterprise space with matching private cloud capabilities and virtual appliances that act as bridges to the public cloud</p><p>公有云时代为高科技企业展开了全新的视野和机会。虚拟机占到了主导地位，资源的快速响应和持久在线是关键。而操作系统 OS 的角色在这样的情况下也有所改变。大规模扩展的需求迫使开发人员同时要运行多个相同的虚拟机（VM）。 VMs 是一个需要轻量级、快速、可扩展和廉价的新流程。DevOps 和 PaaS 解决方案绕过操作系统，允许开发者将代码直接放到云上。所有这些优点都迅速渗透到企业空间中，并提供了与公有云相匹配的私有云功能和虚拟设备。</p><h2 id="Virtualization-2-0"><a href="#Virtualization-2-0" class="headerlink" title="Virtualization 2.0"></a>Virtualization 2.0</h2><h2 id="虚拟化-2-0"><a href="#虚拟化-2-0" class="headerlink" title="虚拟化 2.0"></a>虚拟化 2.0</h2><p>VMware had brought virtualization into the x86 world (recall that virtualization was introduced by IBM’s mainframes in the 70s). While VMware has done a fantastic job shifting the enterprise from physical to virtual, it stopped there. Amazon Web Services had wider vision; Amazon do not use terminology such as virtual machine. Amazon sees the entire user workload and solves scaling issues.</p><p>VMware 将虚拟化引入到了 x86 型机的世界（记得虚拟化是由IBM的大型机在上世纪70年代引入的概念）。虽然 VMware 做了一项出色的工作，将企业从物理机带入虚拟机世界，但它也就止步于此。 而 Amazon 网络服务则有更广阔的视野； Amazon 不使用诸如虚拟机之类的术语。 Amazon 看到了用户整个的工作负载并解决了缩放问题。 </p><p>The right(tm) way - the new world is compose out of the smallest building blocks possible, running in clusters of multiple VMs. Common components are NoSQL databases, MemCacheD, front end webservers, backend webservers, etc. One single application is hosted within the virtual machine. That application uses a fraction of the guest OS capabilities - there is no hardware as the hypervisor owns that, there are no real users as this is a server, there are no other apps to schedule. Users pay for CPU cycles they don’t really need and need to maintain and tune a full blown generic OS.</p><p>正确（TM）的方式 —— 新的世界是由尽可能小的积木组成，运行在多个虚拟机集群中。 常见的组件是 NoSQL 数据库，缓存，前端 Web 服务器，后台服务器等，单个应用程序托管在虚拟机内。该应用程序使用了客户机操作系统功能的一小部分——没有 Hypervisor (虚拟机管理程序) 中的硬件，没有真正的用户，因为这是一个服务器，没有其他应用程序需要去调度。 所以用户不必为他们并不真正需要的 CPU 损耗付费，也不必维护和调整一个完整的通用操作系统。 </p><p>Unlike new infrastructure such as hypervisors, NoSQL, PaaS, etc, the operating system hasn’t changed much. The same OS image that powers physical machines, from tiny embedded devices to room-size top500 supercomputers, is also used in the cloud.</p><p>不象新的基础设施如 Hypervisors 虚拟机管理程序，NoSQL，PaaS 等，操作系统并没有太大变化。 与之相同的实现了物理机功能的操作系统映像 (从小型嵌入式设备的房间大小的TOP500超级计算机) 也都用在了云上。 </p><p>Typical cloud workloads run application servers using Java, Ruby, Python and JavaScript (node.js). This historical evolution is not ideal - Java, Linux and the hypervisor implement parallel/duplicated mechanisms for protection and abstraction. These mechanisms are redundant when combined, and impose a large overhead in terms of CPU and memory.</p><p>常见的云应用服务器使用 Java、Ruby、Python 和 JavaScript (node.js)。而这个历史演变过程实际并不理想 —— Java, Linux 和 Hypervisor (虚拟机管理程序) 为了保护和抽象而实现了并行或复制机制。这些机制在组合时是多余的，在 CPU 和内存方面强加了大量的开销。 </p><p>The management efforts needed to maintain Linux are extensive. Thousands of packages, multiple security updates, complex tuning and specialists to manage. It doesn’t stop in the OS level. JVM workloads require manual tuning in a variety of ways and VM templates and instances needs to be software managed by tools like Puppet and Chef.</p><p>维护 Linux 所需的管理工作是广泛的。 数千个包、多个安全更新、复杂的配置和专用列表需要管理。它不会停止在操作系统级别。JVM 工作负载需要以各种方式手动调优，VM 模板和实例也需要用像 Puppet 和 Chef 这样的工具软件来管理。 </p><p>These tools help to manage multiple OS configurations but if we’ll examine their operation on a single OS instance, we’ll discover that their roots go to the Unix OS of the 1970s. They’re based on pushing human configuration files and strings to /etc files. Typical OSs still do not have a fully automated API. OSv takes a simpler approach, with a common REST API for all configuration and data collection.</p><p>这些工具有助于管理多个操作系统配置， 但如果我们在一个操作系统实例上检查它们的操作，我们会发现它们根本是在 20 世纪 70 年代的 UNIX 操作系统上建立的， 它们是基于将人为的配置文件和字符串入到 /etc 文件目录中来实现的。 常见的操作系统仍然没有完全自动化的 API 。而 OSv 则是用一个简单的方法，用一个共同的 REST API 来完成所有的配置和数据采集。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注：此文是 OSv 官网介绍的文章，感觉对于理解 OSv 很有帮助，特翻译如下，&lt;a href=&quot;http://osv.io/why-new-os/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Today’s cloud-
      
    
    </summary>
    
    
    
      <category term="Hypervisor" scheme="http://wind13.github.io/tags/Hypervisor/"/>
    
      <category term="OSv" scheme="http://wind13.github.io/tags/OSv/"/>
    
  </entry>
  
  <entry>
    <title>SVG 相关学习</title>
    <link href="http://wind13.github.io/2018/02/10/SVG-%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wind13.github.io/2018/02/10/SVG-相关学习/</id>
    <published>2018-02-10T11:32:40.000Z</published>
    <updated>2018-02-28T04:36:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-library"><a href="#JavaScript-library" class="headerlink" title="JavaScript library"></a>JavaScript library</h2><ul><li><a href="http://svgjs.com/" target="_blank" rel="noopener">SVG.js</a> The lightweight library for manipulating and animating SVG.</li><li><a href="https://bonsaijs.org/" target="_blank" rel="noopener">Bonsai</a> A lightweight graphics library with an intuitive graphics API and an SVG renderer.</li><li><a href="http://snapsvg.io/" target="_blank" rel="noopener">Snap.svg</a> The JavaScript SVG library for the modern web</li></ul><h2 id="Draw-library"><a href="#Draw-library" class="headerlink" title="Draw library"></a>Draw library</h2><ul><li><a href="http://sc.chinaz.com/info/150826129135.htm" target="_blank" rel="noopener">15个最佳SVG的JavaScript库</a></li><li><a href="https://segmentfault.com/q/1010000002759556" target="_blank" rel="noopener">推荐 SVG 图标素材网站</a></li><li><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">IconFont.cn</a> 国内图标库网站</li><li><a href="https://github.com/nullice/NViconsLib_Silhouette" target="_blank" rel="noopener">国内外社交网站矢量图标</a></li><li><a href="https://www.flaticon.com/" target="_blank" rel="noopener">FlatIcon</a> The largest database of free icons available in PNG, SVG, EPS, PSD and BASE 64 formats.</li><li><a href="https://worldvectorlogo.com/" target="_blank" rel="noopener">Worldvectorlogo</a> 矢量标志的所有品牌 完全免费和无限制</li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li><a href="https://designer.io/" target="_blank" rel="noopener">Gravit Designer</a> 一款跨平台的设计工具，可以在 AppStore 中直接下载。新发现的，感觉不错，强烈推荐，需要英文门槛。 参考：<a href="http://www.sohu.com/a/205549958_99940811" target="_blank" rel="noopener">欢迎来到设计利器Gravit Designer的世界</a> </li><li><a href="https://www.wobastic.com/omber/" target="_blank" rel="noopener">Omber</a> 可制作图形和色彩渐变效果的工具，可在 AppStore 中直接下载。</li><li><a href="https://inkscape.org/zh/" target="_blank" rel="noopener">Inkscape</a> Draw Freely. 自油自画。跨系统，Linux 上也是首选。缺点：需要先安装<a href="https://www.xquartz.org/" target="_blank" rel="noopener">XQuartz</a>。</li><li><a href="https://vectr.com/" target="_blank" rel="noopener">Vectr</a> is a free graphics software used to create vector graphics easily and intuitively. It’s a simple yet powerful web and desktop cross-platform tool to bring your designs into reality. 可以在 AppStore 中直接下载。</li><li><a href="http://macsvg.org/" target="_blank" rel="noopener">macSVG</a> An open-source macOS app for designing HTML5 SVG art and animation. <a href="https://github.com/dsward2/macSVG" target="_blank" rel="noopener">Github repo</a></li><li><a href="https://www.calligra.org" target="_blank" rel="noopener">Calligra</a> part of the KDE community.</li><li><a href="http://glipssvgeditor.sourceforge.net/" target="_blank" rel="noopener">GlipsSvgEditor</a> An open source SVG graphics editor and a SCADA HMI editor. 似乎是(SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统。)专业领域的画图工具，界面粗糙。</li><li><a href="http://latexdraw.sourceforge.net/" target="_blank" rel="noopener">LaTeXDraw</a> is a graphical drawing editor for LaTeX. LaTeXDraw can be used to 1) generate PSTricks code; 2) directly create PDF or PS pictures. LaTeXDraw is developed in Java and thus runs on top of Linux, Windows, and Mac OS X. You need Java 8 to launch LaTeXDraw.</li><li><a href="http://vectorpaint.yaks.co.nz/" target="_blank" rel="noopener">VectorPaint</a> Draw SVG online. 在线绘制工具。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JavaScript-library&quot;&gt;&lt;a href=&quot;#JavaScript-library&quot; class=&quot;headerlink&quot; title=&quot;JavaScript library&quot;&gt;&lt;/a&gt;JavaScript library&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
      <category term="SVG" scheme="http://wind13.github.io/tags/SVG/"/>
    
      <category term="Graphic" scheme="http://wind13.github.io/tags/Graphic/"/>
    
      <category term="JavaScript" scheme="http://wind13.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Computer Vision 学习</title>
    <link href="http://wind13.github.io/2018/02/07/Computer-Vision-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wind13.github.io/2018/02/07/Computer-Vision-学习/</id>
    <published>2018-02-07T16:17:34.000Z</published>
    <updated>2018-03-05T02:48:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Computer-Vision-Library"><a href="#Computer-Vision-Library" class="headerlink" title="Computer Vision Library"></a>Computer Vision Library</h2><ul><li><a href="https://www.quora.com/What-are-pros-and-cons-of-OpenCV-and-TensorFlow-for-computer-vision" target="_blank" rel="noopener">What are pros and cons of OpenCV and TensorFlow for computer vision?</a></li><li><a href="http://libccv.org/" target="_blank" rel="noopener">ccv</a> A Modern Computer Vision Library</li><li><a href="http://simplecv.org/" target="_blank" rel="noopener">SimpleCV</a> Computer Vision platform using Python.</li><li><a href="https://cecas.clemson.edu/~stb/blepo/" target="_blank" rel="noopener">Blepo</a> Computer Vision Library</li><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">Python教程</a></li></ul><h2 id="OpenCV-vs-VXL-vs-LTI-Performance-Test"><a href="#OpenCV-vs-VXL-vs-LTI-Performance-Test" class="headerlink" title="OpenCV vs VXL vs LTI: Performance Test"></a>OpenCV vs VXL vs LTI: Performance Test</h2><blockquote><p>I recently read this comparison of four vision libraries: OpenCV, VXL, LTI and OpenCV with IPP. It was in the book Learning Learning OpenCV: Computer Vision with the OpenCV Library, authored by the creators of OpenCV themselves. For those who aren’t familiar with these libraries, here’s a brief introduction.</p></blockquote><h3 id="VXL"><a href="#VXL" class="headerlink" title="VXL"></a>VXL</h3><blockquote><p>VXL stands for Vision something Library. It is a C++ library that implements several common computer vision algorithms and related functionality. The idea is to replace the ‘X’ with one of the several letters:</p></blockquote><ul><li>VGL = Vision Geometry Library</li><li>VIL = Vision Image processing Library</li><li>VNL = Vision Numerics Library</li><li>VSL = Vision Streaming Library</li></ul><p>There are several other libraries as well</p><h3 id="LTI"><a href="#LTI" class="headerlink" title="LTI"></a>LTI</h3><blockquote><p>LTI-Lib is another object oriented library for computer vision. It has also been implemented in C++. It also includes classes that encapsulate multithreading, synchronization, serial port access, etc. And it ensures you don’t have to deal with changing operating systems or hardware.</p></blockquote><h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><blockquote><p>Yet another computer vision library. It includes over 500 functions for various commonly used algorithms. It also comes with a machine learning library and a portable window creation library. With version 2.0, OpenCV comes with a C++ interface as well. Before 2.0, it was only the C interface.</p></blockquote><h3 id="OpenCV-IPP"><a href="#OpenCV-IPP" class="headerlink" title="OpenCV + IPP"></a>OpenCV + IPP</h3><blockquote><p>OpenCV developers were friendly with the Intel Performance Primitives team. So, OpenCV makes use of IPP code (which is hand tuned and extremely optimized code) to speed up execution. And this, as you’ll see, gives a substantial boost to its execution speed.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Computer-Vision-Library&quot;&gt;&lt;a href=&quot;#Computer-Vision-Library&quot; class=&quot;headerlink&quot; title=&quot;Computer Vision Library&quot;&gt;&lt;/a&gt;Computer Vision L
      
    
    </summary>
    
    
    
      <category term="OpenCV" scheme="http://wind13.github.io/tags/OpenCV/"/>
    
      <category term="Computer Vision" scheme="http://wind13.github.io/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://wind13.github.io/2018/02/07/Docker-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wind13.github.io/2018/02/07/Docker-学习/</id>
    <published>2018-02-07T00:00:00.000Z</published>
    <updated>2018-09-04T09:20:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-学习"><a href="#Docker-学习" class="headerlink" title="Docker 学习"></a>Docker 学习</h1><hr><p>title: Docker 学习<br>tags: [Docker]<br>date: 2018-02-07 16:18:26</p><hr><h2 id="快速入门心法"><a href="#快速入门心法" class="headerlink" title="快速入门心法"></a>快速入门心法</h2><p>官网文档也好，网上其他的教程也好，都非常有“耐心”，一点点地教你怎么理解和使用 docker，但我在看这些教程和文档的时候其实很着急，因为我只想快速入门并且用起来，而且最好是按最佳实践的路子用起来，而不是象个初学者那样慢慢摸索。但就是没人把这条捷径说清楚……</p><p>下面我就我所知道和理解的内容，写一点快速入门的心法：</p><ul><li>首先知道 docker 大概是个什么？<ul><li>就我的理解，直白地说：就是一个轻量的虚拟机，在一个基本的内核基础上，层层叠加出想要的虚拟机环境。</li><li>同时要注意一个重要概念，类似于微服务概念，每一个 docker 虚拟机里面一般只做一件事，只支持一个服务，例如： web 服务、 hexo 博客服务等；</li></ul></li><li>其次要知道拿 docker 来有什么用，最主要的用途在哪儿？<ul><li>目前就我的使用情况来说，就是一些开发部署环境在本机搭建起来很麻烦，不同的操作系统还有所不同，还要在本机安装一堆的包，还要在本机进行很多配置，而使用 docker 之后，就可以不用在本机安装了，本机干净了，又能快捷享用 docker 虚拟机中提供的服务。</li><li>保证应用项目在不同的主机上运行时一致，因为都是运行在 docker 中的，所以各种操作系统，各个电脑打开项目，只要正常安装了 docker 后，启动运行起来，都象是在 linux 中一样，因为 docker 虚拟机基本都是基于 linux 操作系统的。</li></ul></li><li>如何快速入门使用？<ul><li>首先要有一定的基础，否则会遇到太多阻碍，个人觉得是要对 linux 系统的基础操作和一些工作模式要有一定的熟悉和了解，特别是网络方面比较清楚会有比较大的帮助，另外了解 git 的使用流程和基本命令会比较有帮助，对于理解 docker 这种虚拟机的管理模式也会比较有帮助，当然有一定的编程基础，熟悉一些语言开发也是必须的，毕竟 docker 就是帮助开发部署环境用的。</li><li>快捷路线就是 docker-compose 了，别在 docker 命令上花费太多时间，只要把 docker 和 docker-compose 安装好后，就直接找一两个 docker-compose 构建的开源项目来尝试，运行 <code>docker-compose up</code> 就可以了，这本来也就是使用 docker 后最大的好处之一，只需要一个命令，有 docker 镜像就启动服务，没有就相应地创建或下载，总之不用操心怎么安装环境什么的。</li><li>另一个注意点是尽量选择那些以 alpine 为基础的镜像，文件占空间小。</li></ul></li></ul><p>以上只是心法，具体的知识和教程可参考下面的内容，网上也多得是：</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/miaodx/p/6160863.html" target="_blank" rel="noopener">使用 mongo docker 镜像</a></li><li><a href="http://www.cnblogs.com/yjmyzz/p/docker-compose-sample.html" target="_blank" rel="noopener">docker-compose使用示例</a></li><li><a href="https://www.jianshu.com/p/2217cfed29d7" target="_blank" rel="noopener">Docker Compose 配置文件详解</a> 其中第15项 links 启发了我写数据库连接的方式：<code>mongodb://admin:rootadmin@mgdb:27017/coral-reef</code></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>传统虚拟机：虚拟硬件和完整的操作系统，再运行应用；<br>容器：运行于宿主的内核，没有自己的内核，没有硬件虚拟。</p><h3 id="Docker-包括三个基本概念，涉及-Docker-的整个生命周期。"><a href="#Docker-包括三个基本概念，涉及-Docker-的整个生命周期。" class="headerlink" title="Docker 包括三个基本概念，涉及 Docker 的整个生命周期。"></a>Docker 包括三个基本概念，涉及 Docker 的整个生命周期。</h3><ul><li>镜像（Image）[类]：由多层文件系统联合组成，支持容器运行和配置参数，无动态数据。</li><li>容器（Container）[实例]：运行于独立命名空间的进程，以镜像为基础层，之上是容器存储层（会随容器消亡）。数据卷不会消亡。容器是拥有不同 IP 地址从而使其成为网络上可识别的独立 Linux 进程。容器依赖于镜像，如果想删除某个镜像，必须先删除相应的容器。</li><li>仓库（Repository）：Docker Registry =&gt; Repository =&gt; Tag == Image，”repository:tag”，一个镜像可以对应多个标签 tag。</li><li>虚悬镜像（Dangling image）：<code>docker pull</code> 或 <code>docker build</code> 导致标签指向新镜像，旧的无标签镜像变成虚悬镜像。</li><li>黑箱镜像：使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。</li><li>数据卷：volume</li></ul><h3 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h3><p>强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。</p><h4 id="创建一个新的-Docker-网络"><a href="#创建一个新的-Docker-网络" class="headerlink" title="创建一个新的 Docker 网络"></a>创建一个新的 Docker 网络</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-net</span><br></pre></td></tr></table></figure><h2 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h2><p>使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>docker主命令不要用后台运行，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出。正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p><p><code>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code></p><h3 id="Docker-run-详解"><a href="#Docker-run-详解" class="headerlink" title="Docker run 详解"></a>Docker run 详解</h3><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h3 id="Docker-Registry-公开服务"><a href="#Docker-Registry-公开服务" class="headerlink" title="Docker Registry 公开服务"></a>Docker Registry 公开服务</h3><p>镜像服务被称为<strong>加速器</strong>。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。</p><p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p><h2 id="docker-编译一个-Dockerfile"><a href="#docker-编译一个-Dockerfile" class="headerlink" title="docker 编译一个 Dockerfile"></a>docker 编译一个 Dockerfile</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .</span><br></pre></td></tr></table></figure><h2 id="列出系统中的所有镜像："><a href="#列出系统中的所有镜像：" class="headerlink" title="列出系统中的所有镜像："></a>列出系统中的所有镜像：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br><span class="line">REPOSITORY            TAG                 IMAGE ID</span><br><span class="line">friendlyhello         latest              326387cea398</span><br></pre></td></tr></table></figure><h2 id="删除所有虚悬镜像："><a href="#删除所有虚悬镜像：" class="headerlink" title="删除所有虚悬镜像："></a>删除所有虚悬镜像：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure><h2 id="删除所有无主的数据卷："><a href="#删除所有无主的数据卷：" class="headerlink" title="删除所有无主的数据卷："></a>删除所有无主的数据卷：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume prune</span><br></pre></td></tr></table></figure><h2 id="删除本地镜像："><a href="#删除本地镜像：" class="headerlink" title="删除本地镜像："></a>删除本地镜像：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除所有仓库名为 redis 的镜像</span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 删除所有在 mongo:3.2 之前的镜像</span><br><span class="line">docker image rm $(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><h2 id="查看镜像的历史记录"><a href="#查看镜像的历史记录" class="headerlink" title="查看镜像的历史记录"></a>查看镜像的历史记录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker history ubuntu:latest</span><br></pre></td></tr></table></figure><h2 id="在某个端口映射下启动该镜像："><a href="#在某个端口映射下启动该镜像：" class="headerlink" title="在某个端口映射下启动该镜像："></a>在某个端口映射下启动该镜像：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><ul><li>-i：交互；</li><li>-t：终端；</li><li>–rm 容器退出后将其删除；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口</span><br><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br></pre></td></tr></table></figure><h2 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker port webserver</span><br></pre></td></tr></table></figure><h2 id="进入某个运行中的容器-bash"><a href="#进入某个运行中的容器-bash" class="headerlink" title="进入某个运行中的容器 bash"></a>进入某个运行中的容器 bash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it webserver bash</span><br></pre></td></tr></table></figure><h2 id="查看镜像、容器、数据卷所占用的空间"><a href="#查看镜像、容器、数据卷所占用的空间" class="headerlink" title="查看镜像、容器、数据卷所占用的空间"></a>查看镜像、容器、数据卷所占用的空间</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><h2 id="列出系统中启动的容器："><a href="#列出系统中启动的容器：" class="headerlink" title="列出系统中启动的容器："></a>列出系统中启动的容器：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED</span><br><span class="line">1fa4ab2cf395        friendlyhello       "python app.py"     28 seconds ago</span><br></pre></td></tr></table></figure><h2 id="关闭某个容器："><a href="#关闭某个容器：" class="headerlink" title="关闭某个容器："></a>关闭某个容器：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container stop 1fa4ab2cf395</span><br></pre></td></tr></table></figure><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls                                            # List stacks or apps</span><br><span class="line">docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose file</span><br><span class="line">docker service ls                 # List running services associated with an app</span><br><span class="line">docker service ps &lt;service&gt;                  # List tasks associated with an app</span><br><span class="line">docker inspect &lt;task or container&gt;                   # Inspect task or container</span><br><span class="line">docker container ls -q                                      # List container IDs</span><br><span class="line">docker stack rm &lt;appname&gt;                             # Tear down an application</span><br><span class="line">docker swarm leave --force      # Take down a single node swarm from the manager</span><br></pre></td></tr></table></figure><h2 id="docker-命令帮助"><a href="#docker-命令帮助" class="headerlink" title="docker 命令帮助"></a>docker 命令帮助</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">    attach    Attach to a running container                 <span class="comment"># 当前 shell 下 attach 连接指定运行镜像</span></span><br><span class="line">    build     Build an image from a Dockerfile              <span class="comment"># 通过 Dockerfile 定制镜像</span></span><br><span class="line">    commit    Create a new image from a container<span class="string">'s changes # 提交当前容器为新的镜像</span></span><br><span class="line"><span class="string">    cp        Copy files/folders from the containers filesystem to the host path</span></span><br><span class="line"><span class="string">              # 从容器中拷贝指定文件或者目录到宿主机中</span></span><br><span class="line"><span class="string">    create    Create a new container                        # 创建一个新的容器，同 run，但不启动容器</span></span><br><span class="line"><span class="string">    diff      Inspect changes on a container'</span>s filesystem   <span class="comment"># 查看 docker 容器变化</span></span><br><span class="line">    events    Get real time events from the server          <span class="comment"># 从 docker 服务获取容器实时事件</span></span><br><span class="line">    <span class="built_in">exec</span>      Run a <span class="built_in">command</span> <span class="keyword">in</span> an existing container        <span class="comment"># 在已存在的容器上运行命令</span></span><br><span class="line">    <span class="built_in">export</span>    Stream the contents of a container as a tar archive   </span><br><span class="line">              <span class="comment"># 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span></span><br><span class="line">    <span class="built_in">history</span>   Show the <span class="built_in">history</span> of an image                  <span class="comment"># 展示一个镜像形成历史</span></span><br><span class="line">    images    List images                                   <span class="comment"># 列出系统当前镜像</span></span><br><span class="line">    import    Create a new filesystem image from the contents of a tarball  </span><br><span class="line">              <span class="comment"># 从tar包中的内容创建一个新的文件系统映像[对应 export]</span></span><br><span class="line">    info      Display system-wide information               <span class="comment"># 显示系统相关信息</span></span><br><span class="line">    inspect   Return low-level information on a container   <span class="comment"># 查看容器详细信息</span></span><br><span class="line">    <span class="built_in">kill</span>      Kill a running container                      <span class="comment"># kill 指定 docker 容器</span></span><br><span class="line">    load      Load an image from a tar archive              <span class="comment"># 从一个 tar 包中加载一个镜像[对应 save]</span></span><br><span class="line">    login     Register or Login to the docker registry server   </span><br><span class="line">              <span class="comment"># 注册或者登陆一个 docker 源服务器</span></span><br><span class="line">    <span class="built_in">logout</span>    Log out from a Docker registry server         <span class="comment"># 从当前 Docker registry 退出</span></span><br><span class="line">    logs      Fetch the logs of a container                 <span class="comment"># 输出当前容器日志信息</span></span><br><span class="line">    port      Lookup the public-facing port <span class="built_in">which</span> is NAT-ed to PRIVATE_PORT</span><br><span class="line">              <span class="comment"># 查看映射端口对应的容器内部源端口</span></span><br><span class="line">    pause     Pause all processes within a container        <span class="comment"># 暂停容器</span></span><br><span class="line">    ps        List containers                               <span class="comment"># 列出容器列表</span></span><br><span class="line">    pull      Pull an image or a repository from the docker registry server</span><br><span class="line">              <span class="comment"># 从docker镜像源服务器拉取指定镜像或者库镜像</span></span><br><span class="line">    push      Push an image or a repository to the docker registry server</span><br><span class="line">              <span class="comment"># 推送指定镜像或者库镜像至docker源服务器</span></span><br><span class="line">    restart   Restart a running container                   <span class="comment"># 重启运行的容器</span></span><br><span class="line">    rm        Remove one or more containers                 <span class="comment"># 移除一个或者多个容器</span></span><br><span class="line">    rmi       Remove one or more images</span><br><span class="line">              <span class="comment"># 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span></span><br><span class="line">    run       Run a <span class="built_in">command</span> <span class="keyword">in</span> a new container</span><br><span class="line">              <span class="comment"># 创建一个新的容器并运行一个命令</span></span><br><span class="line">    save      Save an image to a tar archive                <span class="comment"># 保存一个镜像为一个 tar 包[对应 load]</span></span><br><span class="line">    search    Search <span class="keyword">for</span> an image on the Docker Hub         <span class="comment"># 在 docker hub 中搜索镜像</span></span><br><span class="line">    start     Start a stopped containers                    <span class="comment"># 启动容器</span></span><br><span class="line">    stop      Stop a running containers                     <span class="comment"># 停止容器</span></span><br><span class="line">    tag       Tag an image into a repository                <span class="comment"># 给源中镜像打标签</span></span><br><span class="line">    top       Lookup the running processes of a container   <span class="comment"># 查看容器中运行的进程信息</span></span><br><span class="line">    unpause   Unpause a paused container                    <span class="comment"># 取消暂停容器</span></span><br><span class="line">    version   Show the docker version information           <span class="comment"># 查看 docker 版本号</span></span><br><span class="line">    <span class="built_in">wait</span>      Block until a container stops, <span class="keyword">then</span> <span class="built_in">print</span> its <span class="built_in">exit</span> code   </span><br><span class="line">              <span class="comment"># 截取容器停止时的退出状态值</span></span><br></pre></td></tr></table></figure><h2 id="Docker-高级网络工具和示例"><a href="#Docker-高级网络工具和示例" class="headerlink" title="Docker 高级网络工具和示例"></a>Docker 高级网络工具和示例</h2><p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p><h3 id="pipework"><a href="#pipework" class="headerlink" title="pipework"></a>pipework</h3><p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p><h3 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h3><p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。</p><h2 id="Docker-官方三剑客"><a href="#Docker-官方三剑客" class="headerlink" title="Docker 官方三剑客"></a>Docker 官方三剑客</h2><h3 id="Docker-Compose-项目"><a href="#Docker-Compose-项目" class="headerlink" title="Docker Compose 项目"></a>Docker Compose 项目</h3><ul><li>服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。</li><li>项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</li></ul><h3 id="Docker-Machine-项目"><a href="#Docker-Machine-项目" class="headerlink" title="Docker Machine 项目"></a>Docker Machine 项目</h3><p>在多种平台上快速安装 Docker 环境，在 macOS 上安装 xhyve 虚拟机支持：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install docker-machine-driver-xhyve</span><br></pre></td></tr></table></figure><h3 id="Docker-Swarm-mode-项目"><a href="#Docker-Swarm-mode-项目" class="headerlink" title="Docker Swarm mode 项目"></a>Docker Swarm mode 项目</h3><p>提供 Docker 容器集群服务，具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。与 Kubernetes 是竞争关系。</p><ul><li><a href="http://dockone.io/article/1138" target="_blank" rel="noopener">巅峰对决之Swarm、Kubernetes、Mesos</a></li><li><a href="https://platform9.com/blog/kubernetes-docker-swarm-compared/" target="_blank" rel="noopener">Kubernetes vs Docker Swarm</a></li><li><a href="https://www.jianshu.com/p/07daa3a16878" target="_blank" rel="noopener">选择焦虑症のKubernetes 与 Docker Swarm</a></li></ul><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><h5 id="初始化一个-Swarm-集群："><a href="#初始化一个-Swarm-集群：" class="headerlink" title="初始化一个 Swarm 集群："></a>初始化一个 Swarm 集群：</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.99.100</span><br><span class="line"></span><br><span class="line">Swarm initialized: current node (7t2kqs1cmbw3r54921y9ofdcu) is now a manager.</span><br></pre></td></tr></table></figure><p>To add a worker to this swarm, run the following command:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-4l54p60fpaumw188uk5yea8l3z0sd80q6ydiav0e8r12w5cog1-8i70bpp0wtxggiemi2wx63f3g 192.168.99.100:2377</span><br></pre></td></tr></table></figure><p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p><h6 id="添加一个虚拟机后，加入此-swarm-遇到如下报错："><a href="#添加一个虚拟机后，加入此-swarm-遇到如下报错：" class="headerlink" title="添加一个虚拟机后，加入此 swarm 遇到如下报错："></a>添加一个虚拟机后，加入此 swarm 遇到如下报错：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: rpc error: code = Unavailable desc = grpc: the connection is unavailable</span><br></pre></td></tr></table></figure><h2 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h2><p>Kubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言。</p><p><code>Kubernetes</code> 实际上是一个希腊词κυβερνήτης，意思是”船的舵手”。 在这个意义上， Kubernetes 对于 Docker (集装箱船)倒是挺般配的。</p><ul><li><a href="https://blog.kelu.org/tech/2017/08/25/kubernetes-tutorial.html" target="_blank" rel="noopener">kubernetes 架构简介</a></li><li><a href="http://kubernetesbyexample.com/" target="_blank" rel="noopener">Kubernetes By Example</a> 非常棒的 K8s 学习网站</li></ul><h2 id="OSv"><a href="#OSv" class="headerlink" title="OSv"></a>OSv</h2><p><a href="http://osv.io/" target="_blank" rel="noopener">OSv</a> is the open source operating system designed for the cloud.</p><h2 id="Moby"><a href="#Moby" class="headerlink" title="Moby"></a>Moby</h2><p><a href="http://mobyproject.org/" target="_blank" rel="noopener">Moby</a> defines the future in specialized container systems building. An open framework to assemble specialized container systems without reinventing the wheel.</p><p>似乎是更高、更深层定制化容器的工具，示例：<a href="https://github.com/linuxkit/linuxkit" target="_blank" rel="noopener">LinuxKit</a></p><h2 id="开源项目中几个文件各是什么意思？"><a href="#开源项目中几个文件各是什么意思？" class="headerlink" title="开源项目中几个文件各是什么意思？"></a>开源项目中几个文件各是什么意思？</h2><ul><li>Dockerfile 运行时的 docker 镜像生成文件，<code>docker build .</code> 并执行 <code>docker run the-id-build</code> 可尝试。</li><li>Capstanfile 是 OSv 的镜像生成文件。</li><li>Procfile 是 <a href="https://devcenter.heroku.com/articles/procfile" target="_blank" rel="noopener">Heroku</a> 的运行时命令文件。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker-学习&quot;&gt;&lt;a href=&quot;#Docker-学习&quot; class=&quot;headerlink&quot; title=&quot;Docker 学习&quot;&gt;&lt;/a&gt;Docker 学习&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;title: Docker 学习&lt;br&gt;tags: [Docker]&lt;br
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>两个 Lock 文件的迷惑</title>
    <link href="http://wind13.github.io/2018/01/24/two-lock-file-confuse/"/>
    <id>http://wind13.github.io/2018/01/24/two-lock-file-confuse/</id>
    <published>2018-01-24T16:54:08.000Z</published>
    <updated>2018-01-24T08:54:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>从 npm 5 开始，执行后就多出了一个 <code>package-lock.json</code> 的文件，如果在用 yarn 的话，就会有个疑惑，<code>yarn.lock</code> 和这个 <code>package-lock.json</code> 到底用哪个呢？要不要保存入 git 库呢？</p><p>通过参考这两个链接：</p><ul><li><a href="https://stackoverflow.com/questions/44552348/should-i-commit-yarn-lock-and-package-lock-json-files" target="_blank" rel="noopener">Should I commit yarn.lock and package-lock.json files?</a></li><li><a href="https://github.com/yarnpkg/yarn/issues/3614" target="_blank" rel="noopener">Idea: support package-lock.json from npm 5</a></li></ul><p>得到信息如下：</p><ul><li>都是为了记录准确的版本，使用时最好二选一，开发团队内部协商一致后，把另一种舍弃，即尽量不要用另一种并且在 <code>.gitignore</code> 中忽略掉。</li><li>有可能未来 yarn 会支持或兼容 <code>packge-lock.json</code>，等消息吧。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 npm 5 开始，执行后就多出了一个 &lt;code&gt;package-lock.json&lt;/code&gt; 的文件，如果在用 yarn 的话，就会有个疑惑，&lt;code&gt;yarn.lock&lt;/code&gt; 和这个 &lt;code&gt;package-lock.json&lt;/code&gt; 到底用
      
    
    </summary>
    
    
    
      <category term="yarn" scheme="http://wind13.github.io/tags/yarn/"/>
    
      <category term="npm" scheme="http://wind13.github.io/tags/npm/"/>
    
      <category term="package-lock.json" scheme="http://wind13.github.io/tags/package-lock-json/"/>
    
      <category term="yarn.lock" scheme="http://wind13.github.io/tags/yarn-lock/"/>
    
  </entry>
  
  <entry>
    <title>不沉迷电子游戏的心法</title>
    <link href="http://wind13.github.io/2018/01/23/fight-with-digital-games/"/>
    <id>http://wind13.github.io/2018/01/23/fight-with-digital-games/</id>
    <published>2018-01-23T16:46:21.000Z</published>
    <updated>2018-01-23T09:12:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏估计是所有动物的本能吧，至少看上去是人类的本能了，从两三岁的小孩开始，就已经每天都在游戏了，而自从有了电子游戏之后，就出现了一种新的问题：沉迷电子游戏的问题。</p><p>个人也是沉迷“患者”，甚至目前也还是，一天的游戏时间加一起估计有5个小时左右，如果是周末不上班，则可能到10多个小时。自我感觉是需要改变了，所以写下这篇文章来反思这个问题。</p><p>不过我认为游戏甚至电子游戏本身并不是有百害而无一利的事物，不象吸毒抽烟那样，必须戒掉才好。毕竟游戏中是有其精彩的一面的，也有部分寓教于乐的成份的。所以只要不过度沉迷，实际也无伤大雅。</p><p>回到心法的角度来思考，为什么我们喜欢游戏？是因为在游戏中能得到什么吗？想要改变一种习惯或坏毛病，最好是能找到它的思想根源，然后在根源上用一件更好的习惯和事情来替换它。</p><p>我们喜欢玩游戏，玩电子游戏，最根本的不是因为喜欢玩电子游戏，电子游戏千千万万，并不是每一款我们都喜欢玩儿，很多时候打开一些不喜欢的电子游戏，我们也是提不起兴趣甚至是感到厌恶的。另一个现象就是，玩儿（沉迷）网络游戏的人远远比玩儿（沉迷）单机游戏的人多得多，甚至可以说几乎很少有人沉迷于某一款单机游戏，原因还是单机游戏本身是电脑 AI 来跟人玩儿，俗话说的就是死的，固定的，刻板的，当然随着人工智能的发展，也许未来的电脑智能也会不断提高，到时应该也许会有沉迷单机游戏的情况发生吧。人们还是更喜欢跟网络上的真人玩家玩儿网络游戏，这就反映了一个非常基本的需求：人与人之间的互动需求，这互动可能是聊天、对战竞技、合作成就等。</p><p>说到这里不得不提到几乎全民参与的游戏《王者荣耀》了，这款游戏之所以如此受欢迎，分析其中的根本原因有以下这些：</p><ul><li>与玩家对战竞技；</li><li>与队友合作配合；</li><li>成长路径、随机的奖励反馈；</li><li>更好的、更厉害的自己的虚拟投影——英雄系统；</li><li>不同个性、不同想象的虚拟形象，给人各种虚拟角色扮演的感觉；</li><li>手机操作，随时随地有网即可，零碎时间、无聊时间都可快速启动娱乐状态；</li><li>操作简单，上手容易，男女老少皆宜；</li><li>有历史传承，从早期的魔兽争霸、三国无双 到 Dota 到英雄联盟，再到手机上的王者荣耀，很多玩家一直追随下来；</li><li>英雄人物大众喜闻乐见，这也许也算是另一款腾讯的“全民超神”为什么远不如“王者荣耀”的原因之一吧；</li><li>游戏自身功能和体验制作得相当不错，包括还有语音、打字、快捷话语等沟通功能等，加上战队系统，使之不同于一般的游戏仅止于游戏而已，更是包含了一定的社交属性在其中。</li></ul><p>这么多的游戏元素集大成者，不火也难，再加上腾讯用户的基数，以及微信时代的传播效应，自然更是火借风势，一发而不可收拾。</p><p>个人还喜欢玩儿一些大型的网络游戏，比如刀剑2、龙之谷、暗黑3等，也都是类似的集合了这些元素的电子游戏，说到这儿我们就可以开始分析一下这背后的人的真实需求和沉迷的深层原因了。</p><ul><li><p>首先，人是有社交需求的；</p></li><li><p>其次，人是有自我实现需求的；</p></li><li><p>再次，经济规律会促使人们寻找最优性价比的解决方案的；解决以上两大需求，在现实中的成本通常很高，而通过电子游戏互联网，成本变得非常低、非常容易，因此这变成一种不可逆转的大趋势。相应的现象比如：</p><ul><li>人们更多地发微信而更少见面；</li><li>人们更多地远程开会、协作，而更少出差、实地办公；</li><li>人们更多地网上视频，而更少坐长途车来回探亲；</li><li>人们更多地网上购物，而更少逛多处商场选购商品；</li><li>人们更多地用视频监控，而更少亲自守夜监视等；</li></ul></li></ul><p>但无论怎么说，我们不希望自己沉迷于电子游戏的虚拟世界，我们希望适度地游戏娱乐，安排好生活和工作。所以，我们要找到避免沉迷这些电子游戏的方法。</p><h2 id="游戏上瘾的心结"><a href="#游戏上瘾的心结" class="headerlink" title="游戏上瘾的心结"></a>游戏上瘾的心结</h2><h3 id="现实中没有这么有意思的事儿"><a href="#现实中没有这么有意思的事儿" class="headerlink" title="现实中没有这么有意思的事儿"></a>现实中没有这么有意思的事儿</h3><h3 id="可以短暂地抛开现实中的烦恼"><a href="#可以短暂地抛开现实中的烦恼" class="headerlink" title="可以短暂地抛开现实中的烦恼"></a>可以短暂地抛开现实中的烦恼</h3><p>游戏上瘾的人通常在现实中也会同时伴有严重的拖延症，有个说法是说拖延其实不是病，不过拖延本身就是一个很大的话题，有无数的书在说这件事情，个人倒是认为拖延症和游戏上瘾可能有着相同的心理根源，如果找到并解决了，可能两个问题都会被解决。</p><h3 id="可以在虚拟的世界中体验自己想体验的过程"><a href="#可以在虚拟的世界中体验自己想体验的过程" class="headerlink" title="可以在虚拟的世界中体验自己想体验的过程"></a>可以在虚拟的世界中体验自己想体验的过程</h3><p>例如：建造一座城市、成为一个英雄、指挥一个大军。</p><h3 id="解决大脑中的各种强迫症"><a href="#解决大脑中的各种强迫症" class="headerlink" title="解决大脑中的各种强迫症"></a>解决大脑中的各种强迫症</h3><p>例如：把三个或多个连起来并消掉；拼成一排并消掉；</p><h3 id="朋友们都在玩儿"><a href="#朋友们都在玩儿" class="headerlink" title="朋友们都在玩儿"></a>朋友们都在玩儿</h3><p>喜欢玩儿的游戏，主要还是有朋友一起玩儿的才更感觉有趣，再好的游戏，如果没有人一起玩儿，也就失去了大半的乐趣，再无聊的游戏，也许就是因为有朋友一起玩儿也就觉得有趣的。</p><h3 id="我也需要娱乐"><a href="#我也需要娱乐" class="headerlink" title="我也需要娱乐"></a>我也需要娱乐</h3><p>通常都是在工作一天后，就觉得自己也需要找点娱乐的事情，电视、电影什么的偶尔遇到好的看一下，但更多的时候还是觉得玩游戏更有意思。</p><h3 id="现实中的事情都很慢很麻烦"><a href="#现实中的事情都很慢很麻烦" class="headerlink" title="现实中的事情都很慢很麻烦"></a>现实中的事情都很慢很麻烦</h3><p>游戏中只需要点点鼠标、按按键盘，再麻烦的也就是多点点鼠标和多按按键盘，虽然也有一些游戏的技巧，但毕竟游戏是设计出来给人玩儿的，所以肯定适应大多数人的操作和忍耐能力，而现实世界就不一样了，遵循的是现实世界的客观规律，所有事情都需要实事求是，很多真正有成就的事情都需要长期持久的耐心来慢慢实现，不象游戏或影视剧中一转眼十年就过去了……</p><h3 id="游戏的累积是可以看得见的"><a href="#游戏的累积是可以看得见的" class="headerlink" title="游戏的累积是可以看得见的"></a>游戏的累积是可以看得见的</h3><p>游戏中的各项数据都直观地显示给用户，即时评价给用户，同时大多数数据都是“永久”有效的，不断向上累积的，即使需要长时间积累的成就，也是可以期待的，任何时候上线还可以接续着之前的进度继续向前。</p><p>而现实世界则是看不到、摸不着的，没有数据可以直观告诉自己进度，甚至都不清楚会有哪些维度的数据要记录。同时，过程中也是感觉不进则退的，稍有懈怠就会感觉退回了从前，甚至从零开始一般。很多事情都会成为半途而废的失败记忆。</p><p><em>感悟：用一种方式在现实中给人一些数据、进度、里程碑、目标、任务计划等</em></p><h2 id="游戏与现实的逻辑区别"><a href="#游戏与现实的逻辑区别" class="headerlink" title="游戏与现实的逻辑区别"></a>游戏与现实的逻辑区别</h2><h3 id="时间、金钱、注意力"><a href="#时间、金钱、注意力" class="headerlink" title="时间、金钱、注意力"></a>时间、金钱、注意力</h3><ul><li>游戏中，用金钱来购买道具是游戏设计的主要目的之一，所以会尽可能地容易，游戏玩家购买道具通常是为了变得更强、更厉害，通常这些道具要么要耗费大量的时间才有可能得到，或者就是几乎没有几率（运气）得到，所以相当于在游戏中用金钱购买（节省）了自己的时间。</li><li>现实中，人们通常用自己的时间来换取金钱，当然为了生存必须如此，更高级的方式是用金钱来购买别人的时间，开成相互的交易。</li><li>游戏中，注意力通常是高度集中的，通常会让人专注于某一个任务或一系列具体的目标。</li><li>现实中，注意力通常是极其分散的，通常让人不知道要做什么，该做什么才好。</li></ul><p><em>感悟：用一种方式在现实中给人一些具体的大目标、小任务等</em></p><h3 id="大脑优势"><a href="#大脑优势" class="headerlink" title="大脑优势"></a>大脑优势</h3><ul><li>游戏中，体现的是人们的小聪明。</li><li>现实中，反映的是人们的大智慧。</li></ul><p><em>感悟：用一种方式在现实中创建大项目的概念，让人可以看得更长远，做事更持久。</em></p><h3 id="好运"><a href="#好运" class="headerlink" title="好运"></a>好运</h3><ul><li>游戏中，多数时候凭的是运气，玩儿的是概率和赌博。</li><li>现实中，更长远地要看人把握运势的眼光，比的是价值分析和持久专注。</li></ul><h3 id="成就感"><a href="#成就感" class="headerlink" title="成就感"></a>成就感</h3><p>成就感其实不是某种实物，不是金钱，甚至不是做成的某件事情，而是一种大脑自己想象出来的东西，可能是某种回忆（例如与队友在大逆风局里顶住压力，运用策略最终翻盘取胜等），某种脑子中的数字（例如游戏中的金子，在游戏中所构建的系统里，不断地玩儿，不断地熟悉，渐渐地就建立起来了某种价值感，于是乎在电脑里的这种小小的数字后面画一个小小的金子的图标就会让你感觉真的很值钱，甚至让你愿意为它而付出不断地努力挣取甚至打架争抢。）</p><p><em>感悟：记大账，可以大体反映出自己或家庭的财务状况即可</em></p><h2 id="初步的解决方案：管理好自己的注意力"><a href="#初步的解决方案：管理好自己的注意力" class="headerlink" title="初步的解决方案：管理好自己的注意力"></a>初步的解决方案：管理好自己的注意力</h2><p>有个朋友跟我说：你要转移你的注意力，没错，我想这是个办法，人在游戏的时候注意力全在游戏里，如果想控制自己的游戏时间，就需要把自己的注意力转移到别的地方，这样才能离开游戏。他的建议是出去抽根烟，哦，不是，因为我不抽烟，所以他的建议是陪孩子出去玩，去外面转转……</p><p>时间其实是没办法管理的，要想利用好时间，就要管理好自己的注意力，电子游戏虽然不是那么的十恶不郝，但也是要有所控制的，而要有所控制最初步的方式应该就是从转移注意力开始。</p><p>可是，我为什么会转移注意力呢？玩游戏之所以有时会失去控制，就是因为不愿意从这其中转移出来，沉迷其中感受特有的乐趣，甚至有时没什么乐趣，也依然好似强迫症一样地不停地做任务、打怪、升级……为什么呢？也许大脑有一种惯性，懒惰的惯性？在一件事情中找到了乐趣，就不停地想重复得到更多类似的乐趣？据说流行音乐也有类似的特性，就是一个旋律再重复一次，再稍加变化重复一次，最后再回归到最初的旋律再重复一次，人就会觉得很好听。</p><p>游戏其实可以给我们很多启示，设计游戏的机制，实际是非常讨好大脑的兴奋点的，我们要怎么样在现实中那些积极的事情上，也用心费力实现这些机制，让我们的人生、注意力、时间能更多地关注在这些积极的事情上呢？</p><p><em>感悟：在软件中加入任务、目标的价值，加入自己的精力值等参数，学习游戏的运行机制。</em><br><em>感悟：给想做的事情附加上独特的意义，并且最好有数据可衡量，可以直观地得到大脑中想象的成就感</em></p><p>我们沉迷游戏，最怕的是大脑进入到游戏的世界不能自拔，而玩游戏的最大乐趣恰恰在于进入其中的情境，未来的游戏发展只会更加的吸引人的注意力，更加的身临其境，摆脱沉迷游戏的关键点就是让大脑回到现实世界，思考现实世界的事物，冥想可能是比较有效的一个方法，帮助大脑更好地恢复平静，更好地明确人生的意义，而不再沉溺于游戏世界的愉悦和乐趣。</p><p>另外一项就是沉迷于工作，这样就用沉迷于其中一项代替了另一项，用工作代替游戏，这样沉迷工作可以带来更多的收益和成长，同时注意掌握好工作节奏，不至于过份劳累，就是一个可以长期持续的解决方案。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;游戏估计是所有动物的本能吧，至少看上去是人类的本能了，从两三岁的小孩开始，就已经每天都在游戏了，而自从有了电子游戏之后，就出现了一种新的问题
      
    
    </summary>
    
    
    
      <category term="games" scheme="http://wind13.github.io/tags/games/"/>
    
      <category term="游戏" scheme="http://wind13.github.io/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="注意力" scheme="http://wind13.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B/"/>
    
  </entry>
  
</feed>
