<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rust Learning]]></title>
    <url>%2F2019%2F10%2F04%2Frust-learning%2F</url>
    <content type="text"><![CDATA[Rust LearningReferences Julia、Rust、F#、Go编程语言游览和感想 Rust, Julia, and Go_ Disruptive New Programming Languages Changing the Face of C 新兴的函数式编程语言（如 Elixir 或 Elm） 从实际应用角度来看，Rust更偏向于底层，旨在替换C语言与C++，Golang旨在替换Java与C#。 Rust语言本身不依赖于虚拟机与GC，没有运行时，跨平台，主要靠一套所有权、生命周期、类型系统维护着语言的本身，语言高度抽象。 Golang 语言需要依赖于GC，自动垃圾回收，自带协程，快速编译，跨平台。 Rust 是一门入门门槛较高的语言，所有权与生命周期阻碍了不知多少的编程者。而go语言，入门较容易，学过类C语言同学，基本看一下语法就能入手写代码。 Rust Book Rust by Example Rustlings Small exercises to get you used to reading and writing Rust code! The Rust Programming Language The Cargo Book The Rust Playground Rust.cc Rust语言中文社区 Rust Force CN Rust in Motion Need to buy $39.99 Web Rocket is a web framework for Rust with flexibility, usability, or type safety. Ruby and Rails Haskell and Yesod Python and Bottle or Flask IRON extensible web framework for rust GUI conrod An easy-to-use, 2D GUI library written entirely in Rust. druid Data-oriented Rust UI design toolkit. libui-rs Rust bindings to the minimalist, native, cross-platform UI toolkit libui Are we GUI Yet? Other [oeasy]教您玩转rust编程视频教程 使用Rust编写操作系统（一）：独立式可执行程序 不能使用线程、文件、堆内存、网络、随机数、标准输出，或其它任何需要操作系统抽象和特定硬件的特性； 可以使用迭代器、闭包、模式匹配、Option、Result、字符串格式化，当然还有所有权系统。 需要创建一个独立于操作系统的可执行程序，被称作独立式可执行程序（freestanding executable）或裸机程序（bare-metal executable)。 独立式可执行程序并不能访问Rust运行时或crt0库，需要定义自己的入口点，即重写整个crt0库和它定义的入口点。 Rust与go在网上吵的比较大区别是，Rust有泛型，而Go没有。 做网络服务选Go， 上手比较简单。做系统用Rust, 它就是未来的系统语言。 如何利用科大源提速Cargo和Rust Writing an OS in Rust CS140E: Operating Systems Design and Implementation 一个Rust OS的专栏 Julia 是新晋发布1.0版本的科学计算类语言，号称兼具C++、python、matlab的优点。 孩子的编程语言 V 语言强势登顶 GitHub TOP1，难道要取 Go 而代之？ vlang Comparison of V and Other Languages Learn web MDN web docs Key points数据竞争 对于所有的类型T和任意的生命周期参数‘a，都能衍生出两种类型：&amp;’a T 和 &amp;mut ‘a T。 &amp;’a T 相当于T的读取器，持有T的读锁， &amp;mut ‘a T 相当于T的写入器，持有T的写锁。 编译器里有一个工具borrowck，在编译时会自动检查这两种类型的使用情况，如果有非法的使用，就报错，不让你编译通过。同样地，当你手中还持有着对一个值的引用时，编译器不允许将其移动或者销毁。这样，就杜绝了野指针现象和数据竞争问题。 12let rb0 = &amp;b;let rb1 = &amp;mut b; 值传递 Rust 的默认的值的传递是：转移。不管是赋值还是函数调用时的参数和返回值，都是这样。 分类体系(taxonomy) 开放的分类，使用泛型；封闭的分类，使用枚举(ADT)。 开放的全分类：Type + Trait]]></content>
      <tags>
        <tag>rust</tag>
        <tag>golang</tag>
        <tag>julia</tag>
        <tag>vlang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程自立之道]]></title>
    <url>%2F2019%2F10%2F02%2Fprogramming-dao%2F</url>
    <content type="text"><![CDATA[编程自立之道在开始之前，有耐心的朋友可以先看一下这篇 InfoQ 翻译的文章从第1行代码到百万年薪 ，我是如何在8个月内做到的？，英文原文在此：How I Went from First Line of Code to $226K Job Offer in 8 Months，没耐心的我可以简要介绍内容如下： 作者 Jason Zedde 在 2018年6月24日写下了第一行 JavaScript 代码，当时他有一个经济学学位，做过三年管理顾问，但在7月29日面临两个选择： 进入一家高速增长的广告技术公司，担任 Chief of Staff（类似副总或办公室主任的职位，参考这个介绍和这个知乎，即赚钱又稳定） 参加一家 Hack Reactor 的编程“训练营” 作者同时接到了广告技术公司的录用通知和训练营入学考试通过的通知，结果作者经过了72小时的反省，考虑过手头有训练结束后还可以承受三个月的房租和食物费用，由于对技术挑战的喜爱，做出了一个不理性的决定，选择了参加那个编程“训练营”。之后作者在几个月的时间里，每天安排好学习和休息时间，高度优化利用大脑和时间，到12月7日完成了 Hack Reactor 的训练和助教工作，然后又进行了科学而技巧地面试（申请44家，41次面试推荐，14次编码邀请或技术电话面试，8次现场面试，7次录用通知）和谈薪资，最终答应了非常满意的 Lyft 的 $22.6万美元的工作。 文中讲了很多作者的心路历程、时间管理经验、面试谈薪经验等。虽然大多数人不一定能做到象作者那样优秀，但我觉得还是有很多方面都是可以借鉴的，至少是会对当下的自己有所帮助的。同时我也想说明一件事情，就是编程的学习其实是可以在很短时间达到很好的能力水平的，作者就是一个真实的案例，仅用几个月的时间就从第一行代码的小白达到了可以应聘世界顶级软件公司的水平，这中间自然有很多他个人的能力优势，如英语、高学位、高智商、极强的执行力、时间管理和科学学习方法等。不过就普通人来说，也不是不可能的，别人用半年，我们用一年，只要有持续的兴趣和热情，加上方法得当，应该也是可以有所成就的。 现在我就想做这样一件事情，以我的经验来帮助年轻人掌握学习、工作和生活的智慧，提升自己的编程以及各方面综合能力，不保证能大富大贵，但是能够自立在社会上，做自己感兴趣的、有意义的、有价值的事，对大众有益、对社会有所贡献。 我是75年生人，已过不惑之年，工作了很多年，前一份工作的职位是架构师，不过自认为也就是高级程序员而已，水平也很有限，深知山外有山、人外有人。 如今有段闲暇时间，就想记录一下自己这些年的编程学习和生活自立之道，收一些徒弟，希望能对一些年轻人有所帮助。也许你会想我这水平也好意思收徒弟？没关系，水平高的我不敢收，我还要向人家学习呢，我就收一些水平一般的小白就可以了，人总是有一个成长的过程的，谁都当过小白，况且当师父也不一定要水平多高，很多高人当年从师的人也都是平凡人而已。好像《射雕英雄传》里郭靖也是从江南七侠那开始学艺的，《绝代双骄》中的江小鱼也是从恶人谷的四大恶人那儿开始学艺的。所以说师父的水平不一定要最高，主要看徒弟自己的天赋和悟性了，正所谓“师父领进门，学艺在个人”，当然为师者要有一些见识和教育方法。 我是本科学历，医学院药学专业，可想而知我走上编程这条路绕了多大的弯子。从平面设计到网页设计，到 Java 开发，到前端开发等，中间学习了无数的技术知识，接触了无数的类库框架，这中间又不知浪费了多少无用的功夫，所以想开这个学堂收徒，也是有这样的发心，希望能给年轻人指条明路，少走些弯路，少费些无用功。在这个学堂里，不只是教编程方面的经验，还有很多个人生活、工作、投资等方面的感悟和教训，相信年轻人少走错一些，就少损失一些，就会多积累一些，这样带来的收益，应该远比我设置的这个年费价值大多了。首批学徒一年收￥1300 元，越早的学徒，越优先教导、个性化教导，毕竟初期人员少，更有时间耐心地沟通。后期积累的资料多了，内容丰富了，自然价格也会慢慢提高，所以现在这个可谓之“早鸟价”。零基础也可以教，只是学的时间会相对更长，一年年续费，长期保持师徒关系，终身学习、终身成长。 我这个学堂并不同于网上的一些标准课程什么的，对于最早的一些学员，还有一个好处是可以依照学员当前的水平和悟性进行教学，可以保证学得又轻松又高效，后期的也许无法保证了，不过到时候看有没有学徒能成长为“大师兄”帮着教了，哈哈……同时，我的教学不保证考试或证书，也不保证面试或应聘，只教会心法和技能，所谓的真本事，而不是那些表面文章。那类的课程，自然有很多的培训班或线上平台在做了，想学的话花点钱报名就是了。 综上所述，我的世风十三学堂，不保证你能成功、成名，发财致富，但会教你人生大道，心法技能，自立于这个世界，不走太多弯路，不掉太多坑，编程方面掌握不过时的技术和本领，与时俱进，终身成长！]]></content>
      <tags>
        <tag>learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程资料收集]]></title>
    <url>%2F2019%2F09%2F18%2Ffunctional-programming-ref%2F</url>
    <content type="text"><![CDATA[概念 函数式编程入门教程（阮一峰） 回答了为什么要用函数式编程思维？ 面向函数范式编程(Functional programming) 说明了对面向对象编程的区别的关系，是可以互补共用的。 Kotlin极简教程：第8章 函数式编程 其中 Y组合子(Y - Combinator) ——匿名递归函数，解决匿名函数如何递归的问题。以及很多 Kotlin 的函数式编程语法。 强烈推荐以下两本书： 《JavaScript Allonge》 by Reginald Braithwaite 《Functional JavaScript》 by Michael Fogus 不要再尝试函数式编程了 一篇反讽的文章，其实在说函数式编程的好处，以及 OOP 的一些问题。 TypeScript/JavaScript mori A library for using ClojureScript’s persistent data structures and supporting API from the comfort of vanilla JavaScript. 函数式 TypeScript fp-ts Migrate from Ramda fp-ts type classes svg rxmarbles 响应式编程，是明智的选择 掘金——响应式编程，是明智的选择 ClojureScript Cursive The Clojure(Script) IDE that understands your code. lumo Fast, cross-platform, standalone ClojureScript environment shadow-cljs ClojureScript compilation made easy! ClojureScript 入门指南 Om A ClojureScript UI framework and client/server architecture over Facebook’s React. LuaUsing Lamda bjornbytes/RxLua example of observable Ref Moses Utility library for functional programming in Lua. Like Lodash of Lua. lxsmnsyc/RxLua Not ready for production. bacon.lua lua-users Go gomonkey is a library to make monkey patching in unit tests easy. 单元测试打桩框架 minetest 我的世界开发框架 Bacon mod for Minetest Java 8Java 8 才算是真的提高到函数式编程语言了，见以下这些资料： Java 8 中的 Streams API 详解 Java 8 Stream Tutorial fn + rx Rxjava2 二三四五六訪 Functional Java is an open source library facilitating functional programming in Java. 用RxJava实现Rxbus替换EventBus事件总线 Python Python 2.7 函数式编程（廖雪峰） Rx.js RxJS throttleTime, debounceTime and auditTime explained in examples]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当日笔记-20080925]]></title>
    <url>%2F2018%2F09%2F25%2Fdaily-note-20080925%2F</url>
    <content type="text"><![CDATA[小程序 小程序的全栈开发新时代 数学 读懂世纪难题“黎曼猜想”和其历史 黎曼猜想仍旧，素数依然孤独 黎曼猜想，及其解释（上） 黎曼猜想，及其解释（下） 神奇而有趣的素数 素数（质数）就是除了 1 和自身，不能再被其他整数整除的数字。 第一个问题：下一个素数的规律是什么？ 2 的倍数即是所有偶数。 3 的倍数，其数字相加能被 3 整除。 5 的倍数，结尾不是 5 就是 0，即见到这两个数字结尾的整数就能被 5 整除。 7 的倍数是第一个比较没规律的素数集合，而 7 = 2 * 3 + 1，即前两个素数相乘后再加 1 即可。 11 = 2 * 5 + 1，13 = 2 * 2 * 3 + 1，欧几里得在公元前 300 年证明了素数有无限个。如果是有限个，那假设它们的乘积为 P ，而 Q = P + 1，那么 Q 应该是一个合数，即可被其中某个素数 p 整除，而 p 又可以整除 P，那么 Q - P 也应该能被 p 整除，但是 Q - P = 1，1 显然不能被 p 整除，只能被 1 整除，所以不存在这样有限个素数的情况。 调和级数$$H_r = \sum_{r=1}^\infin \frac{1}{r} = 1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4} + …$$ 谐波：高于基音基本频率的泛音，该和式被奥雷斯姆证明是不收敛的（即不存在极限，不接近/趋向于任何特定的数字，而是一直增长到无穷大）。 Zeta 函数$$\zeta(n)=\sum_{r=1}^\infin \frac{1}{r^n}=1 + \frac{1}{2^n} + \frac{1}{3^n} + \frac{1}{4^n} + …$$ 若将 n = 1 代入，就会得到调和级数，它是发散的。然而对于 n &gt; 1 的所有值, 该级数是收敛的，这意味着当 r 递增时，其和趋向于某些数，即它不会增长到无穷大。 欧拉乘积公式zeta 函数和素数间的第一个联系是由欧拉发现的，当时他发现了 n 和 p 两个自然数（大于零的整数）之间的关系，其中 p 为素数： $$\zeta(n)=\sum_{r=1}^\infin\frac1{r^n}=\prod_p\frac1{1-p^{-s}}=(1-\frac1{1-\frac1{2^s}})\times(1-\frac1{1-\frac1{3^s}})\times(1-\frac1{1-\frac1{5^s}})\times(1-\frac1{1-\frac1{7^s}})\times(1-\frac1{1-\frac1{11^s}})\times…$$ 欧拉乘积公式，其中 n，p 均为大于零的数字且 p 为素数 简易思考 100 以内有多少个素数？ golang-daisy-chain 利用信道菊花链筛法求某一个整数范围的素数 100 以后第一个素数是多少？ 数学公式 MathJax Beautiful math in all browsers Markdown 中的 MathJax 数学公式语法整理 在Markdown中输入数学公式(MathJax) MathJax basic tutorial and quick reference Hugo theme Develop a Theme for Hugo Golang ramda deps graph Go Search Unix-like pipelines for Go Doc lennon-guan/pipe A golang library that makes operations on slice easilier 局限于 Slice 数据 gofunctools Github Go TIGER Web 微框架，包含一些工具 Make funcs Package funcs provides utilities to enable functional programming with Go.]]></content>
  </entry>
  <entry>
    <title><![CDATA[当日笔记-20080922]]></title>
    <url>%2F2018%2F09%2F22%2Fdaily-note-20080922%2F</url>
    <content type="text"><![CDATA[Hugo 研究对 Hugo 有点着迷了，看到了 Youtube 上面的教程，非常详细而直观，同时还可以练习英语听力，看自己感兴趣的英语视频内容应该是学英语最佳的途径之一了。 然后发现了这个 netlify 网站 ，号称：Everything you need to deploy your project. 在静态网站的基础上，扩展很多功能 Auth/Form/Lamda 等，包括部署 CI/CD 等，单人免费，多人收费。考虑到结合 Hugo, google AWP, netlify, AWS lamda 和 facebook Fauna 无服务数据库，就可以做很牛的网站和 App 服务了。 未来技术的发展会进一步简化人们提供服务的能力，从人人可以发 Blog，到人人可以提供应用服务，甚至到人人可以搭平台…… 英语学习发现了这个视频 How to learn any language in six months Chris Lonsdale at TEDxLingnanUniversity，5 个原则和 7 个行动，超级棒的学习心法！而且在电视上看到这人的英语学习视频，准备购买了来学，似乎感觉自己真正找到了学习英语的法门。 Ted——6个月掌握外语学习方法（英语字幕） [TED经典视频：6个月掌握流利的外语学习方法] 龙飞虎 英语学习方法 6个月从0学英语 语法是你的朋友 得到招聘赠书]]></content>
      <tags>
        <tag>hugo</tag>
        <tag>netlify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当日笔记-20080921]]></title>
    <url>%2F2018%2F09%2F21%2Fdaily-note-20080921%2F</url>
    <content type="text"><![CDATA[准备做的事 尝试使用 Hugo； 目录结构： archetypes：包括内容类型，在创建新内容时自动生成内容的配置 content：包括网站内容，全部使用markdown格式 layouts：包括了网站的模版，决定内容如何呈现 static：包括了css, js, fonts, media等，决定网站的外观 常用命令： hugo server -t hyde --buildDrafts 其中 -t 指 theme 主题， --buildDrafts 指草稿也渲染。 尝试将 Blog 从 Hexo 转到 Hugo； 用 Hexo 生成目前的 Blog 需要 36 秒，够慢的，看换了 Hugo 后会是多快？ 找到 hexo2hugo 尝试一下。基本可用，但仅能将 _posts 目录下的 md 文件转换一下格式，所以仍存在的问题如下： 并不能转换其他的配置功能，如搜索、回复、赞赏、分享等功能； 转换时未能处理命名为 index.md 的问题； 转换时未能处理无 title 的 meta data 问题，导致显示列表中没有标题链接； 转换时未处理摘要的问题，导致列表中显示大段文字的情况； 找到 Migrate from Hexo to Hugo 看一下。 还有 Migrating From Hexo To Hugo 提到了 Gutenburg (written in Rust) 尝试将转换过程写成自动化脚本，开放为开源项目； 想继续使用 Next 主题，找到了： NeXT is a fast and clean theme for Hugo. which was inspired by a Hexo theme named NexT. 考虑有些需要的功能可以 fork 后提 pull request 支持项目。 遇到的问题 Python2 和 Python3 共存，尝试运行 pip 安装 pytoml，结果用 python 运行时，仍然提示未安装，通过 which python 和 which pip 两个命令才发现，python 指向 python2 的版本，而 pip 指向 pip3 的版本，测试后发现当两个版本共存时，最好在使用具体命令时，要用 2 版本就用 python2 和 pip2 ，要用 3 版本时，就用 python3 和 pip3 ，这样就能明确区别开了。 尝试 HexoConvertToHugo 失败，不太好用，文档也不清楚，测试后报错，暂时放弃。 使用 hexo2hugo，开始的时候报错，以为是 datetime 库没安装，但安装后仍然报错，结果试了一下 python3 居然成功了，说明这个脚本是用 Python3 语法写的，Python 的这两个版本区别还真是麻烦，应该在脚本的最前面加上注释才对，或者直接改一下后缀名： xxx.py3 就清楚了。 使用 hexo2hugo，遇到第一行不是 --- 的文档会报错，找不到 meta 信息，看了一眼程序逻辑比较固化，暂不修改了，直接修改文档匹配规则。 添加 next 主题，全新的站点，只添加一个文章，但在首页上看不到，能看到 next 的主题起作用了。换用 ananke 主题就显示正常了。一批批转移文件倒是可以，怀疑可能是 index.md 文件命名的问题，至少会导致 All Posts 链接被覆盖。 灵感记录 互联网时代，每个人都可能成为扫地僧，整个互联网就象是少林寺的藏经阁，要学什么、怎么学，就要看你自己怎么把握了。 萧峰和慕荣的爹都练走火了，为什么扫地僧没练走火？因为扫地僧不急功近利，有雄厚的佛法心法。 什么是互联网的修炼心法？终身学习！]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
        <tag>hugo</tag>
        <tag>next</tag>
        <tag>python</tag>
        <tag>灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在得到 App 上听书《知识的边界》和《走近2050》感悟]]></title>
    <url>%2F2018%2F09%2F21%2Fbook-comprehend%2F</url>
    <content type="text"><![CDATA[人类已经进入互联网时代，互联网对人类的很多方面产生了巨大而深远的影响，有些方面在商业和科技的促进下转变得比较快，比如电子商务、信息搜索、出行交通等，但有些方面就显得相对落后，如：政府效能、教育培训、人才评定等，通常受阻于政策、传统、观念、制度等。 特别是教育培训方面，目前的学校教育依然延续着工业时代的教学方式和考试制度，延续着数年甚至数十年不变的课程和教材，很多细节上都缺乏深思与变通。 早期中国人在竹签上刻字，后来用毛笔写字，现在还需要吗？在电脑时代，更多的文字创作将由电脑输入产生，是不是更应该学习的是打字或语音输入呢？而现在的学校教育依然是使用铅笔、钢笔写字，也许在不久的将来，回想起来才会发现这些细节的迟滞和落后。 如果你去问十个小学生，通常有九个都不喜欢写字，我认为写字这种方式未来并不会绝迹，就象毛笔字一样会变为一门艺术，只有少数对它情有独钟的人去练习和创作，而这通常会是在十多岁的少年时期才会有些人有兴趣去钻研的事，当然也可能象钢琴那样会成为少数人从小就开始苦练的一门手艺，不过考虑到硬笔书法的艺术性和难度，估计这种可能性不大，毕竟电脑设计领域已经可以将很多的优秀手写字体转化到电脑中了，只需要打字后切换一下字体就可以输出漂亮的硬笔书法体的文章了。 另一个方面就是教学方式了，互联网时代，知识的边界已经极大地扩展，人们基于兴趣可以在网上冲浪，可以通过一个个链接通向全新的领域和世界，未来的人才不再如工业时代那样统一和标准化，更加人性化、多样化、奇葩化，很多人基于自己的兴趣，可能会身兼数个你无法想象的技能组合，而这样的多样性才会给世界带来很多全新的创新思想和科技。因此我们的教学方式也应该变得更加符合这种发展的自然状态，也许： 不再有课堂，而是一个自由上网、自由交流、自由合作的俱乐部； 不再有课程，而是遇到什么问题，解决什么问题，遇到什么兴趣，再观看什么教学视频，俱乐部的系统会记录学生的学习路径，适时地推送恰当的学习资料、视频和测试题等； 不再有专职的老师，而是集体学习、互相进步的社群，可以结伴前行，可以搭配协作，可以远程互助等，没有老师，所有人都在其中自学，同时又可能是每个人都是老师，在必要的时候教授别人相应的知识，解答别人相应的困惑，记录下自己的学习经验和感悟供他人参考…… 未来人类更加不需要顾虑物质生活的限制了，而人类会逐渐发现对物质生活追求而获得的满足感将会非常有限，毕竟一个人整天吃喝玩乐也持续不了多久，终归会落入空虚和无聊之中，而对于未知世界的探索将会填补这些需求，也就是人们会更倾向于对精神生活的追求，而精神世界的追求则是有无限的想象空间的，随着科技的发展，人们可以更随心所欲地发展个人的兴趣爱好，多数时间感觉更象是在玩耍中不断扩展自己的知识边界，也就是传统意义上的学习和提升，同时也会不断涉及到社会的高级工作中，因为低级工作通常已经被机器智能所代替了，人们在这些工作中创造出更多更灿烂的文化和科技等，使得人类文明进一步繁荣和发展……]]></content>
      <tags>
        <tag>得到 App</tag>
        <tag>互联网时代</tag>
        <tag>教育</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go 语言学习]]></title>
    <url>%2F2018%2F09%2F19%2Fgo-learn%2F</url>
    <content type="text"><![CDATA[安装、升级、卸载等 官网 中文官网教程 Golang 速查表 安装简单，按官网的说明来就好了，macOS 上就是下载个 pkg 的包双击安装即可。 卸载也简单，删除那个 /usr/local/go 的目录即可。 升级官网上没提，搜了一下基本就是先卸载再安装，我试了一下直接安装最新下载的也可以，会提示发现旧版本，确定后会自动卸载再安装。 国际惯例：Hello world! 参考：Go安装的设置问题：GOROOT，GOPATH 学习项目：Learn golang notes 名词概念 程序实体：变量、常量、函数、结构体和接口等的统称。 标识符：各个程序实体的名字。可以是任何 Unicode 编码可以表示的字母字符（甚至中文，但不推荐）、数字以及下划线等，但首字母不能是数字。 命令源码文件：可以被直接运行，也包含程序实体。 库源码文件：不可以被直接运行，仅用于存放程序实体。 GOPATH：Go 语言的源码文件都需要存放在环境变量 GOPATH 包含的某个工作区（目录）中的 src 目录下的某个代码包（目录）中。 *string 是字符串的指针类型，而不是字符串类型。 := 是重定义变量类型并赋值，可以改变外部变量类型和值，而 = 只能赋给相同类型的值，类型不对时编译期会报错。 类似 toString() 方法的接口： 123type Stringer interface &#123; String() string&#125; Channel and go routines, 同一时间只允许一个 go routine 访问 channel，所以可以用这个机制来进行安全稳定的 concurrency 并发编程。 go run -race main.go Running with race detector. 使用竞跑模式运行，各 goroutine 会争抢优先级，方便发现一些隐藏的多 goroutine 运行时冲突问题。 初学者入门极客时间的那个 《Go语言核心 36 讲》 显然不是针对初学者的，所以要先看看以下内容： 官方教程 高级内容 Advanced Go Concurrency Patterns 介绍了 goroutine 编程的一些高级模式和技巧，如： for select 循环 select nil channel case run race detector service channel, reply channels(chan chan error) Web Framework iris 号称最快的 web 框架，因为基于fasthttp性能非常的好，需要考虑的是如果选它做web框架，你的代码将难以迁移到别的框架上,因为它实现了和标准库net/http不一样的接口。 看了一下文档，相当全面。 Hugo The world’s fastest framework for building websites 静态网站生成器 零基础使用Hugo和GitHub Pages创建自己的博客 非常专业的博客 Basic Usage 基础使用方法介绍 Host on GitHub 官方文档 Echo 最流行的框架，功能、文档齐全 Revel 全栈框架，但据说不太合 golang 的语法习惯。 借鉴的java和scala语言的 play框架 的很多想法。 Martini 据说是最易用的 web 框架，是一个强大为了编写模块化Web应用而生的GO语言框架。 Negroni 不是一个框架，它是为了方便使用 net/http 而设计的一个库而已。 Beego 国人开发的一个使用 Go 的思维来帮助您构建并开发 Go 应用程序的开源框架 Golang Web FrameWork 比较 Go语言的Web框架 谁是最快的Go Web框架 使用Golang（Margini）+Mongodb打造你的第一个站点 GraphQL GraphQL 用例：使用 Golang 和 PostgreSQL 构建一个博客引擎 API GraphQL Starter Kit for GoLang A GraphQL server example written in GoLang integrating with Cassandra and MongoDB. graphql-go/graphql An implementation of GraphQL for Go / Golang 常见问题重复定义 遇到 no new variables on left side of := 报错，说明左边的变量被重复定义了，去上面的代码中找同名的变量，一定有，解决方法就是换个变量名。 通道锁死 fatal error: all goroutines are asleep - deadlock! 一般发生在通道中没内容，而不断从通道取值时，另一种情况是向通道送值，但没放在单独的 goroutine 中。 解决思路，一个是将通道送值放在 go func 即 goroutine 中，另外就是取值用 for select 后要有退出机制，在恰当的条件时 return 就可以退出，实在没有合适的条件，可以用 time.After 设置超时退出。 文件组织规则 同目录的代码包声明要一致； 代码包声明可以与目录名称不同； 名称首字母大写的程序实体才可以被包外引用，否则只能被包内引用。 internal 代码包仅能被当前模块的其他代码引用，即模块级私有。 同目录中只能有一个入口函数 main，否则会被（vscode）警告，算是最佳实践吧。 Go 相关项目 Docker 容器 Cobra Cli 开发命令行工具的工具，Go 语言的牛 X 工具。 Viper Go configuration with fangs! 管理配置文件的工具。 Afero A FileSystem Abstraction System for Go Robotgo Golang 跨平台自动化系统，控制键盘鼠标位图和读取屏幕，窗口句柄以及全局事件监听 练习题：Web Crawler终于完成了整个学习，最后这道题记录如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package mainimport ( "fmt" "sync" "time")type Fetcher interface &#123; // Fetch returns the body of URL and // a slice of URLs found on that page. Fetch(url string) (body string, urls []string, err error)&#125;const TIMEOUT = 3const MAX_DEPTH = 4var queue = make(chan Job)var successes = make(chan map[string]string)var errors = make(chan map[string]string)var history = History&#123;h: make(map[string]Job)&#125;type Job struct &#123; url string depth int&#125;// History is safe to use concurrently.type History struct &#123; h map[string]Job mux sync.Mutex&#125;// Inc increments the historyfunc (c *History) Add(url string, depth int) &#123; c.mux.Lock() // Lock so only one goroutine at a time can access the map c.h. _, exist := c.h[url] if !exist &#123; c.h[url] = Job&#123;url, depth&#125; queue &lt;- Job&#123;url, depth&#125; &#125; c.mux.Unlock()&#125;func fetchWeb(url string, depth int, fetcher Fetcher) &#123; if depth &lt;= 0 &#123; return &#125; body, uris, err := fetcher.Fetch(url) if err != nil &#123; // fmt.Println(err) errors &lt;- map[string]string&#123;url: err.Error()&#125; return &#125; // fmt.Printf("found: %s %q\n", url, body) successes &lt;- map[string]string&#123;url: body&#125; for _, u := range uris &#123; history.Add(u, depth-1) &#125;&#125;// Crawl uses fetcher to recursively crawl// pages starting with url, to a maximum of depth.func Crawl(url string, depth int, fetcher Fetcher) &#123; quit := time.After(TIMEOUT * time.Second) // Timeout // Fetch URLs in parallel. // Don't fetch the same URL twice. // This implementation doesn't do either: go history.Add("https://golang.org/", 4) for &#123; select &#123; case q := &lt;-queue: // fmt.Println(q) go fetchWeb(q.url, q.depth, fetcher) case s := &lt;-successes: for url, body := range s &#123; fmt.Println(url, body) &#125; case e := &lt;-errors: for url, err := range e &#123; fmt.Println(url, err) &#125; case &lt;-quit: fmt.Println("quit") return &#125; &#125;&#125;func main() &#123; Crawl("https://golang.org/", MAX_DEPTH, fetcher)&#125;// fakeFetcher is Fetcher that returns canned results.type fakeFetcher map[string]*fakeResulttype fakeResult struct &#123; body string urls []string&#125;func (f fakeFetcher) Fetch(url string) (string, []string, error) &#123; if res, ok := f[url]; ok &#123; return res.body, res.urls, nil &#125; return "", nil, fmt.Errorf("not found: %s", url)&#125;// fetcher is a populated fakeFetcher.var fetcher = fakeFetcher&#123; "https://golang.org/": &amp;fakeResult&#123; "The Go Programming Language", []string&#123; "https://golang.org/pkg/", "https://golang.org/cmd/", &#125;, &#125;, "https://golang.org/pkg/": &amp;fakeResult&#123; "Packages", []string&#123; "https://golang.org/", "https://golang.org/cmd/", "https://golang.org/pkg/fmt/", "https://golang.org/pkg/os/", &#125;, &#125;, "https://golang.org/pkg/fmt/": &amp;fakeResult&#123; "Package fmt", []string&#123; "https://golang.org/", "https://golang.org/pkg/", &#125;, &#125;, "https://golang.org/pkg/os/": &amp;fakeResult&#123; "Package os", []string&#123; "https://golang.org/", "https://golang.org/pkg/", &#125;, &#125;,&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[再见了 Redux （翻译）]]></title>
    <url>%2F2018%2F09%2F05%2Fgoodbye-redux-cn%2F</url>
    <content type="text"><![CDATA[作者：Jack Scott 原文（英语） 国内网可能访问不到……大致翻译如下： 本文主要分析了一下我们过去为什么需要 Redux，而为什么以后又不再需要了。 在过去的几年里，互联网技术已经转向用前端 JavaScript 框架来实现网站和手机应用，以达到更好的用户体验。这非常棒 🔥 ，我个人很欣赏这些框架提供的灵活性。 但是灵活得是否有些过头了…… 为了能更好地理解这个问题，让我们把时钟拨回到 JavaScript 框架出现以前，看看我们是怎么开发应用的。 ⏳ JavaScript 以前的大陆 A Land Before JavaScript…在前几个前端框架（最值得注意的是AngularJS、Backbone和Ember）出现之前，我们只是在服务器上渲染模板，然后将完整的HTML页面发送到浏览器。当时流行的框架包括： Django (Python)——2005年7月21日发布 ~13 年前 Ruby on Rails —— 2005年12月13日发布 ~13 年前 Symphony (PHP) —— 2005年10月22日发布 ~13 年前 这些框架主要是围绕了 MVC 概念也就是 Model-View-Controller 来开发的，Model 表示数据的模型，View 表示怎么显示这些数据，而 Controller 则连接这两部分。 我的意思是说，这其中也有 JavaScript，但我们更多的时候是在说 jQuery 做的滑动条和一些完全没必要的动态网页效果 在这些框架上编写的应用有一些问题，但总得来说还不错，直到有一天 Ryan Dahl 有了一个很棒的主意，他开发了第一版的 Node.js，可以让开发人员写服务端程序，而不止是用 JavaScript 做些愚蠢的动画。 Node.js ——2009年5月27日发布 ~9 年前 猛然间人们似乎看到了 JavaScript 的无限可能性，用一丁点儿的代码就能做很多事儿，这充分打开了其他开发人员的想象力，人们不仅创建更多强大的 Node.js 工具，还开始创建有趣的前端框架，在接下来的几年里，JavaScript 就象滚雪球一样高速发展起来： Express.js（后端）——2010年11月16日发布 ~8 年前 Backbone.js（前端）——2010年10月12日发布 ~8 年前 AngularJS（前端）——2010年10月20日发布 ~8 年前 Ember.js（前端）——2011年12月8日发布 ~8 年前 这就开始了应用开发模式的重大转变。之前由服务端直接处理的 MVC 模式被分拆为两部分：一个服务端的 MC 和一个客户端的 V(MC)，客户端使用的就是上述的前端框架。在早期的这些框架中，还包含 Model 和 Controller 层在 View 中。两份 Model 和 Controller，前端也有一份 MC，这样看来是要写更多的代码了。 🤦‍ 脸书有个头疼的问题 Facebook Had A Problem正当所有人开心地使用上述方案的时候，Facebook 来了，随着它的迅速崛起，Facebook 变成了最大的网页应用，而为了解决页头上即时消息的数量显示问题（实际上这个小问题在海量用户使用的场景下是比较复杂的），旧的方案也并不能很好地应对…… 于是他们推出了 React： React（前端） ——2013年 三月发布 ~5 年前 而 React 只管 View 层，于是又有了 Flux，之后是 Redux（Redo Flux），有兴趣了解详情的可以看这个视频： Youku视频 QQ视频 🍐 ……于是这东西变得象个鸭梨 …Then Things Started to Go Pear ShapedRedux 的工作方式是把一个应用中几乎所有的动态信息都保存在一个 JavaScript 对象中。这样不管你在应用的哪个地方看到的数据都来自同一个地方，也就能保持一致，这样也就解决了 Facebook 所头疼的问题。 于是突然又来了一种新框架：React + Redux 解决方案，Facebook 用它来解决问题，而从此以后所有人都过上了幸福的生活……对吗？ ✋ 不尽然 Not quite.问题在于人们（包括我）开始用一个对象保存所有信息，其中的每一部分都是由服务端获得，没错这可以保证数据的及时更新，但同时也存在 3 个缺点： 这需要大量的多余的代码才能很好地运行，这很浪费时间。 因为所有代码放在一处，这可能带来“旧数据”的问题，也就是说你可能在应用中见到一些来自之前状态的不想要的数据。 对于新的开发人员学习曲线太高，继而使得前端Web开发很难被新的开发人员采用。 我们有一个向用户显示数据的相对简单的老式 MVC 框架应用，其中也就是几个简单的模板，在2005年，我们成功地将它转换为一个单页面应用，它的前端代码通常是后端代码的 10 倍。例如：我最近开发了一个简单的应用，然后我用 WakaTime 来衡量我在编码上的耗时情况，以下是测量结果： React Redux 前端代码库—— 32 小时. Express + Mongoose 后端代码库——4 小时. 🤯 你当真？Are you serious??我花了 8 倍的时间在前端？让我们看看原因吧，下面是一个示例，一个很普通的取数据（例如取得所有用户）到前端的流程： 🚧 警告：下面的步骤描述非常技术化，如果你看不太懂没关系。Warning: the following steps are super techy so don’t worry if you get lost. 创建一个组件来显示用户列表（这一步没啥问题）； 创建一个 fetch 请求到后端接口； 在 state 中添加一个新字段； 添加一个 action 用来更新 state 的数据； 添加一个 thunk 方法来运行 fetch 请求，然后使用新的 action 来更新 state 状态； 使用 connect() 将这个 thunk 方法加到组件中的 dispatch 方法中； 再次使用 connect() 从 state 中提取数据； 在组件的 prop types 属性类型中声明 thunk 方法和提取的数据字段； 在 componentDidMount() 方法中调用 thunk 方法； 最后，渲染数据到界面； 我的天……10步，回到 Ruby on Rails 的时代，我只需要把数据放到 HTML 的模板中就完事儿了，达到的效果差不多，我想这中间肯定有什么问题吧？！ ☝️ 一条新的路径 A New ApproachRedux 只是解决了前端数据的一致性，但它也带来了如前所述的问题，那么它的价值到底是什么？ 基本上我们重写了整个前端只是解决了屈指可数的几个小问题。 Facebook 也意识到了这个问题，启动了一个新项目叫 GraphQL，GraphQL 目前还是个技术名词，我不确定大家是否知道它为什么酷？ GraphQL 完全不同于 Redux，Facebook 又创造了一个大神级的产品，但却没指出这宝贝为什么这么重要，这也是为什么我花时间写此文的原因。 简言之，如果说 Redux 是一匹马的话，GraphQL 就是一辆车。 什么？怎么 Redux 成了一匹马？我之所以把它们比做一匹马和一辆车，原因是这俩完全是两个物种，一个是有四条腿的马动物，一个是有四个轮子的机器。然而，它们的作用是一样的，都是把人运到想去的地方。虽然它们各自有不同的适合场景，但通常来说，汽车会更快些。 那么，GraphQL 到底是什么？官方文档是这样说的：“GraphQL 是一种 APIs 接口的查询语言”，感觉不清不楚的，其实他们所谓的查询语言基本上一个就可以替代上百个 HTTP 接口，因为这个技术还很新，所以文档和支持的技术还有点难懂，有一定的学习曲线。这儿给你一个例子看是否有帮助： GraphQL 可以替代类似这样的接口： GET /users/1234567890 POST /cars PUT /example/endpoints 只查询你需要的字段，如下： 123456&#123; user(id: "1234567890") &#123; name, email &#125;&#125; 返回： 123456&#123; &quot;user&quot;: &#123; &quot;name&quot;: &quot;Luke Skywalker&quot;, &quot;email&quot;: &quot;luke@iamyourfather.com&quot; &#125;&#125; 等一下——自定义的查询……这可是需要点儿时间去实现的，也许你这么认为~ 但实际上不用，原因在于：由于只请求需要的数据，突然你不需要那么多服务端请求了，也就是说你不需要写那么多代码去处理那么多服务端请求了，于是，你就节省了大量不需要实现的代码和时间。 🤷‍ 但这就能替代 Redux 了吗？But how does this replace Redux?问得好！简单地说，不能。不过，它鼓励你不要象 Redux 那样把所有信息存在一个单独的对象中，因为每个查询只针对应用的一小部分，而不是整个应用。在一整个应用的数据源中只关注一小部分，这应该算是个 anti-pattern 反模式、反常识（甚至是有点不合逻辑）的。 通过使用 GraphQL 你就可以摆脱对 Redux 的依赖从而省掉大量的代码。 还有一点要注意：Redux 和 GraphQL 是可以共存的，这样你可以平滑地过渡，这儿有一些关于两者整合的文章： Integrating with Redux | Apollo React Docs 用不用 Redux 变成一种选择。是用它解决一些小任务而面对头疼的问题，还是换一种方法完成那些任务？ 那么，你会怎么选择？Redux 在当时确实解决了问题，但就在同时，Web 开发行业又在 Web sockets 领域有了巨大的进步。 Web sockets 是在服务端和客户端建立持续的连接，服务端就可以通知客户端何时更新。你猜怎么着？GraphQL 用一种叫 subscriptions 的订阅技术直接就能支持 web sockets，我们可以用这种 subscriptions 的订阅机制来更新应用中想保持同步的部分。 核心的区别在于：与其让客户端（用 Redux）告诉我们哪里要更新，不如让服务端直接通知客户端更新。结果是一样的，这儿有一些例子是怎么用 MongoDB 或 Mongoose 实现 Web socket 和 subscriptions 的。 A Node.js Perspective on MongoDB 3.6: Change Streams Mongoose v5.2.12: API — Model.watch() 🚀 未来很精彩！The Future Looks Awesome!GraphQL 开发没多久，但眼下也可以用在产品上了。我不想撒谎，官方文档确实能把人搞晕，需要对 JavaScript 和 服务端运行机制有很强的理解才行。然而如果你还没那么强，但想了解更多，这有一个很流行的教程： GraphQL: A query language for APIs. 还有很多有用的库可以帮你逐步地整合 GraphQL 到已有产品中。不用担心，你不用一次弄完，这些库可以帮你轻松地、慢慢地改善你的应用。Apollo 就是一家做这事儿的公司。 Apollo GraphQL 好了，我希望这篇文章可以对阐明一些复杂的概念有帮助。 如果你喜欢这篇文章，请点赞——这对我来说是很大的鼓励——或者有问题请留言。 谢谢！🙌]]></content>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>graphql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vscode 的 vi 模式下，按中文标点移动光标的方法]]></title>
    <url>%2F2018%2F08%2F27%2Fvscode-vi-segment-chinese-punctuation%2F</url>
    <content type="text"><![CDATA[问题描述首先，vscode 是目前最好的编程工具，未来前途也无可限量，其次 vi 的快捷键模式也是最高效的键盘输入模式，在 vscode 中可以添加 vi 快捷键的支持（在首选项-按键映射扩展中可以安装 Vim 即可，或在插件商店搜索：@recommended:keymaps 也能添加）。 但是在编辑中文时会有一个问题： 因为英文单词是由空格隔开的，所以在 vi 模式时按 w 键天然是能按单词移动的，而中文字句是连在一起的，所以会在移动光标时，整段中文字直接跳过，非常不符合使用的习惯。 解决方法在 vscode 的用户设置（在 macOS 中按 Cmd + , 编辑）中添加这两项即可： 12&quot;editor.wordSeparators&quot;: &quot;`~!@#$%^&amp;*()-=+[&#123;]&#125;\\|;:&apos;\&quot;,.&lt;&gt;/?，。；、：“”！？《》【】……￥&quot;,&quot;vim.iskeyword&quot;: &quot;/\\()\&quot;&apos;:,.;&lt;&gt;~!@#$%^&amp;*|+=[]&#123;&#125;`?-，。；、：“”！？《》（）【】……￥&quot;, 前面都是默认的，后面只是添加上了中文的标点符号，这样就不会整段移动，而是在中文标点处停止再继续，基本符合使用的习惯了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何保持专注高效地工作]]></title>
    <url>%2F2018%2F07%2F31%2Fhow-to-focus-work%2F</url>
    <content type="text"><![CDATA[问题和现象小张喜欢做运维技术研究，特别是最新的 k8s 技术，在应聘时选择了一家公司，就是因为这家公司有相关的 k8s 方面的技术栈，然而到了这家公司一段时间后，感觉最近工作越来越压力大，越来越不顺利。 具体的一个事例是这样的，公司需要安装一套监控系统，小张本来是会直接部署服务器的，然而对技术的热爱，让他想去尝试用 docker 来实现部署，于是选择了用这个方案开始尝试，然而因为懂这方面技术的同事并不多，他只能一个人研究摸索，在这期间遇到很多技术难题，有些解决了，有些迟迟解决不了，也没有人可以讨论沟通，一个人在网上搜寻答案效率非常低。 同时公司其他同事还会因为各类大小不同的软硬件故障、系统问题时不时来打扰他，他也基本都热心去帮助解决，小张是一个遇到技术问题就想去解决的偏执狂，但这样也就会占用很多的工作时间，一转眼两周时间过去了，公司领导问监控系统的情况，得知居然还没有完成时，非常不满意，责令他当天必须完成，此时，小张感受到了无限的压力还有一肚子的委屈，却又不知道跟谁说理去，可谓“身心俱疲”啊！ 分析以上情况，我给予两方面的建议如下： 一、怎么安排好重要的工作？在接到公司安排的工作后，要做如下思考： 公司为什么要做这个？对公司的意义在哪里？ 预期的完成时间大概是什么时间？ 预期的完成状态是什么样子？ 比如上例中，可能的答案是这样的： 监控系统，这事对公司挺重要，即便技术上没什么难度，但多了决策的依据，所以对公司业务分析和决策很有意义，或者对于把控服务器的状态有很大的帮助，作为运维环节，监控系统也是必不可少的。 预期的完成时间，最长是一周，如果不顺利两周内怎么说也是要完成的。同时也可以跟公司沟通一下具体的期望完成时间。 预期完成的状态，其实要求并不高，只要先有一个监控数据界面就好了，后面有机会可以不断优化。公司并没有强调是不是用 docker 来容器化。 通过沟通和分析得到以上问题的答案后，就可以将这件事安排到自己的工作面板中了，工作面板分为四列：Backlog（任务池）、待处理、处理中和已完成。 Backlog（任务池）： 这里通常堆了一堆想要做的事情、别人安排的事情，但是目前一定还没有开始的事情。 待处理： 这里通常是近期准备开始的事情，相应的解决方案、配套资源都已经到位，都知道详细的需求了，没有什么阻碍和问题了，只差的是具体的执行和操作了，通常这里的任务是要有预估完成时间、具体的执行人员安排以及优先次序的排列的。 处理中： 这里通常一个人只有一件正在做的事，也就是当下优先级最高的事情，可以按一定的周期（如：每天）更新完成状态（如：完成35%，或 2/5 表示共有5个子步骤/任务，已经完成 2 个。） 已完成： 已经交出结果，并通过验收的任务，没什么好说的，可以记录下实际的完成时间，未来可用于复盘或与预计完成时间对比和参考，不断调整预估的准确性。 如果有些重要的工作环节比较多比较复杂，就需要拆分成多个任务放在上面的面板中，通常一个任务持续时间不要超过两天，但也不要短过半小时（即一个番茄钟的时间）。 二、怎么处理干扰多的情况？在公司工作，难免会有同事之间的协作，也就难免出现同事来打扰说事儿，首先不要在情绪上反感和讨厌这类打扰，通常来说这类打扰都是一次很好的机会，什么机会呢？ 了解公司问题、现状、同事的困难、业务的阻碍等； 表现你解决问题的能力、掌握的技术等的机会； 同事加强协作的机会，现在你帮他，也许哪天你也需要他帮你； 如果哪一天你发现，再也没人来打扰你了，估计反倒是个危险的信号，你可能要离开这家公司了，同事们已经不再需要你了。 那么干扰太多又会占用很多时间，影响正常的工作进度怎么办？以下列出处理的具体步骤： 当前是否在番茄工作中，如果是，礼貌地告知来访同事正在忙，大概15分钟后去找他； 如果不在番茄工作中，或者番茄工作完后，就主动去找来访同事，花10分钟了解问题缘由； 如果预估 5 分钟内可以解决，那就现场解决； 如果预估比较麻烦或者尝试了 5 分钟后仍不能解决，就给同事说明情况，告知问题的处理现状和可能原因，但要解决也许需要更多的时间和资源，需要另行安排。 在 4 的情况时，就要把问题和事情记录下来，也就是添加到 Backlog 一栏中，同时与当前手头的工作（即进行中那一栏的工作，通常只能有一件事）比较一下优先级，如果优先级不高，就继续手头的工作。 Backlog 中的工作最好也能排出优先级，最好能有预估的时间，初期可以给自己稍微宽松一些的期限设定，按照自己的工作时间来排程，比如：明天上午完成 A 事件，明天下午完成 B 事件，后天一天完成 C 事件的一半，大后天彻底完成 C 等。这样，你就可以给相应的同事或领导回报你的安排，如：“张总，您说的 C 事件，按我手头工作的排序，预计在后天开始，大后天完成，到时候需要您配合给我一台测试的电脑……您看怎么样？”，如果张总觉得不行，后天太迟，你可以把你当前的安排呈现给他，跟他沟通：“张总，您看，这是李总安排的 A 事件，还有王总安排的 B 事件，我预估顺利的话，明天一天也是要被占用的，如果您这事更急，可能需要您跟李总和王总一起商量一下，看我这边最优先做哪件。” 一旦最终商讨后定下了新的计划，就可以把新的时间安排以适当的形式（如：邮件、或公司的工作平台等）通知相关人员。 相信以上思路可以给出一些启发性的思路，具体的工作还要具体分析，但总的原则要抓住，那些影响高效专注工作的问题，都是有办法解决的，不急不燥，保持自律（戒除“贪、嗔、痴”，哈哈……），总是能够解决的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ant Design React 使用记录]]></title>
    <url>%2F2018%2F07%2F26%2FAnt-Design-React-Note%2F</url>
    <content type="text"><![CDATA[遇到的问题Table 组件的服务端分页问题 Table 表格 仔细看了一下，虽然 mock 中的数据是全部数据集，但是是模拟远程数据库的概念的，每次返回到客户端的数据还是单个页面的数据，所以这里可以理解为本身的设计就是支持服务端分页的。 路由带参数问题 Route props - match 下载 Excel 模板的问题 Using Node.js to download files 后端文档路径： http://jp-open-service.thinkmacro.cn/swagger-ui.htmlForm 相关参考： http://react-component.github.io/form/Post 提交跨域问题： 遇到 Failed to load http://jp-open-service.thinkmacro.cn/login: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested post 请求后，得到这个返回，是不是又是跨域问题？ 发现问题，接口是用 query 传参的 又发现：如果密码正确，就有那项，如果密码不对，报500错就没有了。 估计是抛出异常时走了不同的代码逻辑。 解决向 route 子组件统一传参的问题： How to pass props to {this.props.children} Passing props to React Router children routes 解决子组件中定义 meta 属性的需求： react-helmet A document head manager for React React Document Meta HTML meta tags for React-based apps. 相关文档资料 Dive into React codebase: Handling state changes 深入了解 React 的状态变化机制 React组件生命周期小结 React v16.3 版本新生命周期函数浅析及升级方案]]></content>
      <tags>
        <tag>antd</tag>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>react-route</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话理解 Node.js 异步单线程]]></title>
    <url>%2F2018%2F05%2F22%2Fbaihua-async%2F</url>
    <content type="text"><![CDATA[Nginx 和 Node.js 都是多进程单线程的。它通过事件轮询（event loop Node.js 事件循环）来实现并行操作，因此，我们要尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。参考 Understanding the node.js event loop 主线程和子线程，这里说的单线程，是说主线程只有一个，所以要把阻塞的运算处理分拆到子线程中去运行。 使用回调函数 以非阻塞操作进行请求响应 几种可能的响应网络请求的方式： 同步；最简单，但一个访问会阻塞其他访问； 分出新进程；还算简单，但大量的访问请求意味着大量的进程，会占用大量内存资源； 多线程；比较复杂，有些机器不支持线程，随着线程的增加，编程复杂度的增加也是很可怕的，很快就不知道怎么控制线程间的共享资源了。另外，线程占用内存会随请求数量增加快速增加，这也是为什么 Apache 比 Nginx 响应同样数量请求时占用更多的内存的原因。 单线程异步回调；也算简单，通过异步调用将主线程的任务分派到子线程中，通过回调函数来实现任务完成后的通知主线程及执行后续任务。 白话理解假设我们想做机器人卖米线的生意，我们要给机器人编程序，有煮米线的程序、收钱找钱的程序、擦桌子收碗的程序、端盘上饭的程序等。 同步的程序是最容易编写的，就是一件一件地做，一项一项地完成，一个步骤一个步骤地操作等。 那么同步的方式会带来什么问题呢？就是每来一个顾客请求，我们就开始处理这个请求，不理其他顾客甚至当前顾客的其他请求，如果当前的事情是比较费时的，比如煮米线，那么就会阻塞其他所有请求和顾客，这显然是不能接受的。 那么新进程的方式是什么意思呢？就好比复制多开了很多个米线摊，其他顾客的请求自然可以由其他米线摊来处理，但显然这很浪费资源，只有在需要开分店的时候才比较合适，那就是分布式架构加负载均衡所解决的问题了。但我们不能在一个店还没开好（高效运转）的时候就去搞连锁，那样会亏死的，所以先要把一个店的运转高效起来再说。 那么多线程的方式呢？可以想象就是一个摊儿或店，但雇佣了多个人，有人收钱，有人煮米线，但每个服务仍是同步单线程状态、即初级机器人水平，也就是说只专心做手头的事，做完一件事才做下一件事。 单线程异步回调的方式呢？就好像来了一个灵活的（机器）人（主线程），他来操作其他机器人，他接受请求，再命令其他专业的机器人做，然后他就又接受下一个请求…… 这样就需要其他机器人是可以接受命令的，而煮米线机器人原来的方法是同步的，如下： 12345678/** * 口味: 大/小份, * 份量: 麻辣/三鲜 */煮米线(口味, 份量) &#123; 花 5 分钟煮一碗 此口味 此份量 的米线; return 米线；&#125; 新的方法： 1234567891011121314/** * 需求参数： * 口味: 大/小份, * 份量: 麻辣/三鲜 * 完事儿干啥： * callback 回调函数 */煮米线(&#123;需求参数&#125;, 完事儿干啥) &#123; 花 5 分钟煮一碗 需求参数.此口味 需求参数.此份量 的米线; call 完事儿干啥();&#125;下单米线(某口味, 某份量, 服务员) &#123; 煮米线(&#123;口味: 某口味, 份量:某份量&#125;, 服务员.上菜);&#125; 调用方法： 12下单米线(三鲜, 小份, 服务员A);下单米线(麻辣, 大份, 服务员B); 运行结果： 12煮一碗 小份 三鲜 米线服务员A 端给客人 For 循环也要注意阻塞问题以下示例证明 for 循环较大时会是个阻塞操作，同时证明 Node.js 是单线程的。1234567891011121314function proveSingleBlock() &#123; var start = Date.now();//获取当前时间戳 var n = 0 setTimeout(function () &#123; console.log(Date.now() - start); for (var i = 0; i &lt; 1000000000; i++)&#123;//执行长循环 n = n+1; &#125; &#125;, 1000); setTimeout(function () &#123; console.log(Date.now() - start); console.log(n); &#125;, 2000);&#125; 我们在 Node.js 中就需要将如下的耗时较长的 for 循环： 12345678function block() &#123; var n = 0 for (var x = 0 ; x &lt; 1000000000; x++)&#123; //do something crazy. n = n+x; &#125; return n;&#125; 改写为下面这样： 1234567function noblock(callback) &#123; setTimeout(function () &#123; var r = block(); if (callback) &#123; callback(r); &#125; &#125;, 0); return 'async';&#125; 测试代码如下： 1234567891011121314151617var start = Date.now();//获取当前时间戳// block versionconsole.log(block());console.log('Block version:');console.log(Date.now() - start);// no block setTimeout versionconsole.log(noblock(function(r)&#123; console.log(r); console.log('No block version:'); console.log(Date.now() - start);&#125;));console.log('Main end:');console.log(Date.now() - start); 使用 ES6 的 Promise 实现异步123456789101112$('#link').click(function () &#123; console.log("Enter"); var asyncFunct = new Promise(function(resolve, reject) &#123; $('#link').animate(&#123; width: 200 &#125;, 2000, function() &#123; console.log("finished"); resolve(); &#125;); &#125;); asyncFunct.then((result) =&gt; &#123; console.log("Exit"); &#125;);&#125;); 还有 async/await, generator/yield 等 多线程方案用 libuv 库来支持多线程如果我们非要让 Node.js 支持多线程，还是提倡使用官方的做法，利用 libuv 库来实现。 libuv是一个跨平台的异步I/O库，它主要用于 Node.js 的开发，同时他也被Mozilla’s Rust language, Luvit, Julia, pyuv等使用。它主要包括了Event loops事件循环， Filesystem 文件系统， Networking 网络支持， Threads 线程， Processes 进程， Utilities 其他工具。 tagg2模块 threads_a_gogo 库threads_a_gogo 实现 nodejs 多线程，真正的非阻塞 多进程方案在支持 html5 的浏览器里，我们可以使用 webworker 来将一些耗时的计算丢入 worker 进程中执行，这样主进程就不会阻塞，用户也就不会有卡顿的感觉了。在 Node.js 中是否也可以使用这类技术，保证主线程的通畅呢？ clustercluster可以用来让 Node.js 充分利用多核 cpu 的性能，同时也可以让 Node.js 程序更加健壮，官网上的 cluster 示例已经告诉我们如何重新启动一个因为异常而崩溃的子进程。 webworker想要像在浏览器端那样启动 worker 进程，我们需要利用 Node.js 核心 api 里的 child_process 模块。 child_process 模块提供了 fork 的方法，可以启动一个 Node.js 文件，将它作为 worker 进程，当 worker 进程工作完毕，把结果通过 send 方法传递给主进程，然后自动退出，这样我们就利用了多进程来解决主线程阻塞的问题。 多进程和多线程大部分多线程解决 cpu 密集型任务的方案都可以用我们之前讨论的多进程方案来替代，但是有一些比较特殊的场景多线程的优势就发挥出来了，比如 http web 服务器响应静态文件的例子。 以 express 处理小型静态文件为例，大致的处理流程如下： 首先获取文件状态，判断文件的修改时间或者判断 etag 来确定是否响应 304 给客户端，让客户端继续使用本地缓存。 如果缓存已经失效或者客户端没有缓存，就需要获取文件的内容到 buffer 中，为响应作准备。 然后判断文件的 MIME 类型，如果是类似 html, js, css 等静态资源，还需要 gzip 压缩之后传输给客户端。 最后将 gzip 压缩完成的静态文件响应给客户端。 用 ifile 包能得到 10 倍的速度和效率，不过 express 的作者TJ 说： 请牢记你可能不需要这么高等级吞吐率的系统，就算是每月百万级别下载量的 npm 网站，也仅仅每秒处理 17 个请求而已，这样的压力甚至于 PHP 也可以处理掉（又黑了一把 php ）。 总结单线程的 Node.js 给我们编码带来了太多的便利和乐趣，我们应该时刻保持清醒的头脑，在写 Node.js 代码中切不可与 PHP 混淆，任何一个隐藏的问题都可能击溃整个线上正在运行的 Node.js 程序。 单线程异步的 Node.js 不代表不会阻塞，在主线程做过多的任务可能会导致主线程的卡死，影响整个程序的性能，所以我们要非常小心的处理大量的循环，字符串拼接和浮点运算等 cpu 密集型任务，合理的利用各种技术把任务丢给子线程或子进程去完成，保持 Node.js 主线程的畅通。 线程/进程的使用并不是没有开销的，尽可能减少创建和销毁线程/进程的次数，可以提升我们系统整体的性能和出错的概率。 最后请不要一味的追求高性能和高并发，因为我们可能不需要系统具有那么大的吞吐率。高效，敏捷，低成本的开发才是项目所需要的，这也是为什么 Node.js 能够在众多开发语言中脱颖而出的关键。 参考文档 js的单线程和多进程 Node.js的线程和进程 How can I create an Asynchronous function in Javascript?]]></content>
  </entry>
  <entry>
    <title><![CDATA[GraphQL 学习]]></title>
    <url>%2F2018%2F05%2F03%2FGraphQL-learning%2F</url>
    <content type="text"><![CDATA[实践 Using GraphQL with MongoDB Testing a GraphQL Server using Jest using-dataloader-to-batch-requests How GraphQL Replaces Redux js Client Bind GraphQL data to your UI with one function call. 相关网站 GraphQL CN A query language for APIs. 一种用于 API 的查询语言。 GraphQL 最佳实践 awesome-graphql The Fullstack Tutorial for GraphQL Youtube 视频教程 GraphiQL A graphical interactive in-browser GraphQL IDE. Live demo Lacinia - GraphQL for Clojure，Github Repo 一套 GraphQL 规范的完整实现，致力于维护对规范的外部兼容。 alumbra Simple &amp; Elegant GraphQL for Clojure! graphql-clj A Clojure library designed to provide GraphQL implementation. 流行的服务端框架、客户端库、服务 Getting started with TypeScript and Apollo Relay A JavaScript framework for building data-driven React applications Om Next w/ DataScript Node.js 实现： Apollo Server is a flexible, community driven, production-ready HTTP GraphQL middleware for Express, Hapi, Koa, and more. express-graphql 以下内容部分摘自微信文章：微服务下使用GraphQL构建BFF的实践 微服务架构的优势(virtue)：简单说来，微服务是一种架构风格。通过对特定业务领域的分析与建模，将复杂的应用分解成小而专一、耦合度低并且高度自治的一组服务。微服务中的每个服务都是很小的应用，这些应用服务相互独立并且可部署。微服务通过对复杂应用的拆分，达到简化应用的目的，而这些耦合度较低的服务则通过 API 形式进行通信，所以服务之间对外暴露的都是 API，不管是对资源的获取还是修改。 Isolation 隔离状态 Autonomy 自治 BFF 前端的中间层后端Backend for Frontends(以下简称 BFF) 顾名思义，是为前端而存在的后端 (服务) 中间层。引用了 BFF 之后，前端应用将直接和 BFF 通信，BFF 再和后端进行 API 通信，所以本质上来说，BFF 更像是一种“中间层”服务。 BFF 其实是一种 API Gateway 实现模式API Gateway 的三种实现： 一个 API Gateway 对所有客户端提供同一种 API，例：/api/users 一个 API Gateway 通过 Router 对每种客户端提供分别的 API，例：/mobile/api/users 和 /web/api/users 多个 API Gateway 分别对每种客户端提供分别的 API，例：如上，但两个 Gateway 分别为 Mobile Gateway 和 Web Gateway。 BFF 其实是 API Gateway 的其中一种实现模式，即 BFF 更类似于第三种 API Gateway 实现，通常一个 BFF 对应一种客户端，再由 BFF 去调用后端的实际 API。 GraphQL 与 REST 对比相比于 REST 风格，GraphQL 具有如下特性： 定义数据模型：按需获取 数据分层 强类型 协议而非存储 无须版本化 对于 GraphQL 和 REST 之间的对比，主要有如下不同： 数据获取：REST 缺乏可扩展性， GraphQL 能够按需获取。GraphQL API 调用时，payload 是可以扩展的 ; API 调用：REST 针对每种资源的操作都是一个 endpoint, GraphQL 只需要一个 endpoint( /graphql), 只是 post body 不一样 ; 复杂数据请求：REST 对于嵌套的复杂数据需要多次调用，GraphQL 一次调用, 减少网络开销； 错误码处理：REST 能够精确返回 HTTP 错误码，GraphQL 统一返回 200，对错误信息进行包装； 版本号：REST 通过 v1/v2 实现，GraphQL 通过 Schema 扩展实现； 微服务 + GraphQL + BFF 实践在微服务下基于 GraphQL 构建 BFF，例如在项目对应的业务场景下，微服务后台有近 10 个微服务，客户端包括针对不同角色的 4 个 App 以及一个 Web 端。对于每种类型的 App，都有一个 BFF 与之对应。每种 BFF 只服务于这个 App。BFF 解析到客户端请求之后，会通过 BFF 端的服务发现，去对应的微服务后台通过 CQRS 的方式进行数据查询或修改。 使用 GraphQL-express 框架构建项目的 BFF 端，然后通过 Docker 进行部署。BFF 和微服务后台之间，还是通过 registrator 和 Consul 进行服务注册和发现。 三个 App 客户端分别使用 GraphQL 的形式请求对应的 BFF。BFF 层再通过 Consul 服务发现和后端通信。 关于系统中的鉴权问题用户登录后，App 直接访问 KeyCloak 服务获取到 id_token，然后通过 id_token 透传访问 auth-api 服务获取到 access_token, access_token 以 JWT (Json Web Token) 的形式放置到后续 http 请求的头信息中。 在我们这个系统中 BFF 层并不做鉴权服务，所有的鉴权过程全部由各自的微服务模块负责。BFF 只提供中转的功能。BFF 是否需要集成鉴权认证，主要看各系统自己的设计，并不是一个标准的实践。 BFF is pary of Application, BFF 就是客户端的一部分 BFF 中定义的数据结构，就是客户端所真正关心的。 BFF 就是为客户端而生，是客户端的一部分。 需要说明的是，对于“业务的关注”并不是说，BFF 会处理所有的业务逻辑，业务逻辑还是应该由微服务关心，BFF 关注的是客户端需要什么。 GraphQL Mutation 与 CQRS不同于 query，所有 mutation 都会调用后端的 API，而后端的 API 对于资源的修改也是通过 SpringBoot EventListener 实现的 CQRS 模式。 新架构的测试在引入了 BFF 的项目，我们的测试仍然使用金字塔原理，只是在客户端和后台之间，需要添加对 BFF 的测试。 Client 的 integration-test 关心的是 App 访问 BFF 的连通性，App 中所有访问 BFF 的请求都需要进行测试； BFF 的 integration-test 测试的是 BFF 到微服务 API 的连通性，BFF 中依赖的所有 API 都应该有集成测试的保障； API 的 integration-test 关注的是这个服务对外暴露的所有 API，通常测试所有的 Controller 中的 API。]]></content>
      <tags>
        <tag>TypeScript</tag>
        <tag>React</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一图看懂 AntD 的结构]]></title>
    <url>%2F2018%2F03%2F29%2Fone-pic-know-antd%2F</url>
    <content type="text"><![CDATA[个人理解，仅供参考！ 在开发时，仅需关注图中的那些 *.js 文件即可。]]></content>
      <tags>
        <tag>AntD</tag>
        <tag>一图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年3月23日这期“歌手”听后感]]></title>
    <url>%2F2018%2F03%2F24%2F2018-3-23-singer-feeling%2F</url>
    <content type="text"><![CDATA[2018年3月23日这期“歌手”听后感这一期两位歌手都唱了崔健的歌，腾格尔唱《从头再来》，华晨宇唱《假行僧》，可见崔健中国摇滚之父的称号不是虚的。 从1993年大学时听过崔健的歌后，就将他奉为中国甚至世界摇滚中最为独特另类的一个，后来在几十年中，偶尔再听还是那么独特，不管时代如何变迁，他的音乐依然在每次听到的时候都有特殊的感觉。 这期“歌手”再次证明了这一点，崔健的摇滚即使在今天这个信息智能时代听起来依然是最新潮、最牛逼的！ 不过相对来说，我更欣赏华晨宇的改编，是新一代音乐人用自己的灵魂对崔健《假行僧》的自我诠释，中间一度听得我两眼含泪，华晨宇是个可怜孩子，心灵的孤独和寂苦在小时候长时间无人知道、无人理解、无人关爱，好在自己在音乐中找到了表达，从而也造就了今天的新一代音乐天才和新星。有过童年悲伤经历的人们应该能感受到音乐中那种透达心底的孤寂，也应该更能理解这表面有些怪异的音乐和演唱方式所传达的空灵宇宙间的无奈和无所谓…… 腾格尔的演唱基本是崔健摇滚的原本风格，没太多新的创新，当然也没有崔健原版的风格独特和反抗精神。嗯，再去找崔健的原版演唱会看一下……]]></content>
      <tags>
        <tag>歌手</tag>
        <tag>崔健</tag>
        <tag>华晨宇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么说一个全新的操作系统是必要的？]]></title>
    <url>%2F2018%2F03%2F05%2Fwhy-new-os-zh%2F</url>
    <content type="text"><![CDATA[注：此文是 OSv 官网介绍的文章，感觉对于理解 OSv 很有帮助，特翻译如下，原文地址 Today’s cloud-based applications run a heavyweight stack: the hypervisor, which divides the hardware resources among virtual machines; the operating system, which divides the virtual machine’s resources among applications; and the application server, which divides the application’s resources among the end users. 当今的云应用都运行在一个非常重的技术栈上： Hypervisor (虚拟机管理程序) ，要将硬件资源从虚拟机中分离； OS 操作系统，要将虚拟机从应用中分离； App Server 应用服务，要将应用资源从终端用户处分离。 Clearly, there is a lot of duplication going on. Each layer adds its own overhead in an attempt to abstract away and hide the problems caused by the lower layer. The result is inefficient and complex. 很明显，这中间有很多的重复。每一层都添加了额外的开销用来抽象和隐藏低一层所产生的问题。结果是低效和复杂的。 Enter OSv - the operating system for the cloud. On the one hand, designed and optimized to run on a hypervisor. On the other hand, designed to run an application stack without getting in the way. Designed for the cloud. 来到 OSv —— 专为云而生的操作系统。一方面，它是专为虚拟机管理而设计和优化的。另一方面，专为无障碍地运行整个应用（包括 OS 系统）。专为云设计。 It’s cloudy out there and we love it它就在云上，我们喜欢它！The public cloud era opens new horizons and opportunities for hi-tech businesses. Virtualization is dominant, resources are evergreen and agility is the key. The role of the OS in this form changes. The need to massively scale out forces developers to run multiple copies of identical Virtual Machines (VMs). VMs are the new process that needs to be lightweight, blazing fast, scalable and cheap. DevOps and PaaS solutions bypass the OS and allow developers to deploy their code directly to the cloud. All these goodies are rapidly penetrating the enterprise space with matching private cloud capabilities and virtual appliances that act as bridges to the public cloud 公有云时代为高科技企业展开了全新的视野和机会。虚拟机占到了主导地位，资源的快速响应和持久在线是关键。而操作系统 OS 的角色在这样的情况下也有所改变。大规模扩展的需求迫使开发人员同时要运行多个相同的虚拟机（VM）。 VMs 是一个需要轻量级、快速、可扩展和廉价的新流程。DevOps 和 PaaS 解决方案绕过操作系统，允许开发者将代码直接放到云上。所有这些优点都迅速渗透到企业空间中，并提供了与公有云相匹配的私有云功能和虚拟设备。 Virtualization 2.0虚拟化 2.0VMware had brought virtualization into the x86 world (recall that virtualization was introduced by IBM’s mainframes in the 70s). While VMware has done a fantastic job shifting the enterprise from physical to virtual, it stopped there. Amazon Web Services had wider vision; Amazon do not use terminology such as virtual machine. Amazon sees the entire user workload and solves scaling issues. VMware 将虚拟化引入到了 x86 型机的世界（记得虚拟化是由IBM的大型机在上世纪70年代引入的概念）。虽然 VMware 做了一项出色的工作，将企业从物理机带入虚拟机世界，但它也就止步于此。 而 Amazon 网络服务则有更广阔的视野； Amazon 不使用诸如虚拟机之类的术语。 Amazon 看到了用户整个的工作负载并解决了缩放问题。 The right(tm) way - the new world is compose out of the smallest building blocks possible, running in clusters of multiple VMs. Common components are NoSQL databases, MemCacheD, front end webservers, backend webservers, etc. One single application is hosted within the virtual machine. That application uses a fraction of the guest OS capabilities - there is no hardware as the hypervisor owns that, there are no real users as this is a server, there are no other apps to schedule. Users pay for CPU cycles they don’t really need and need to maintain and tune a full blown generic OS. 正确（TM）的方式 —— 新的世界是由尽可能小的积木组成，运行在多个虚拟机集群中。 常见的组件是 NoSQL 数据库，缓存，前端 Web 服务器，后台服务器等，单个应用程序托管在虚拟机内。该应用程序使用了客户机操作系统功能的一小部分——没有 Hypervisor (虚拟机管理程序) 中的硬件，没有真正的用户，因为这是一个服务器，没有其他应用程序需要去调度。 所以用户不必为他们并不真正需要的 CPU 损耗付费，也不必维护和调整一个完整的通用操作系统。 Unlike new infrastructure such as hypervisors, NoSQL, PaaS, etc, the operating system hasn’t changed much. The same OS image that powers physical machines, from tiny embedded devices to room-size top500 supercomputers, is also used in the cloud. 不象新的基础设施如 Hypervisors 虚拟机管理程序，NoSQL，PaaS 等，操作系统并没有太大变化。 与之相同的实现了物理机功能的操作系统映像 (从小型嵌入式设备的房间大小的TOP500超级计算机) 也都用在了云上。 Typical cloud workloads run application servers using Java, Ruby, Python and JavaScript (node.js). This historical evolution is not ideal - Java, Linux and the hypervisor implement parallel/duplicated mechanisms for protection and abstraction. These mechanisms are redundant when combined, and impose a large overhead in terms of CPU and memory. 常见的云应用服务器使用 Java、Ruby、Python 和 JavaScript (node.js)。而这个历史演变过程实际并不理想 —— Java, Linux 和 Hypervisor (虚拟机管理程序) 为了保护和抽象而实现了并行或复制机制。这些机制在组合时是多余的，在 CPU 和内存方面强加了大量的开销。 The management efforts needed to maintain Linux are extensive. Thousands of packages, multiple security updates, complex tuning and specialists to manage. It doesn’t stop in the OS level. JVM workloads require manual tuning in a variety of ways and VM templates and instances needs to be software managed by tools like Puppet and Chef. 维护 Linux 所需的管理工作是广泛的。 数千个包、多个安全更新、复杂的配置和专用列表需要管理。它不会停止在操作系统级别。JVM 工作负载需要以各种方式手动调优，VM 模板和实例也需要用像 Puppet 和 Chef 这样的工具软件来管理。 These tools help to manage multiple OS configurations but if we’ll examine their operation on a single OS instance, we’ll discover that their roots go to the Unix OS of the 1970s. They’re based on pushing human configuration files and strings to /etc files. Typical OSs still do not have a fully automated API. OSv takes a simpler approach, with a common REST API for all configuration and data collection. 这些工具有助于管理多个操作系统配置， 但如果我们在一个操作系统实例上检查它们的操作，我们会发现它们根本是在 20 世纪 70 年代的 UNIX 操作系统上建立的， 它们是基于将人为的配置文件和字符串入到 /etc 文件目录中来实现的。 常见的操作系统仍然没有完全自动化的 API 。而 OSv 则是用一个简单的方法，用一个共同的 REST API 来完成所有的配置和数据采集。]]></content>
      <tags>
        <tag>Hypervisor</tag>
        <tag>OSv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG 相关学习]]></title>
    <url>%2F2018%2F02%2F10%2FSVG-%E7%9B%B8%E5%85%B3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[JavaScript library SVG.js The lightweight library for manipulating and animating SVG. Bonsai A lightweight graphics library with an intuitive graphics API and an SVG renderer. Snap.svg The JavaScript SVG library for the modern web Draw library 15个最佳SVG的JavaScript库 推荐 SVG 图标素材网站 IconFont.cn 国内图标库网站 国内外社交网站矢量图标 FlatIcon The largest database of free icons available in PNG, SVG, EPS, PSD and BASE 64 formats. Worldvectorlogo 矢量标志的所有品牌 完全免费和无限制 Tools Gravit Designer 一款跨平台的设计工具，可以在 AppStore 中直接下载。新发现的，感觉不错，强烈推荐，需要英文门槛。 参考：欢迎来到设计利器Gravit Designer的世界 Omber 可制作图形和色彩渐变效果的工具，可在 AppStore 中直接下载。 Inkscape Draw Freely. 自油自画。跨系统，Linux 上也是首选。缺点：需要先安装XQuartz。 Vectr is a free graphics software used to create vector graphics easily and intuitively. It’s a simple yet powerful web and desktop cross-platform tool to bring your designs into reality. 可以在 AppStore 中直接下载。 macSVG An open-source macOS app for designing HTML5 SVG art and animation. Github repo Calligra part of the KDE community. GlipsSvgEditor An open source SVG graphics editor and a SCADA HMI editor. 似乎是(SCADA(Supervisory Control And Data Acquisition)系统，即数据采集与监视控制系统。)专业领域的画图工具，界面粗糙。 LaTeXDraw is a graphical drawing editor for LaTeX. LaTeXDraw can be used to 1) generate PSTricks code; 2) directly create PDF or PS pictures. LaTeXDraw is developed in Java and thus runs on top of Linux, Windows, and Mac OS X. You need Java 8 to launch LaTeXDraw. VectorPaint Draw SVG online. 在线绘制工具。]]></content>
      <tags>
        <tag>SVG</tag>
        <tag>Graphic</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Vision 学习]]></title>
    <url>%2F2018%2F02%2F07%2FComputer-Vision-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Computer Vision Library What are pros and cons of OpenCV and TensorFlow for computer vision? ccv A Modern Computer Vision Library SimpleCV Computer Vision platform using Python. Blepo Computer Vision Library Python教程 OpenCV vs VXL vs LTI: Performance Test I recently read this comparison of four vision libraries: OpenCV, VXL, LTI and OpenCV with IPP. It was in the book Learning Learning OpenCV: Computer Vision with the OpenCV Library, authored by the creators of OpenCV themselves. For those who aren’t familiar with these libraries, here’s a brief introduction. VXL VXL stands for Vision something Library. It is a C++ library that implements several common computer vision algorithms and related functionality. The idea is to replace the ‘X’ with one of the several letters: VGL = Vision Geometry Library VIL = Vision Image processing Library VNL = Vision Numerics Library VSL = Vision Streaming Library There are several other libraries as well LTI LTI-Lib is another object oriented library for computer vision. It has also been implemented in C++. It also includes classes that encapsulate multithreading, synchronization, serial port access, etc. And it ensures you don’t have to deal with changing operating systems or hardware. OpenCV Yet another computer vision library. It includes over 500 functions for various commonly used algorithms. It also comes with a machine learning library and a portable window creation library. With version 2.0, OpenCV comes with a C++ interface as well. Before 2.0, it was only the C interface. OpenCV + IPP OpenCV developers were friendly with the Intel Performance Primitives team. So, OpenCV makes use of IPP code (which is hand tuned and extremely optimized code) to speed up execution. And this, as you’ll see, gives a substantial boost to its execution speed.]]></content>
      <tags>
        <tag>Computer Vision</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2018%2F02%2F07%2FDocker-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Docker 学习 title: Docker 学习tags: [Docker]date: 2018-02-07 16:18:26 快速入门心法官网文档也好，网上其他的教程也好，都非常有“耐心”，一点点地教你怎么理解和使用 docker，但我在看这些教程和文档的时候其实很着急，因为我只想快速入门并且用起来，而且最好是按最佳实践的路子用起来，而不是象个初学者那样慢慢摸索。但就是没人把这条捷径说清楚…… 下面我就我所知道和理解的内容，写一点快速入门的心法： 首先知道 docker 大概是个什么？ 就我的理解，直白地说：就是一个轻量的虚拟机，在一个基本的内核基础上，层层叠加出想要的虚拟机环境。 同时要注意一个重要概念，类似于微服务概念，每一个 docker 虚拟机里面一般只做一件事，只支持一个服务，例如： web 服务、 hexo 博客服务等； 其次要知道拿 docker 来有什么用，最主要的用途在哪儿？ 目前就我的使用情况来说，就是一些开发部署环境在本机搭建起来很麻烦，不同的操作系统还有所不同，还要在本机安装一堆的包，还要在本机进行很多配置，而使用 docker 之后，就可以不用在本机安装了，本机干净了，又能快捷享用 docker 虚拟机中提供的服务。 保证应用项目在不同的主机上运行时一致，因为都是运行在 docker 中的，所以各种操作系统，各个电脑打开项目，只要正常安装了 docker 后，启动运行起来，都象是在 linux 中一样，因为 docker 虚拟机基本都是基于 linux 操作系统的。 如何快速入门使用？ 首先要有一定的基础，否则会遇到太多阻碍，个人觉得是要对 linux 系统的基础操作和一些工作模式要有一定的熟悉和了解，特别是网络方面比较清楚会有比较大的帮助，另外了解 git 的使用流程和基本命令会比较有帮助，对于理解 docker 这种虚拟机的管理模式也会比较有帮助，当然有一定的编程基础，熟悉一些语言开发也是必须的，毕竟 docker 就是帮助开发部署环境用的。 快捷路线就是 docker-compose 了，别在 docker 命令上花费太多时间，只要把 docker 和 docker-compose 安装好后，就直接找一两个 docker-compose 构建的开源项目来尝试，运行 docker-compose up 就可以了，这本来也就是使用 docker 后最大的好处之一，只需要一个命令，有 docker 镜像就启动服务，没有就相应地创建或下载，总之不用操心怎么安装环境什么的。 另一个注意点是尽量选择那些以 alpine 为基础的镜像，文件占空间小。 以上只是心法，具体的知识和教程可参考下面的内容，网上也多得是： 参考链接 使用 mongo docker 镜像 docker-compose使用示例 Docker Compose 配置文件详解 其中第15项 links 启发了我写数据库连接的方式：mongodb://admin:rootadmin@mgdb:27017/coral-reef 基本概念传统虚拟机：虚拟硬件和完整的操作系统，再运行应用；容器：运行于宿主的内核，没有自己的内核，没有硬件虚拟。 Docker 包括三个基本概念，涉及 Docker 的整个生命周期。 镜像（Image）[类]：由多层文件系统联合组成，支持容器运行和配置参数，无动态数据。 容器（Container）[实例]：运行于独立命名空间的进程，以镜像为基础层，之上是容器存储层（会随容器消亡）。数据卷不会消亡。容器是拥有不同 IP 地址从而使其成为网络上可识别的独立 Linux 进程。容器依赖于镜像，如果想删除某个镜像，必须先删除相应的容器。 仓库（Repository）：Docker Registry =&gt; Repository =&gt; Tag == Image，”repository:tag”，一个镜像可以对应多个标签 tag。 虚悬镜像（Dangling image）：docker pull 或 docker build 导致标签指向新镜像，旧的无标签镜像变成虚悬镜像。 黑箱镜像：使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像。 数据卷：volume Docker 网络强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。 创建一个新的 Docker 网络1docker network create -d bridge my-net docker 命令使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 docker主命令不要用后台运行，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出。正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] Docker run 详解当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从公有仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 Docker Registry 公开服务镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。 国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。 docker 编译一个 Dockerfile1docker build -t friendlyhello . 列出系统中的所有镜像：1234docker imagesREPOSITORY TAG IMAGE IDfriendlyhello latest 326387cea398 删除所有虚悬镜像：1docker image prune 删除所有无主的数据卷：1docker volume prune 删除本地镜像：1234567docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]# 删除所有仓库名为 redis 的镜像docker image rm $(docker image ls -q redis)# 删除所有在 mongo:3.2 之前的镜像docker image rm $(docker image ls -q -f before=mongo:3.2) 查看镜像的历史记录1docker history ubuntu:latest 在某个端口映射下启动该镜像：1docker run -p 4000:80 friendlyhello 1docker run -it --rm ubuntu:16.04 bash -i：交互； -t：终端； –rm 容器退出后将其删除； 12# 用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口docker run --name webserver -d -p 80:80 nginx 查看映射端口配置1docker port webserver 进入某个运行中的容器 bash1docker exec -it webserver bash 查看镜像、容器、数据卷所占用的空间1docker system df 列出系统中启动的容器：1234docker container lsCONTAINER ID IMAGE COMMAND CREATED1fa4ab2cf395 friendlyhello "python app.py" 28 seconds ago 关闭某个容器：1docker container stop 1fa4ab2cf395 Services12345678docker stack ls # List stacks or appsdocker stack deploy -c &lt;composefile&gt; &lt;appname&gt; # Run the specified Compose filedocker service ls # List running services associated with an appdocker service ps &lt;service&gt; # List tasks associated with an appdocker inspect &lt;task or container&gt; # Inspect task or containerdocker container ls -q # List container IDsdocker stack rm &lt;appname&gt; # Tear down an applicationdocker swarm leave --force # Take down a single node swarm from the manager docker 命令帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Commands: attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像 build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像 commit Create a new image from a container's changes # 提交当前容器为新的镜像 cp Copy files/folders from the containers filesystem to the host path # 从容器中拷贝指定文件或者目录到宿主机中 create Create a new container # 创建一个新的容器，同 run，但不启动容器 diff Inspect changes on a container's filesystem # 查看 docker 容器变化 events Get real time events from the server # 从 docker 服务获取容器实时事件 exec Run a command in an existing container # 在已存在的容器上运行命令 export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ] history Show the history of an image # 展示一个镜像形成历史 images List images # 列出系统当前镜像 import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应 export] info Display system-wide information # 显示系统相关信息 inspect Return low-level information on a container # 查看容器详细信息 kill Kill a running container # kill 指定 docker 容器 load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save] login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器 logout Log out from a Docker registry server # 从当前 Docker registry 退出 logs Fetch the logs of a container # 输出当前容器日志信息 port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端口 pause Pause all processes within a container # 暂停容器 ps List containers # 列出容器列表 pull Pull an image or a repository from the docker registry server # 从docker镜像源服务器拉取指定镜像或者库镜像 push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker源服务器 restart Restart a running container # 重启运行的容器 rm Remove one or more containers # 移除一个或者多个容器 rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除] run Run a command in a new container # 创建一个新的容器并运行一个命令 save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 load] search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像 start Start a stopped containers # 启动容器 stop Stop a running containers # 停止容器 tag Tag an image into a repository # 给源中镜像打标签 top Lookup the running processes of a container # 查看容器中运行的进程信息 unpause Unpause a paused container # 取消暂停容器 version Show the docker version information # 查看 docker 版本号 wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 Docker 高级网络工具和示例在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣： pipeworkJérôme Petazzoni 编写了一个叫 pipework 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。 playgroundBrandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 Python库，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。 Docker 官方三剑客Docker Compose 项目 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。 Docker Machine 项目在多种平台上快速安装 Docker 环境，在 macOS 上安装 xhyve 虚拟机支持： 1brew install docker-machine-driver-xhyve Docker Swarm mode 项目提供 Docker 容器集群服务，具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。与 Kubernetes 是竞争关系。 巅峰对决之Swarm、Kubernetes、Mesos Kubernetes vs Docker Swarm 选择焦虑症のKubernetes 与 Docker Swarm 使用方法：初始化一个 Swarm 集群：123docker swarm init --advertise-addr 192.168.99.100Swarm initialized: current node (7t2kqs1cmbw3r54921y9ofdcu) is now a manager. To add a worker to this swarm, run the following command: 1docker swarm join --token SWMTKN-1-4l54p60fpaumw188uk5yea8l3z0sd80q6ydiav0e8r12w5cog1-8i70bpp0wtxggiemi2wx63f3g 192.168.99.100:2377 To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions. 添加一个虚拟机后，加入此 swarm 遇到如下报错：1Error response from daemon: rpc error: code = Unavailable desc = grpc: the connection is unavailable KubernetesKubernetes 是 Google 团队发起的开源项目，它的目标是管理跨多个主机的容器，提供基本的部署，维护以及运用伸缩，主要实现语言为 Go 语言。 Kubernetes 实际上是一个希腊词κυβερνήτης，意思是”船的舵手”。 在这个意义上， Kubernetes 对于 Docker (集装箱船)倒是挺般配的。 kubernetes 架构简介 Kubernetes By Example 非常棒的 K8s 学习网站 OSvOSv is the open source operating system designed for the cloud. MobyMoby defines the future in specialized container systems building. An open framework to assemble specialized container systems without reinventing the wheel. 似乎是更高、更深层定制化容器的工具，示例：LinuxKit 开源项目中几个文件各是什么意思？ Dockerfile 运行时的 docker 镜像生成文件，docker build . 并执行 docker run the-id-build 可尝试。 Capstanfile 是 OSv 的镜像生成文件。 Procfile 是 Heroku 的运行时命令文件。]]></content>
  </entry>
  <entry>
    <title><![CDATA[两个 Lock 文件的迷惑]]></title>
    <url>%2F2018%2F01%2F24%2Ftwo-lock-file-confuse%2F</url>
    <content type="text"><![CDATA[从 npm 5 开始，执行后就多出了一个 package-lock.json 的文件，如果在用 yarn 的话，就会有个疑惑，yarn.lock 和这个 package-lock.json 到底用哪个呢？要不要保存入 git 库呢？ 通过参考这两个链接： Should I commit yarn.lock and package-lock.json files? Idea: support package-lock.json from npm 5 得到信息如下： 都是为了记录准确的版本，使用时最好二选一，开发团队内部协商一致后，把另一种舍弃，即尽量不要用另一种并且在 .gitignore 中忽略掉。 有可能未来 yarn 会支持或兼容 packge-lock.json，等消息吧。]]></content>
      <tags>
        <tag>yarn</tag>
        <tag>npm</tag>
        <tag>package-lock.json</tag>
        <tag>yarn.lock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不沉迷电子游戏的心法]]></title>
    <url>%2F2018%2F01%2F23%2Ffight-with-digital-games%2F</url>
    <content type="text"><![CDATA[前言游戏估计是所有动物的本能吧，至少看上去是人类的本能了，从两三岁的小孩开始，就已经每天都在游戏了，而自从有了电子游戏之后，就出现了一种新的问题：沉迷电子游戏的问题。 个人也是沉迷“患者”，甚至目前也还是，一天的游戏时间加一起估计有5个小时左右，如果是周末不上班，则可能到10多个小时。自我感觉是需要改变了，所以写下这篇文章来反思这个问题。 不过我认为游戏甚至电子游戏本身并不是有百害而无一利的事物，不象吸毒抽烟那样，必须戒掉才好。毕竟游戏中是有其精彩的一面的，也有部分寓教于乐的成份的。所以只要不过度沉迷，实际也无伤大雅。 回到心法的角度来思考，为什么我们喜欢游戏？是因为在游戏中能得到什么吗？想要改变一种习惯或坏毛病，最好是能找到它的思想根源，然后在根源上用一件更好的习惯和事情来替换它。 我们喜欢玩游戏，玩电子游戏，最根本的不是因为喜欢玩电子游戏，电子游戏千千万万，并不是每一款我们都喜欢玩儿，很多时候打开一些不喜欢的电子游戏，我们也是提不起兴趣甚至是感到厌恶的。另一个现象就是，玩儿（沉迷）网络游戏的人远远比玩儿（沉迷）单机游戏的人多得多，甚至可以说几乎很少有人沉迷于某一款单机游戏，原因还是单机游戏本身是电脑 AI 来跟人玩儿，俗话说的就是死的，固定的，刻板的，当然随着人工智能的发展，也许未来的电脑智能也会不断提高，到时应该也许会有沉迷单机游戏的情况发生吧。人们还是更喜欢跟网络上的真人玩家玩儿网络游戏，这就反映了一个非常基本的需求：人与人之间的互动需求，这互动可能是聊天、对战竞技、合作成就等。 说到这里不得不提到几乎全民参与的游戏《王者荣耀》了，这款游戏之所以如此受欢迎，分析其中的根本原因有以下这些： 与玩家对战竞技； 与队友合作配合； 成长路径、随机的奖励反馈； 更好的、更厉害的自己的虚拟投影——英雄系统； 不同个性、不同想象的虚拟形象，给人各种虚拟角色扮演的感觉； 手机操作，随时随地有网即可，零碎时间、无聊时间都可快速启动娱乐状态； 操作简单，上手容易，男女老少皆宜； 有历史传承，从早期的魔兽争霸、三国无双 到 Dota 到英雄联盟，再到手机上的王者荣耀，很多玩家一直追随下来； 英雄人物大众喜闻乐见，这也许也算是另一款腾讯的“全民超神”为什么远不如“王者荣耀”的原因之一吧； 游戏自身功能和体验制作得相当不错，包括还有语音、打字、快捷话语等沟通功能等，加上战队系统，使之不同于一般的游戏仅止于游戏而已，更是包含了一定的社交属性在其中。 这么多的游戏元素集大成者，不火也难，再加上腾讯用户的基数，以及微信时代的传播效应，自然更是火借风势，一发而不可收拾。 个人还喜欢玩儿一些大型的网络游戏，比如刀剑2、龙之谷、暗黑3等，也都是类似的集合了这些元素的电子游戏，说到这儿我们就可以开始分析一下这背后的人的真实需求和沉迷的深层原因了。 首先，人是有社交需求的； 其次，人是有自我实现需求的； 再次，经济规律会促使人们寻找最优性价比的解决方案的；解决以上两大需求，在现实中的成本通常很高，而通过电子游戏互联网，成本变得非常低、非常容易，因此这变成一种不可逆转的大趋势。相应的现象比如： 人们更多地发微信而更少见面； 人们更多地远程开会、协作，而更少出差、实地办公； 人们更多地网上视频，而更少坐长途车来回探亲； 人们更多地网上购物，而更少逛多处商场选购商品； 人们更多地用视频监控，而更少亲自守夜监视等； 但无论怎么说，我们不希望自己沉迷于电子游戏的虚拟世界，我们希望适度地游戏娱乐，安排好生活和工作。所以，我们要找到避免沉迷这些电子游戏的方法。 游戏上瘾的心结现实中没有这么有意思的事儿可以短暂地抛开现实中的烦恼游戏上瘾的人通常在现实中也会同时伴有严重的拖延症，有个说法是说拖延其实不是病，不过拖延本身就是一个很大的话题，有无数的书在说这件事情，个人倒是认为拖延症和游戏上瘾可能有着相同的心理根源，如果找到并解决了，可能两个问题都会被解决。 可以在虚拟的世界中体验自己想体验的过程例如：建造一座城市、成为一个英雄、指挥一个大军。 解决大脑中的各种强迫症例如：把三个或多个连起来并消掉；拼成一排并消掉； 朋友们都在玩儿喜欢玩儿的游戏，主要还是有朋友一起玩儿的才更感觉有趣，再好的游戏，如果没有人一起玩儿，也就失去了大半的乐趣，再无聊的游戏，也许就是因为有朋友一起玩儿也就觉得有趣的。 我也需要娱乐通常都是在工作一天后，就觉得自己也需要找点娱乐的事情，电视、电影什么的偶尔遇到好的看一下，但更多的时候还是觉得玩游戏更有意思。 现实中的事情都很慢很麻烦游戏中只需要点点鼠标、按按键盘，再麻烦的也就是多点点鼠标和多按按键盘，虽然也有一些游戏的技巧，但毕竟游戏是设计出来给人玩儿的，所以肯定适应大多数人的操作和忍耐能力，而现实世界就不一样了，遵循的是现实世界的客观规律，所有事情都需要实事求是，很多真正有成就的事情都需要长期持久的耐心来慢慢实现，不象游戏或影视剧中一转眼十年就过去了…… 游戏的累积是可以看得见的游戏中的各项数据都直观地显示给用户，即时评价给用户，同时大多数数据都是“永久”有效的，不断向上累积的，即使需要长时间积累的成就，也是可以期待的，任何时候上线还可以接续着之前的进度继续向前。 而现实世界则是看不到、摸不着的，没有数据可以直观告诉自己进度，甚至都不清楚会有哪些维度的数据要记录。同时，过程中也是感觉不进则退的，稍有懈怠就会感觉退回了从前，甚至从零开始一般。很多事情都会成为半途而废的失败记忆。 感悟：用一种方式在现实中给人一些数据、进度、里程碑、目标、任务计划等 游戏与现实的逻辑区别时间、金钱、注意力 游戏中，用金钱来购买道具是游戏设计的主要目的之一，所以会尽可能地容易，游戏玩家购买道具通常是为了变得更强、更厉害，通常这些道具要么要耗费大量的时间才有可能得到，或者就是几乎没有几率（运气）得到，所以相当于在游戏中用金钱购买（节省）了自己的时间。 现实中，人们通常用自己的时间来换取金钱，当然为了生存必须如此，更高级的方式是用金钱来购买别人的时间，开成相互的交易。 游戏中，注意力通常是高度集中的，通常会让人专注于某一个任务或一系列具体的目标。 现实中，注意力通常是极其分散的，通常让人不知道要做什么，该做什么才好。 感悟：用一种方式在现实中给人一些具体的大目标、小任务等 大脑优势 游戏中，体现的是人们的小聪明。 现实中，反映的是人们的大智慧。 感悟：用一种方式在现实中创建大项目的概念，让人可以看得更长远，做事更持久。 好运 游戏中，多数时候凭的是运气，玩儿的是概率和赌博。 现实中，更长远地要看人把握运势的眼光，比的是价值分析和持久专注。 成就感成就感其实不是某种实物，不是金钱，甚至不是做成的某件事情，而是一种大脑自己想象出来的东西，可能是某种回忆（例如与队友在大逆风局里顶住压力，运用策略最终翻盘取胜等），某种脑子中的数字（例如游戏中的金子，在游戏中所构建的系统里，不断地玩儿，不断地熟悉，渐渐地就建立起来了某种价值感，于是乎在电脑里的这种小小的数字后面画一个小小的金子的图标就会让你感觉真的很值钱，甚至让你愿意为它而付出不断地努力挣取甚至打架争抢。） 感悟：记大账，可以大体反映出自己或家庭的财务状况即可 初步的解决方案：管理好自己的注意力有个朋友跟我说：你要转移你的注意力，没错，我想这是个办法，人在游戏的时候注意力全在游戏里，如果想控制自己的游戏时间，就需要把自己的注意力转移到别的地方，这样才能离开游戏。他的建议是出去抽根烟，哦，不是，因为我不抽烟，所以他的建议是陪孩子出去玩，去外面转转…… 时间其实是没办法管理的，要想利用好时间，就要管理好自己的注意力，电子游戏虽然不是那么的十恶不郝，但也是要有所控制的，而要有所控制最初步的方式应该就是从转移注意力开始。 可是，我为什么会转移注意力呢？玩游戏之所以有时会失去控制，就是因为不愿意从这其中转移出来，沉迷其中感受特有的乐趣，甚至有时没什么乐趣，也依然好似强迫症一样地不停地做任务、打怪、升级……为什么呢？也许大脑有一种惯性，懒惰的惯性？在一件事情中找到了乐趣，就不停地想重复得到更多类似的乐趣？据说流行音乐也有类似的特性，就是一个旋律再重复一次，再稍加变化重复一次，最后再回归到最初的旋律再重复一次，人就会觉得很好听。 游戏其实可以给我们很多启示，设计游戏的机制，实际是非常讨好大脑的兴奋点的，我们要怎么样在现实中那些积极的事情上，也用心费力实现这些机制，让我们的人生、注意力、时间能更多地关注在这些积极的事情上呢？ 感悟：在软件中加入任务、目标的价值，加入自己的精力值等参数，学习游戏的运行机制。感悟：给想做的事情附加上独特的意义，并且最好有数据可衡量，可以直观地得到大脑中想象的成就感 我们沉迷游戏，最怕的是大脑进入到游戏的世界不能自拔，而玩游戏的最大乐趣恰恰在于进入其中的情境，未来的游戏发展只会更加的吸引人的注意力，更加的身临其境，摆脱沉迷游戏的关键点就是让大脑回到现实世界，思考现实世界的事物，冥想可能是比较有效的一个方法，帮助大脑更好地恢复平静，更好地明确人生的意义，而不再沉溺于游戏世界的愉悦和乐趣。 另外一项就是沉迷于工作，这样就用沉迷于其中一项代替了另一项，用工作代替游戏，这样沉迷工作可以带来更多的收益和成长，同时注意掌握好工作节奏，不至于过份劳累，就是一个可以长期持续的解决方案。]]></content>
      <tags>
        <tag>games</tag>
        <tag>游戏</tag>
        <tag>注意力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018年第一折腾]]></title>
    <url>%2F2018%2F01%2F23%2F2018-first-shot%2F</url>
    <content type="text"><![CDATA[花了两天时间，绕了些弯路，总算把 Blog 搞得差不多满意了，用了 Next! 的主题，用了 hexo 的服务技术。 之前用的 JekyllBootstrap，本来还能凑合用，但是那个项目很长时间都没再维护更新了，仅有的几个主题也看烦了，影响了写博客和记录的心情，中间还转而去用一些笔记工具，用到高级功能又要收费，想来想去自己是搞软件开发的，为什么不再折腾一下呢？ 太长时间没动过 Jekyll 和 Github page 相关的事儿了，导致前期过程做了些尝试和回忆的事情，经过这两天的折腾，明白了 Jekyll 和 Hexo 的工作机制，也算一项收获吧！ 详细的折腾过程就懒得说了，给一些参考链接吧： from jekyll to hexo 将博客从jekyll迁移到了hexo Jekyll uses the Liquid template Elegant Theme for Hexo Hexo 指令 hexo常用命令笔记]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wind13 的 Blog 之 原来的首页]]></title>
    <url>%2F2017%2F12%2F31%2Findex%2F</url>
    <content type="text"><![CDATA[学用Play!和Scala做软件本站收集Play1.x相关 停止SSH，用Play!吧 Play!技巧问答 国内一些使用Play!框架的网站 Xml 域名空间识别问题 Playing Play!系列之一：Play框架的暴力美学 Playing Play!系列之二：再见Servlet，Play框架的启动 Playing Play!系列之三：不必Servlet3，Play框架的异步请求处理之道 playframework 学习实践(一) – Play框架概述 playframework 学习实践(二) – 搭建play开发环境 playframework 学习实践(三) – Hello World , play! playframework 学习实践(四) – 配置你喜欢的IDE Play framework 技巧记录 Play framework 技巧记录 二 软件开发相关 编程知识链接收集 编程自学之路（个人建议供参考） 其他相关技术管理相关知识管理从思想上来说是哲学的，从理论上来说是科学的，从操作上来说是艺术的。——余世维 Toc术语 如何制定和落实一项有效的改善方案？ 罗辑思维听后记录 用了半天OKR，结果还是KPI？二者区别看这里 常用在线工具 正则表达式测试 代码对比/归并 JS代码压缩 BASE64编码解码 CSV转HTML表格 JSON代码格式化 JS代码格式化 相关的网站 Playframework官方网站简洁明快，特别适合开发Web应用软件，1.2.5版本实践中… Spray官方网站一套值得关注的基于Scala和Akka的轻量REST/HTTP解决方案。 中国Play官方社区 关于Play2的一个非常好的入门教程 Scala语言，结合面向对象与函数式编程，更好地加强了软件的可扩展性，学习中…… Scala指南 Play!2.0官方文档，在github开源。 国内中文文档翻译，Play!文档中文化QQ群：168013302，在兴趣的可以帮忙翻译 在github上的项目网址 一个非常简单的内嵌CMS模块（play-cms module） 生活智慧有趣经典收集 关于本站的一些说明一切才刚刚开始，希望大家多支持…… 如果您需要信息化方面一些好的解决方案， 请给我发邮件：wind13 AT 163 DOT com！ 当然，你也可以说点别的…… 环境保护，只要你是人类，就应该反思！从节约资源开始吧！志同道合（做个环保主义的程序员）的技术博客：酷壳CoolShell]]></content>
      <categories>
        <category>Pages</category>
      </categories>
      <tags>
        <tag>wind13</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Playframework 1.4.x 与Playframework 2.5.x 选型比较]]></title>
    <url>%2F2017%2F02%2F23%2Fplay2x-compare-play1x%2F</url>
    <content type="text"><![CDATA[Playframework 1.4.x 与Playframework 2.5.x 选型比较Playframework 2.5.x优势： 文档齐全，持续更新； 支持更多最新的技术，更清晰的底层技术； 完全异步的HTTP编程模型； 通过 Comet, long-polling and WebSockets 给客户端提供持续的连接； 通过 Akka 的 Actor 模型提供响应高并发的系统； 使用 Akka Streams Filters Streaming response bodies Request body parsers WebSockets Streaming WS client responses 使用 Websocket 使用 Ebean 或 JPA 和 Anorm（用于Scala）作为数据层，Java 建议用 Ebean， Ebean 可以很容易跟 ElasticSearch 结合做全文检索相关功能。 Ebean 服务端分页极为容易。 使用 Comet sockets 使用更强大的 The Twirl template engine，即 Scala 的界面模板， 模板是要编译的，编译前更早报错，报错更准确。 语法简洁，只有一个“@”特殊字符，借助强大的 Scala 语言功能更强大。 函数式编程的语法和表达式非常适合模板引擎。 路由系统 routing system 也是编译的，帮助提早发现错误。 强大而易用的自动化测试系统。 采用 sbt 作为集成编译工具，可以很好地与 Maven 等传统工具结合，这样也就可以很好地和已有系统集成。 有很多的实际示例代码和模组 Module 可用，如下： swagger-play PDF module Geolocation 很多方面都有针对性的优雅解决方案，如： CSRF JSON 转换 Play 2 使用的是 Jackson 而不是 google 的那个 gson。 Database Evolutions Deploy 部署 dist 命令很强大，直接打个zip包，解压后，运行 bin 目录下的 run 命令就可以启动服务了。甚至可以打成各个系统 Native 的安装包，如 *.msi (Windows), *.apk (macOS), *.rpm (Linux) 等 劣势： 深入的功能，特别是 Akka 有一定的学习曲线。 Java 和 Scala 有界线，有两套API，不能自然转换，未来要用 Scala 则可能需要重写。 Playframework 1.4.x优势： 有之前的项目经验，熟悉度高； 满足基本的项目需求，实现一般的（传统的）信息系统没有问题； 可用之前的项目快速起步，包括与 Swagger 等的结合，部署脚本文件等。 劣势： 动态语言的 Groovy 界面模板，非编译型语言，仅在运行时才能知道错误，不易排查错误原因，解释型运行效率低。 太多黑科技，“不正规”地使用“正规”的 Java 技术，可能导致一些很难解决的Bug，包括与第三方 jar 包的兼容问题等。 项目采用 python 做为编译等工作的工具，不易自定义和集成已有系统。 结论：越看越觉得应该直接开始使用 Play 2.5.x ，没什么可担心的，只会更好，不会入坑！ 一般的应用，Play 2.5.x 与 Play 1.4.x 上手难度相当，甚至在测试、Form表单、Model层（Ebean）等方面 Play 2.5.x 更有优势，有更多更专业且现成的解决方案。 深层次的功能和配置等，更是Play2有所涉及（但需一定的学习曲线去掌握），而Play1就没有相关资料，只能借助第三方类库解决了，但跟Play1的结合又只能通过写它的Module来实现，麻烦情况可见一般。]]></content>
      <categories>
        <category>play2x</category>
      </categories>
      <tags>
        <tag>playframework</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F02%2F05%2Ftech-select%2F</url>
    <content type="text"><![CDATA[技术选型之我见 layout: postcategories : manage agiletitle: 技术选型之我见tagline: “Architect select”tags : [architect]lang: zh 技术选型是各个技术团队架构师所面临的挑战之一，也是重要的决策之一，关系到团队技术发展的大方向，甚至决定着项目未来生存的生命力和寿命长短。 然而要做好这件选型的决策却是不那么简单，同时也没有什么特定的标准。 个人所见： 首先，要见多识广；既然是说选型，那就要有所选择，也就是说要能够博览众长，知道相关领域各式各样的技术方向，多看一些严谨的介绍文章和比较文章，做一些重点的笔记，毕竟精力是有限的，所以不可能每一个技术方向都深入研究，最终通常也只能选择三种左右来进行体验和原型测试等。平时要多看新技术社区的文章，顺藤摸瓜地去发现新的技术动向，看它们的官网，看官方文档（英文阅读是基本功），看Demo等，不要迷信商业解决方案，更多地相信开源社区的力量，关注人气较高的开源社区，注意看有些开源项目有可能维护较少或者bug较多（查看Issue列表页），那就不能轻易使用。 其次，要实事求是；最后，要勇于冒险；]]></content>
  </entry>
  <entry>
    <title><![CDATA[DB, SQL 技术相关]]></title>
    <url>%2F2016%2F12%2F18%2Fdb-collection%2F</url>
    <content type="text"><![CDATA[DB, SQL 技术相关Presto（中文站）是一个运行在多台服务器上的分布式系统。]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>DB</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DevOps技术相关]]></title>
    <url>%2F2016%2F12%2F18%2Fdevops-collection%2F</url>
    <content type="text"><![CDATA[DevOps技术相关相关链接 Ansible中文权威指南 所有重复的IT工作可以被自动化并分享给其他组员。 Choosing a deployment tool - ansible vs puppet vs chef vs salt 相关观点 Puppet is a similar tool to Chef Vagrant is a tool for developers and a toy for admins, you can quickly stand up a development environment with vagrant, e.g. I want to develop an android app, grab an IDE from vagrant, I think it will be overtaken by Docker soon. 我现在使用的是阿里容器服务: https://cs.console.aliyun.com ，配合阿里的虚拟主机以及代码托管(code.aliyun.com)，实在不能再方便。 创业圈的docker服务，我比较推荐http://daocloud.io，很久以前我还去他们家上海总部做过使用开发demo，这是一家很有工程师文化的企业，而且里面确实有好几个国内docker界顶级玩家。 假如你用的是VPS或者AWS什么的 首选Rex http://rexify.org/ 次选Ansible http://ansible.cc/ Docker &gt; Vagrant那针对国内可以流畅使用docker但无法正常使用vagrant的情况，作如何处理呢？ 我们团队的解决方案是将服务器部署的docker编排脚本(docker-compose)直接修改参数以适应Local开发。每次开发前，docker-compose up -d，再配以各类脚本。结果是，这样开发起来比在硅谷用Vagrant还要爽！！Vagrant所有的操作都可以用在docker中一样做，例如:复制文件: vagrant scp; docker cpssh: vagrant ssh; docker-compose exec CONTAINER /bin/sh所以，到最后，我们发现，开发部署都用docker还有一个额外好处，vagrant的开发环境到部署环境还是存在差异的，而我们开发用的起docker集群的编排脚本无需经过调试直接复制到服务器端就能一行命令解决部署:docker-compose up -d What you developed is what will be deployed. 谢谢! 作者：大杰哥链接：https://www.zhihu.com/question/32324376/answer/123239426来源：知乎著作权归作者所有，转载请联系作者获得授权。]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ionic 2 相关学习]]></title>
    <url>%2F2016%2F11%2F08%2Flearn-ionic-v2%2F</url>
    <content type="text"><![CDATA[基础 ionic2文档整理 A Guide to Styling an Ionic 2 Application Tips &amp; Tricks for Styling Ionic 2 Applications User-Selected Style Themes in an Ionic 2 Application Vonic简明教程（一）：起步{:target=”_blank”} SQLite plugin{:target=”_blank”} Cordova plugin NativeStorage{:target=”_blank”} Debugging Ionic 2 Apps in Chrome from Visual Studio Code{:target=”_blank”} Ionic 2 Conference Application{:target=”_blank”} Ionically Speaking{:target=”_blank”} 问题 I18n 官方文档如此{:target=”_blank”}，使用ng2-translate{:target=”_blank”}库实现。 Angular2 debug tool: Augury{:target=”_blank”} Form validation is not working with Angular 2 FormBuilder in Ionic 2{:target=”_blank”} Checkbox Group handling and Validation in Angular2{:target=”_blank”} ionic2+angular2中踩的那些坑{:target=”_blank”} (Ionic 2) Getting data from php services is undefined 解决 ionic 中的 CORS（跨域） 问题{:target=”_blank”} 跨域资源共享 CORS 详解 报以下错误，是因为 providers 填错了，应该只填 Service： 1234567891011metadata_resolver.js:499 Uncaught Error: Can&apos;t resolve all parameters for Project: (?, ?). at CompileMetadataResolver.getDependenciesMetadata (http://localhost:8100/build/main.js:23905:19) at CompileMetadataResolver.getTypeMetadata (http://localhost:8100/build/main.js:23806:26) at http://localhost:8100/build/main.js:23949:41 at Array.forEach (native) at CompileMetadataResolver.getProvidersMetadata (http://localhost:8100/build/main.js:23929:19) at CompileMetadataResolver.getDirectiveMetadata (http://localhost:8100/build/main.js:23569:34) at http://localhost:8100/build/main.js:23674:49 at Array.forEach (native) at CompileMetadataResolver.getNgModuleMetadata (http://localhost:8100/build/main.js:23668:49) at RuntimeCompiler._compileComponents (http://localhost:8100/build/main.js:39512:47) 如，将： 12345@Component(&#123; selector: 'page-prj-detail', templateUrl: 'prj-detail.html', providers: [Project]&#125; 改为： 12345@Component(&#123; selector: 'page-prj-detail', templateUrl: 'prj-detail.html', providers: [ProjectService]&#125; 遇到这个错误，可能是html界面的方法与ts中的方法对不上。 1234567891011polyfills.js:3 Uncaught TypeError: exceptionHandler.handleError is not a functionat Object.next (http://localhost:8100/build/main.js:26130:82) at SafeSubscriber.schedulerFn [as _next] (http://localhost:8100/build/main.js:27643:52) at SafeSubscriber.__tryOrUnsub (http://localhost:8100/build/main.js:9761:16) at SafeSubscriber.next (http://localhost:8100/build/main.js:9710:22) at Subscriber._next (http://localhost:8100/build/main.js:9663:26) at Subscriber.next (http://localhost:8100/build/main.js:9627:18) at EventEmitter.Subject.next (http://localhost:8100/build/main.js:11949:25) at EventEmitter.emit (http://localhost:8100/build/main.js:27635:76) at NgZone.triggerError (http://localhost:8100/build/main.js:28451:76) at Object.onHandleError (http://localhost:8100/build/main.js:28430:23) 编译时遇到这个错误： 12345[23:13:04] Error: Error at [project path]/.tmp/pages/statis/projects.ngfactory.ts:351:29[23:13:04] Supplied parameters do not match any signature of call target.[23:13:04] ngc failed[23:13:04] ionic-app-script task: &quot;build&quot;[23:13:04] Error: Error 一般说明在程序的某处有个方法需求的参数与提供的参数对应不上，在build时无法通过，但在ionic serve时可正常运行，这个错误就比较难找了。这里注意看错误提示，说的是 1.tmp/pages/statis/projects.ngfactory.ts 那么就去检查 /pages/statis/projects.ts 文件中的相应方法的参数吧！ 编译时遇到这个错误： 12345 FAILURE: Build failed with an exception.* What went wrong:Execution failed for task &apos;:packageDebug&apos;.&gt; java.io.FileNotFoundException: /Users/samliu/gits/jing-xi-h5/platforms/android/build/intermediates/assets/debug/www/assets/stub (Is a directory) 这个错误原因不明，但通常再次编译运行就好了。 调试时遇到这个错误： 12Application ErrorThere was a network error (http://192.168.56.1) 网上查到答案是要添加whitelist的插件{:target=”_blank”}，然后添加相应的网址到config.xml中。 发现这个错误，一般是 queries.sql 里面的SQL写错了。 1ERROR Can not issue data manipulation statements with executeQuery() 原因是修改性的SQL语句，上面的声明要用“!”，而不能用“?”。 遇到这个错： 123 Can&apos;t bind to &apos;ngShow&apos; since it isn&apos;t a known property of &apos;ion-list&apos;.1. If &apos;ion-list&apos; is an Angular component and it has &apos;ngShow&apos; input, then verify that it is part of this module.2. If &apos;ion-list&apos; is a Web Component then add &quot;CUSTOM_ELEMENTS_SCHEMA&quot; to the &apos;@NgModule.schemas&apos; of this component to suppress this message. 应该是说 ngShow 并不支持这样的写法，后改为 *ngIf即可。 遇到这个错：Can’t coerce body of type class java.lang.Integer 是因为返回的数据不是json，比如直接将db操作的update结果1返回给客户端，这里(ok 1)就会报这个错，改为：(ok {:success 1}) 即可。 遇到这个错：Unable to find localabstract name of cordova app 参考此回复 1vim .vscode/extensions/vsmobile.cordova-tools-1.2.4/out/src/debugger/cordovaDebugAdapter.js 在 254 行，修改为 1234// if (socketsInodes.indexOf(parseInt(fields[6], 10)) === -1) &#123;if (pathField.indexOf(pid) === -1) &#123; continue;&#125;]]></content>
      <categories>
        <category>devtech/js</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angular 2 相关学习]]></title>
    <url>%2F2016%2F11%2F08%2Flearn-angular-v2%2F</url>
    <content type="text"><![CDATA[基础 I18n 官方文档如此{:target=”_blank”}，目前的解决方案似乎很麻烦。 Angular 2 Components: Inputs and Outputs{:target=”_blank”} The impure AsyncPipe{:target=”_blank”} Angular2 管道（pipes）{:target=”_blank”} [Angular 2] Build a select dropdown with *ngFor in Angular 2{:target=”_blank”} JavaScript Array Methods Reference{:target=”_blank”} JavaScript Modules: A Beginner’s Guide{:target=”_blank”} 问题]]></content>
      <categories>
        <category>devtech/js</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李笑来《把时间当朋友》笔记]]></title>
    <url>%2F2016%2F10%2F08%2Ftime-friend-lixiaolai%2F</url>
    <content type="text"><![CDATA[什么是心智一个人的心智，就是其过往获得的一切知识及经验的总和，包括基于这些知识和经验造就的思考方法、思考模式。]]></content>
      <categories>
        <category>manage</category>
      </categories>
      <tags>
        <tag>李笑来</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序相关学习]]></title>
    <url>%2F2016%2F09%2F24%2Fweixin-xiao-cheng-xu%2F</url>
    <content type="text"><![CDATA[收集链接 微信小应用资源汇总整理 WePY 让小程序支持组件化开发的框架 Github 微信小程序wepy框架开发资源汇总 开发微信小程序入门前 微信小程序设计指南 CSS参考手册 首个微信小程序开发教程！ 微信小程序简易教程 微信web开发者工具 微信小程序分享1：开发环境的配置 wechat-weapp-gank 一个图片App示例 wxapp-cli: 一个简单的微信小程序的小（jiao）手架 通过微信小程序看前端 微信小程序中使用lodash 微信小程序 | 47，下载文件与保存文件 小程序测试方案初探 知识点 rpx 是微信定义的像素单位，动态布局标量。 执行顺序： App Launch–&gt;App Show–&gt;onLoad–&gt;onShow–&gt;onReady。 App.onLaunch App.onShow index.onLoad（首次） index.onShow（由App.onShow驱动） index.onReady（我准备好互动了，可以操作了） 进入后台时： app.onHide index.onHide 恢复前台显示时： app.onShow index.onShow 破解方法 （测试发现有问题，不能用。） 遇到的问题 加载 util.js 在开发工具中可以正常执行，但在真机上会出现无数据白屏。 怀疑问题是 exports 的方法不规范，参考：微信小程序中module.exports和exports的区别 最终找到原因：千万别用 console.assert 方法]]></content>
      <categories>
        <category>devtech/js</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[4clojure problem solving]]></title>
    <url>%2F2016%2F09%2F20%2F4clojure-problem-solving%2F</url>
    <content type="text"><![CDATA[14 题以前答案一般没啥区别，略过…… #151#(* % 2) adereth’s solution: 1* 2 #161format "Hello, %s!" adereth’s solution: 1#(str "Hello, " % "!") #171'(6 7 8) adereth’s solution: 1[6 7 8] #181'(6 7) adereth’s solution: 1'(6 7) #191#(peek (vec %)) adereth’s solution: 1(comp first reverse) #201#(nth (reverse %) 1) adereth’s solution: 1(comp second reverse) #211234(fn getn [ary n] (if (= n 0) (first ary) (getn (rest ary) (dec n)))) adereth’s solution: 1#(first (drop %2 %1)) #221#(reduce (fn [a b] (inc a)) 0 %) adereth’s solution: 1(fn [sequence] (reduce (fn [acc v] (inc acc)) 0 sequence)) #231#(reduce (fn [rs ls] (cons ls rs)) [] %) adereth’s solution: 123456(fn [s] (loop [result [] s s] (if (seq s) (recur (concat [(first s)] result) (rest s)) result))) #241#(reduce + %) adereth’s solution: 1apply + #251#(filter odd? %) adereth’s solution: 1filter odd? #2612#(take % ((fn fib [a b] (lazy-seq (cons a (fib b (+ b a))))) 1 1)) adereth’s solution: 12345#(take % (map first (iterate (fn [[i1 i2]] [i2 (+ i1 i2)]) [1 1]))) #291#(clojure.string/replace % #"[^A-Z]" "") adereth’s solution: 1(fn [s] (reduce str (filter #(Character/isUpperCase %) s))) #271#(= (reverse %) (seq %)) #28123456789(defn cci [ls r] (if (every? sequential? ls) (concat r ls) (apply cci r (partition-by sequential? ls))))#(let [f (first %)] (if (sequential? f) ) conj [] (first %)) #301234567#((fn dis [ss l r] (if-let [f (first ss)] (let [rss (rest ss)] (if (= l f) (dis rss f r) (dis rss f (conj r f)))) r)) % nil []) 123456#((fn dis [ss l r] (let [[f &amp; s] ss] (cond (nil? f) r (= l f) (dis s f r) :else (dis s f (conj r f))))) % nil []) adereth’s solution: 1#(map first (partition-by identity %)) #321#(mapcat (fn [s] [s s]) %) #341234#((fn rng [s n r] (if (&lt; s n) (rng (inc s) n (conj r s)) r)) %1 %2 []) adereth’s solution: 1234(fn [start end] (take-while #(&lt; % end) (iterate inc start) ) ) #3517 #371"ABC" #381(fn [&amp; s] (reduce (fn mx [a b] (if (&gt; a b) a b)) s)) adereth’s solution: 12(fn [ &amp; xs ] (reduce #(if (&gt; %1 %2) %1 %2) xs)) #391234(fn l [a b &amp; r] (if (or (nil? (first a)) (nil? (first b))) (flatten r) (l (rest a) (rest b) (conj (vec r) (first a) (first b))))) adereth’s solution: 12(fn [s1 s2] (flatten (map list s1 s2))) #401(fn [x ys] (butlast (flatten (map #(list % x) ys)))) adereth’s solution: 1#(butlast (interleave %2 (repeat %1))) #4112(fn [ls n] (keep-indexed #(if (&gt; (mod (inc %1) n) 0) %2) ls)) adereth’s solution: 1234(fn [coll n] (-&gt;&gt; (partition-all n coll) (map (partial take (dec n))) (flatten))) #4212#((fn factorial [n r] (if (= n 1) r (factorial (dec n) (* n r)))) % 1) adereth’s solution: 1#(reduce * (range 1 (inc %))) #4816 #521[c e] #571'(5 4 3 2 1) #621(fn fb ([f b] (lazy-seq (cons b (fb f (f b)))))) aceeca1’s solution: 1(fn [f x] (reductions #(%2 %1) x (repeat f))) 注：从中学习和理解到： fn 给命名 name? 后也可以递归； lazy-seq 适合做无限循环递归的懒序列； reductions 可以将一个数组通过某个方法做 reduce 结果为一个懒序列； #641+ #6612345678910(fn [a b] (let [m (min a b) d (fn [a b m] (and (= 0 (mod a m)) (= 0 (mod b m)))) r (fn o [a b m] (if (d a b m) m (o a b (dec m))))] (r a b m))) astangl’s solution: 12345(fn [x y] (if (= 0 y) x (recur y (mod x y)))) 注：从中学习和理解到： recur 可以递归 fn 这样的匿名函数； (mod x y) 当 x &lt; y 时，返回 x ，也就是说 x/y 得 0 余 x； 最大公约数 w 一定也可以除尽 (mod x y) 的余数； #681'(7 6 5 4 3) adereth’s solution: 1[7 6 5 4 3] #711last #721apply + adereth’s solution: 1#(reduce + %) #811(fn [a b] (reduce #(if (contains? a %2) (conj %1 %2) %1) #&#123;&#125; b)) aceeca1’s solution: 1(comp set filter) 学到的经验：#{} set 是可以当做 contains 方法来 filter 的。 #991(fn [a b] (map #(Integer/parseInt(str %)) (str (* a b)))) aceeca1’s solution: 1(comp (partial map #(- (int %) 48)) str *) 学到的经验：可以组合几个方法，或者用 -&gt;&gt; 语法串联方法 #99#1071(fn [n] #(reduce * (repeat n %))) #1341#(= nil (get %2 %1 0)) adereth’s solution: 1#(nil? (get %2 % true)) #1451[1 5 9 13 17 21 25 29 33 37] #1561#(apply merge (map (fn [k] &#123;k %1&#125;) %2)) 1#(apply array-map (mapcat (fn [k] [k %1]) %2)) adereth’s solution: 1(fn [default values] (reduce #(assoc %1 %2 default) &#123;&#125; values)) #1611#&#123;1 2&#125; #16211 Another solutionSolutions to 4Clojure Easy Problems #1071(fn [n] #(reduce * (repeat n %))) #1341#(= nil (get %2 %1 0)) adereth’s solution: 1#(nil? (get %2 % true)) #1451[1 5 9 13 17 21 25 29 33 37] #1561#(apply merge (map (fn [k] &#123;k %1&#125;) %2)) 1#(apply array-map (mapcat (fn [k] [k %1]) %2)) adereth’s solution: 1(fn [default values] (reduce #(assoc %1 %2 default) &#123;&#125; values)) #1611#&#123;1 2&#125; #16211 Another solutionSolutions to 4Clojure Easy Problems]]></content>
      <categories>
        <category>devtech/clojure</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《清晰思考的艺术》读书笔记]]></title>
    <url>%2F2016%2F09%2F20%2Fthe-art-of-clear-thinking-note%2F</url>
    <content type="text"><![CDATA[幸存偏误只（看到、统计）（幸存的、媒体报道的、成功的）（案例、公司、明星）等，而得到错误的结论。 如：股票指数不能代表一个国家的经济。如：畅销图书和成功教练都值得怀疑。 游泳选手身材错觉在游泳选手和化妆品模特那里，美丽是一种选择标准，而不是结果。 远离成功自助图书，因为写这些书的人都天生具有快乐倾向。 过度自信效应]]></content>
      <categories>
        <category>manage</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《智能时代》读书笔记]]></title>
    <url>%2F2016%2F09%2F18%2Fdata-time%2F</url>
    <content type="text"><![CDATA[第一章 数据——人类建造文明的基石使用数据的标准流程： 获取数据 分析数据 建立模型 预测未知 完美的镜头里面的透镜其实不应该是球面镜，而应该是某种复杂的曲面，这样才能使画面不变形，但这样的镜头在设计和制作上要求非常复杂而难以实现，相反如同日本的镜头生产一样，采用多个球面透镜来组合虽然显得笨重，但是容易大规模生产，成本也非常低，因此二战后，日本超过德国成为全球光学仪器（包括相机）第一大制造国。 启发： 由简单模型组合而成复杂功能的模型； 可由若干个简单模型逐渐契合数据（Fit Data）的方法称为数据驱动方法。 大数据的三个特征： 数据量大 多维度 完备性 熵： 混乱度，越混乱熵越大。 如恒温的空气状态。]]></content>
      <categories>
        <category>manage</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用系统来工作》部分摘抄]]></title>
    <url>%2F2016%2F09%2F18%2Fsystem-working%2F</url>
    <content type="text"><![CDATA[自立和富足出现在系统建立起来之后。 你只要暂时把部分时间和精力，投入到有步骤的、一次性的建立过程中，就可以得到长久的自由、富足和宁静。 第一步是开窍，体验一种觉醒，让你时刻留意人生的各个独立系统。 一下子理顺人生的零乱杂合状态是不可能的；它无法从整体上治理。整治任何复杂事物都需要一次一个步骤、一次一个部件地进行——绝非是整体做法。 运作三步曲： 系统的拆分、剖析和修复：充分揭示、分析，进而完善工作、个人和人际关系各系统；创建新系统，消除那些阻碍你的旧系统。 文件编制：撰写目标、原则和程序，为你和同事确立行动和决策指导方针。这不是为了让你感觉良好，而是创造效率必须做的。这是一次性重任，但不会花太长时间。如果你有一个团队或部门，你要教他们去做。 后续的系统维护。给齿轮上油。这很容易。用系统来工作的效果实际而具体，激励人心。你会愉快地监督你的系统，以使其保持高效运转。 一些概念： 生意：一个人不必到岗就能赚钱。 工作或职业：一个人必须到岗才能赚钱。 项目工程师：生意人或经理的角色，扮演外在系统改进者，而不是内部工作者。 旁人：在生意人或经理的监督下工作的人。 我的世界观一直是错的。我不应该企图通过抱怨来改变世界。我能控制的事情微乎其微，所以我要停止为那些力所不及的事情烦恼。 我下定决心，只在自己能控制的具体事务上花精力，逐步改善我自己和两个依靠我的人的生活。 没错，专注的工作、优秀的员工、有针对性的营销和一贯高质量的产品都至关重要，但这些不是好转的原因，而是原因的副产物。好转的原因是对原则的发现和应用；领导者必须着眼于改进流程，而非具体执行任务或应急救火。优质产品或服务、稳定的员工队伍和盈利能力，是高质量系统的产物，而不是产生高质量的原因。 幸福的人和不幸福的人之间有一个非常简单的区别，不幸的人掌控不了自己的人生，只能整天应付不受管理、或管理不善的系统随机产生的坏结果；幸福的人掌控自己的人生，每天都在享受管理良好的系统必然产生的好结果。]]></content>
      <categories>
        <category>manage</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程初学者的捷径]]></title>
    <url>%2F2016%2F09%2F16%2Fshortcut-for-programming-beginners%2F</url>
    <content type="text"><![CDATA[注：本文将不断更新或添加链接 有没有捷径？一听到“捷径”这个词，很多人就会感觉是个负面的意思，人不应该走捷径，而应该踏实努力、步步为营。所以，这里我们要先讨论一下这个问题：有没有捷径？ 既然题目取了“编程初学者的捷径”，当然就是说有捷径的，为什么说有？是因为事物发展的基本规律如此，一代人比一代人更进一步，就好像这个时代的人不用特别有学问也会知道很多上个时代的人曾经不知道的事物，这一代人不用再经历“大哥大”的模拟式蜂窝电话，就可以直接用上智能手机了，熟练使用最先进的智能手机，也不用知道手机内部的结构和软件逻辑，这其实就是一种捷径，前人所走过的弯路，前人所趟过的深坑都可以跳过了。人类的认知本来也就是在前人的巨人肩膀上不断叠加起来的，编程的学习路径为什么不可以走走捷径（新的快捷路径）呢？ 从哪里开始？有人问我：“你那么多的新技术是从哪里学的呢？”，我笑笑回答说：“互联网啊！？各个技术的官网就摆在那儿啊？”，当然，自己一个人啃英文官网对大多数人来说还是很费劲的。 其实，我们学任何东西应该从哪里开始呢？现在各种学习资料、网络信息极大地丰富，大部分的知识根本不愁找不到合适的资料来源，那么为什么有些人进步神速，而有些人却停步不前呢？我个人分析主要是：动力源泉、方法技巧和实践应用这几个方面的差别造成的。 动力源泉“兴趣是最好的老师”这句话实实在在地道出了学习这件事的根本的根本。除了兴趣之外还有可能有其他一些动力来源，比如：升职压力、经济利益等，但要说持久的动力源泉，应该还是个人的兴趣爱好了。 首先是坚定的信念想学编程的初学者，最重要的是坚定的信念，不怕学得慢，不怕学不会，就怕中途放弃，不学了谁也没办法。 为什么选择学编程？世界上那么多的学问，每个人的精力和时间都是有限的，那么选择编程到底对不对？好不好？这个信念可以不可持久坚持下去呢？ 编程这门学问，实际上是人类智慧发展到今天最璀璨的明珠之一，其重要性不用多说，这个时代的很多伟大工程都离不开这门学问，随着互联网、移动互联网与各个行业的不断深入结合，编程已经是现代乃至未来时代所不可获缺的一个部分。 人类自有语言和文字以后，各方面科技发展突飞猛进，得益于人类使用语言互相交流沟通，语言打通了人与人之间的思维联系，从而能够集合很多人的共同智慧来达成伟大的成就。而新时代的来临，人类开始利用机器、电脑来达成新的成就，而人与机器、电脑沟通的语言就是编程语言，这也将是一个全新的精彩的世界，等待人类不断探索和发现。 人类发明的编程语言，比自然形成的语言更为严谨，更为科学，组合了人类逻辑、数学、机器等多方面的学识，结合机器和电脑的功能，可以解决很多的问题，完成很多的工作等。 暂且不说目前互联网以及移动互联网的火热，也不看软件开发人才的抢手和热门，只因编程本身就是一个很有意思、很有趣的学问，同时也可以和其他行业的学问有机地结合起来，不影响自己对其他方面知识的探索，反而会是很有效的工具，帮助你轻松跨界高速发展！ 其次是正确的路径正确的路径就是说方法，其实也就是咱们说的“捷径”，少走弯路，少填坑，人的精力有限，时间宝贵，注意力珍惜，必须选择正确的方法和路径。 边用边学就是最佳路径；iPad拿在一个小孩子手中，你仔细观察，几乎没有人教他们，他们就会很快熟悉这里面的界面、功能，很快就能用iPad做很多事情，拍照片、画画涂鸦、玩游戏、看视频等。 大多数时候，我们总是先会用某件东西，之后再了解其中的原理，进而深入研究它的内部机制等，这是符合事物的熟悉规律的，所以这里所说的“捷径”自然不会搞反人类的学院式教学，先讲计算机原理、数据结构什么的了，第一步自然是不管三七二十一，先用起来再说。 第一步的第一步，当然是要有一台电脑，这里说的自然不是一般的电脑，为了学编程，为了走捷径地学编程，自然要选择一台学编程最捷径的电脑，那就是苹果笔记本，钱少的可以买Macbook Air，钱多的自然可以Macbook Pro，选择尺寸自然也是13寸或15寸，根据自己的经济水平和个人喜好了，追求性能自然15寸，还想兼顾便携性那就13寸，如果不考虑钱的问题，个人推荐15寸MBP（Macbook Pro)，那屏幕看起来才舒服，个头稍大点，重量稍重点都不是事儿，年轻人背个电脑包到处跑跑是没啥问题的。除了笔记本，当然iMac或Mac mini也都是可以选择的，总之是要用苹果系统来学编程就最快捷了。 接下来，苹果电脑的一般性使用，网上大把的教程和技巧，大家可以各自找来看看，悟性好的话基本都不是什么问题。 进入正题，开始用程序，如何开始呢？REPL应该是最好的开始，编程世界的即时响应，所见即所得嘛！ 参考 Homebrew总结 1brew install boot-clj 用上面这个命令安装 boot 这个命令工具。然后有了boot就可以运行下面这个命令： 1boot repl 得到一个REPL的环境，你就可以开始练习简单的编程了： 1(* 8 9) 这个就可以得到 72，你看你现在拥有了一个计算器了！ 再试试更复杂的四则运算吧： 1(* (+ 6 2) (- 9 2) (- 7 3)) 这个就是：(* 8 7 4)，得到224。 接下来可以来这里注册个账号然后做些题，边做题练习，边在REPL里面测试。 英语看不懂，怎么办？安装个有道词典，边查边学，硬着头皮查着看，慢慢就明白了，最好再用标准的伦敦腔读出来英语学得更快。 我自己做的答案在这里供参考。 我终于弄懂了各种前端build工具{:target=”_blank”} 基本功也很重要；基本功就象武侠小说里比喻的“内功心法”一般，是决定你能达到多高，以及走到多远的根基，类似“悟性”的东西，说某个人对编程这门学问比较有悟性，也可能就是在这些基本功方面有所特长，自然会在很多地方显现出他与别人的区别。 开悟、开窍也就有点这里所说的“捷径”的意思，所以，如果一个人的基本功比较扎实，那自然走上“捷径”的过程就比较容易，相反，就感觉非常困难了。 第一、英语第二、数学道理基本是说：你数学初中水平也可以学，但想成为编程高手，就不容易了。 就象是你内功只有二级水平（初中水平），学些普通武功是没问题的，但要学高级武功，就要内功到八、九级或十级（大学以上、专家水平）才厉害~ 内功就象是数学水平，而武功就象是编程水平。 第三、观察力第四、思考力（分析力）系统的图画不断显现；面临无数的选择，学会选择最佳方案、实践、工具等很重要。 成为一个高手刻意练习 套路 永远做有挑战的事 脑中存储最新的技术架构 提高自己的认知水平 最后就是实践，学以致用了！只学不用岂不是浪费？我们也不能仅仅是为学而学，何况上一节也提到边学边用才是最佳路径。 找准自己的发展方向；不断深入，不断登高；完成伟大的成就吧！战略的定义： 事后总结出来的好运气 有选择的放弃]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>初学者</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 Code review 的思考]]></title>
    <url>%2F2016%2F09%2F10%2Fcode-review-thinking%2F</url>
    <content type="text"><![CDATA[今天看了陈皓的《从Code Review 谈如何做技术》一文，笔记一些有启发的重点如下： 首先要清晰思考很多时候，人思考问题不清楚，很大一部分原因是因为把很多问题混为一谈。 Code Review 的好处：主要是让代码可以更好地组织起来，更易读，有更高的维护性，同时可以达到知识共享，找到bug只是其中的副产品。 代码的质量级别： 可编译 可运行 可测试 可读 可维护 可重用 通过自动化测试可达到第3级； 通过 Code Review 至少会在第4级甚至更高 Code Review 做不起来，没效果的问题和原因如下： 人员能力不足；即不知道什么是好代码，什么是不好的代码。 结果更重要；不关注质量、成长，急功近利。 人员的态度问题；完事交差心态，自扫门前雪心态。 需求变化问题；代码生命同期短就算了（如一次性Demo等，而现实中这样的项目其实不多），正常的项目如果需求变化快，代码质量要求反而更高，要能不断适应快速变化的需求。 时间不够；这是需求管理和项目管理不善的问题，需另外解决，思路如下： 梳理需求，分析清楚哪些该做，哪些不该做； 拿到需求后问几个问题：为什么要做？业务影响度有多大？有多少用户受益？回答不清这些问题，没有数据支持就不做。 产品经理的成长： 不但对用户把握得很好，也对软件工艺把握得很好。 不但会开出外在的功能性需求，也同样会开出内在的让软件系统更完善的非功能性需求。 不是在迁就用户，而是引导用户。 不会无限制地加功能，而是把握产品灵魂，控制并简化功能。 会为要做的和不做的需求感到同样的自豪。 做事情是要讲效率的。 需求总是会变化的，不要抱怨需求变化太快。应该抱怨的是为什么我们没有把握好方向？老变？没有应对好这些变化？ 当你忙得象牲口一样时，想一下是不是因为自己做事的时候就象牲口一样思考？ 寻求资源，不重复造轮子，进一步减少必须要做的需求； 分解需求，设定合理的进度目标； 对技术人员的培养： 写每一个模块，都 Code Review 和 Refactor 至 Elegant （优雅）的级别； 经常学习并分享好的技术文章； 降低手头的重复工作和维护性工作，通过使用工具、编写工具等消除它们； 拒绝或简化不合理的需求并征得所有（Stakeholder）利益相关者的同意； 对自己负责，内心中坚持尽可能高的标准，尽量不对骨感的现实妥协，如果妥协得受不了了就选择离开吧~ 【个人感悟】：Code Review 确实是最有益的编程实践，甚至没有“之一”，然而骨感的现实是80%的开发者做不到（80/20法则应该在此处适用），即使是做到的20%，其中80%还是被逼的，呵呵……包括我在内也是这样，因此需要想办法冲破这些心结和障碍登上那个新的台阶！ 从 Review 自己的代码开始做起，每每为自己的优雅代码而欢颜颂唱，或为自己的愚蠢蹩脚而痛斥凌骂：“垃圾！Shite！一坨翔！&amp;#@……”； 多读别人的代码，特别是好的开源项目的代码，建立与好代码的“亲切感”，见到优雅的代码如沐春风一般，这感觉应该就差不多了； 多分享，写一些小工具，开源并写相应的文档，接受各种挑剔、拍砖和建议等，不断改进修正而提高自己的代码质量和编程设计水平……]]></content>
      <categories>
        <category>manage/agile</category>
      </categories>
      <tags>
        <tag>code review</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[李笑来《通往财富自由之路》笔记]]></title>
    <url>%2F2016%2F09%2F06%2Fnote-lixiaolai%2F</url>
    <content type="text"><![CDATA[财富自由的定义首先要在语言上有准确的概念，才能思考清晰，并且要能在行动上指导自己。 分享的概念：好东西必须先是自己的，再拿出来跟人分享。 个人财富自由：某个人再也不用为了满足生活必须而出售自己的时间了。 把原来一份的时间卖出更多份，或是不需要出售自己的时间，在自己创造的平台上获取财富。 财富自由不是终点。 决择的依据注意力 &gt; 时间 &gt; 金钱 注意力凡是能用钱买来的时间，就是便宜的，凡是能用时间换来的注意力持续就是有价值的。 过去的一段时间里，你付费捡到的便宜都有哪些？ 过去的一段时间里，你在哪些可以捡便宜的地方却浪费了时间和注意力？ 过去的一段时间里，你发生过多少次因为跟家人吵架而整天心情不好的情况？ 如果你需要持续的注意力，却反复地被打扰，你有没有想出过什么有效对策？ 你在哪些地方忽略了资产的价值顺序，乃至于你吃了大亏？ 你到底有没有资本 资金的金额大小 资金的使用时限 资金背后的智慧 大多数人其实不配站在资本之后 第一个要突破的，并不是金额——这是绝大多数人止步不前的根本陷阱。 其实，投资的重点并不在于盈亏绝对值大小，而是在于盈亏比例大小。 把焦点放在盈亏比例上（相对值），而不是本金大小，盈亏金额上（绝对值），是90%以上的投资者终生没有学会的东西。 本金大小相对来看其实根本不重要，重要的是盈亏比例。 第二个要突破的，也是最重要的：能不能给自己的投资款“判上个无期徒刑”…… 不能够心平气和地被判上个无期徒刑的资金，就别假装资本混迹江湖了…… 第三个突破是与第二个突破联合并发的：投资知识、经验、智慧，几乎只能从实战中获得——书上写的、牛人讲的，都跟你没关系，因为只有那些东西在你骨子里生根之后再发芽且不夭折而后还要等上很久才会茁壮甚至茂盛…… 什么是落后？ 百分之一之后全是落后，将来可能是千分之一、万分之一都算落后 未来的目标： 早晚有一天，你要做到不再为了生活而出卖自己的时间。 早晚有一天，你要做到不落后，成为前百分之二十，甚至前百分之一。 从平庸走向卓越的最佳策略 比较是陷阱 用多维来与单维竞争，打造多维度竞争力。 每次跨界，都是给自己拓展一个新的维度。 同时要在至少一个维度上足够突出。 你应该拥有的最重要的能力——元认知 元认知能力：对自己的思考过程的认知与理解。 所谓可以用来解放自己的“心智”，指的就是具备足够元认知能力的大脑。 大量的研究结果表明，人 与人之间的技能差异，证据确凿地来自 于“刻意锻炼” （Deliberate Practice)。而一个人能够做到“刻意锻炼”，唯一能够仰仗的就是元认知能力， 反过来，元认知能力也必然会在刻意锻炼 的过程中不断被加强——现在你能想象人 与人之间的差异有多大了吗？ 元认知能力的提高，会有效防止抑郁症的发生。 你的财富创造能力取决于你能给别人创造 多少真正的价值。 •元认知能力是一个人可拥有的最重要的能 力。 •元认知能力不仅可以习得，还可以通过刻 意训练长期持续发展。 能够意识到自己的注意力—— 你这_生中最宝贵的资源——被分散了，就是元认知能力在起作用。 提高元认识能力的方法1. 坐享 类似打坐、禅修、内视、冥想等，英文称：Mediation。 把所有的注意力全部集中到一点。 2. 兴趣 类似心流一说，英文称：Flow 进入全神贯注状态可以使元认知能力彻底放松 教是最好的学习方法 大多数人直至成年，并没有养成哪怕仅仅一个属于自己的真正兴趣。即大多数人基本上没有什么事情感觉值得自己（主动去）“全神贯注”地做…… 全神贯注分为两种： 主动的：专注于提升某个特定的技能，必须刻意练习才能获得进步的技能。如：弹吉它、跳舞、跑步等。 被动的：读小说、看电影、玩游戏等。 3. 反思 琢磨自己的想法从何而来、有无逻辑谬误等。 反思不仅是一种元认知能力的刻意训练方式，也是调整情绪的根本。 控制情绪和控制时间一样，几乎是徒劳的。 冷静：认清情绪来源，并找到解决方案的结果。要认清情绪来源，就要调用元认知能力。 “我很生气”和“我知道我现在很生气”有巨大差异。 每一次认清情绪的来源，就是一次元认知能力获得锻炼的重大机会。 反思最多的是被情绪左右的行为和决定，多次以后，最终适时激活元认知能力会成为习惯，习惯性地冷静。 最有助于休息的活动： 阅读 亲近大自然 独处 钥匙在别处问题的解决方案通常不在问题的表面，而是在别的什么地方，所以别总是盯着问题不放，而应该在别处找它的钥匙。 毅力和坚持，都是不存在的概念：给想要实现的目标赋予对自己重要的意义。一念一世界： 重要的不是把关注点放在其他地方，而是要找到当下对自己最重要的意义，并且把它均摊到每天的任务上。 给想要实现的目标赋予想象的吓人的负面意义。另一方面，还可以想尽一切办法为“没有它的存在”赋予很多负面意义。 如果我没有这项技能，那现在有什么事儿我根本做不了？根本没有机会？ 进而，在将来会遇到什么样的困难？会失去怎样的机会？ 如果我最终竟然没有掌握这项技能，我就跟哪些人是一样的？他们的生活究竟因此有多么凄惨？ 不仅要罗列，还要“展开想象的翅膀”，把可以想象出来的细节“栩栩如生”地写下来——相信我，这会“吓到”你的大脑（准确地说，是把那种你所需要的恐惧深深地进入你的潜意识）。 与类似目标或技能的人群呆在一起。社交，从来都是学习活动中的一部分。 近朱者赤，近墨者黑。 总结更新的观念 注意力才是最宝贵的财富； 付费其实是花钱捡便宜； 百分之百的安全感可能是最大的枷锁； 活在未来才可能遇见财富； 自己先成为贵人才能不断遇到更多的贵人; 很可能1%之后都是落后； 为自己打造多维度的竞争力才是出路； 感悟的记录各种能力 元认知能力 学习能力 深入思考的能力 正确本身没什么价值加上“特立独行”才会有大的价值重点是要“行”，不能光特立独“想”。 比起“想错了”，更让人恼火的难道不是“想对了但是没有行动”吗？ “特立独行且正确”与“自以为是”的根本区别是什么？ 通过独立思考并合理的逻辑推理，找到“特立独行且正确”的事情。 有勇有谋，是对人最大的褒奖： 有勇，说明这个人愿意为自己的行为负责。不论做什么事，都不推卸责任，承担一切后果。只有拥有这样的胆量，才能够真正做到敢于特立独行。 有谋，说明他不会意气用事。做事讲逻辑，尊重事物发展的规律，不违背大势行动，这样才有机会无限地接近“正确”。 时间只是表象，注意力才是本质。思维技能和工具技能，工具技能比较显性，思维技能比较隐性，但更为重要。早其实并非决定性因素知识也有复利在知识的复利影响下，一个人的成长主要看这个人的利率，利率的高低取决于学习、实践的效果，而不在于时间长短。 注意：利率是可能变为负数的。错误或模糊的概念，通常会造成负利率的效果。 任何时候开始投资，开始学习都不迟。]]></content>
      <categories>
        <category>manage</category>
      </categories>
      <tags>
        <tag>罗辑思维</tag>
        <tag>李笑来</tag>
        <tag>财富自由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Re-natal 报错分析列表]]></title>
    <url>%2F2016%2F09%2F03%2Fre-natal-error-list%2F</url>
    <content type="text"><![CDATA[1234567Assert failed: ccustomEval figwheel-bridge.js:75&lt;unknown&gt; figwheel-bridge.js:88&lt;unknown&gt; JSTimers.js:47 引入的控件不可用？ 1Uncaugh [object object] 可能是db.cljs里的检查项不合格。 1Spec check failed: &#123;:cljs.spec/problems &#123;[] &#123;:pred map?, :val nil, :via [:xumu-app.db/app-db], :in []&#125;&#125;&#125; 传入参数为nil，不符合db.cljs中spec的检查项。 12345undefined is not an object (evaluating &apos;nextState.routes.forEach&apos;)NavigationScenesReducer NavigationScenesReducer.js:116NavigationTransitioner NavigationTransitioner.js:92 可能是sub.cljs加载错误，修改reg-sub为reg-sub-raw即可。 1console.error: &quot;Error rendering component (in env.android.main.reloader &gt; xumu_app.android.core.app_root)&quot; 可能是lein figwheel android未启动，或关闭了。 1Error validating module options: child &quot;platform&quot; fails because [&quot;platform&quot; must be a string] 未知原因：添加了dispatch 方法到按钮上即报此错。 123Cannot read property &apos;rowIdentities&apos; of undefinedConstructor.render ListView.js:362 ListView 的参数错误 参见这里 1234Assert failed: Missing tconfig key: :compiled-dictionary(:compiled-dictionary tconfig)customEval figwheel-bridge.js:75 应该是在i18n_l10n.cljs文件中少定义了:compiled-dictionary这项吧~ 1234Assert failed: Invalid tconfig key: :dictionary(not (:dictionary tconfig))customEval figwheel-bridge.js:75 无效的key？ 1234iOS build error&apos;React/RCTView.h&apos; file not found #374 OpenIOS build failed #392 原因参见 #371 1Requiring unknown module &quot;xxxx&quot;.... 因为没有加载，在figwheel模式下需要运行 re-natal use-component some-library/Component 1onlyChild must be passed a children with exactly one child 通常是因为某个元素如：TouchableHighlight 不允许里面有多个子节点而报的错，检查相应的元素内部是否有多个子节点的情况，修改为只有一个子节点即可。 详细参见此文。 123456789undefined is not an object (evaluating &apos;this.props.children.props.children&apos;)stackedPresent ListItem.js:336getInitialStyle ListItem.js:41prepareRootProps ListItem.js:290render ListItem.js:548 因为 List 下面含有非 ListItem 的元素。 12345Error while updating property &apos;justifyContent&apos; in shadow node of type: RCTViewupdateShadowNodeProp ViewManagersPropertyCache.java:109setProperty ViewManagerPropertyUpdater.java:150 设置的 justifyContent 属性错误，必须是 space-around 等形式。 12345Assert failed: ccustomEval figwheel-bridge.js:75&lt;unknown&gt; figwheel-bridge.js:88 某个组件、控件有问题，不能正确render。 123456789console.error: &quot;goog.require could not find: figwheel.connect&quot;error YellowBox.js:60&lt;unknown&gt; figwheel-bridge.js:223customEval figwheel-bridge.js:81&lt;unknown&gt; figwheel-bridge.js:109 修改了 project.clj 导致的错误，引用了错误的库，退回修改后正常。 另外，请参考： React native开发中常见的错误]]></content>
      <categories>
        <category>devtech/clojure</category>
      </categories>
      <tags>
        <tag>clojure</tag>
        <tag>re-natal</tag>
        <tag>react native</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F08%2F28%2Fclojure-learning%2F</url>
    <content type="text"><![CDATA[Clojure/Script 学习 layout: posttitle: “Clojure Learning”description: “”category: devtech/clojuretags: [clojure, GraphQL] RESTful Service Framework Luminus 综合 web 框架，其中（查看 Profiles 详细包含内容）包含 RESTful Services 的实现。 Immutant Web server Hiccup HTML Template Compojure API Sweet web apis with Compojure &amp; Swagger Arachne is a full, highly modular web development framework for Clojure. It emphasizes ease, simplicity, and a solid, scalable design. Hoplon ClojureScript Web Framework，如果只做一些网页，不多的动态效果，特别是你的技术栈还没有加入 React，而是在用 jQuery，而此时想试用 clojure script，那就可以试试这个 Hoplon 框架。 What is Hoplon? 说明了 hoplon 不同于 react 这类的使用虚拟 Dom 的框架的区别之处。 Precept A declarative programming framework, Precept is a framework for creating reactive web applications using a rules engine, declarative logic, and relational data modeling. Pedestal is a sturdy(坚实的) and reliable(可靠的) base for services and APIs. Liberator (Github repo) is a Clojure library for building RESTful applications. Compojure is a small routing library for Ring that allows web applications to be composed of small, independent parts. Moustache is a micro web framework/internal DSL to wire Ring handlers and middlewares. bidi Bi-directional URI dispatch. Silk Isomorphic Clojure[Script] Routing. 各框架比较图Clojurescript TodoMVC Examples by Library 各种 cljs 框架的 TodoMVC 比较Rich Hickey Already Answered That!Tenzing, the awesome Clojurescript application template 默认无后台，专注前端应用开发。 注：Eclipse Public License confetti-clj/confetti A tool to help creating and deploying static sites with AWS 在 AWS 上架设自己的静态网站服务 的工具。 Web server Ring is a low-level interface and library for building web applications in the Clojure programming language. It is similar to the Ruby Rack library, the WSGI in Python, or the Java Servlet specification. Chestnut is a Clojure/ClojureScript web apps application template. React framework Reagent Om Quiescent A lightweight ClojureScript abstraction over ReactJS, emphasizing its ability to (re)render immutable values efficiently. Rum is a client/server library for HTML UI. In ClojureScript, it works as React wrapper, in Clojure, it is a static HTML generator. Citrus State management library for Rum Brutha Simple ClojureScript interface to React GraphQL Framework Lacinia is a library for implementing Facebook’s GraphQL specification in idiomatic Clojure. Github site HTML UI lib Rum is a client/server library for HTML UI. In ClojureScript, it works as React wrapper, in Clojure, it is a static HTML generator. antizer ClojureScript library for Ant Design React UI components. 库倒是不错，可惜版本有点落后了，antd 已经 3.x 了，这个才适配 2.x 相关网站资料 Clojure 文档 cljdoc is a platform to build, host and view documentation for Clojure/Script libraries. Ten reasons to use Clojure/ClojureScript on your next web dev project oakes/paren-soup A browser-based editor for ClojureScript maven及clojars镜像 可以解决国内连接clojars慢的问题。 Qinais/WeChat 一个基于Clojure语言的微信开发库 Clojure Web 开发– Ring 使用指南 Night Light 在Clojure项目中添加依赖，运行命令即可运行起一个 IDE。 jiacai2050/history-master 用 ClojureScript + Reagent + Re-frame + Ant.design 写的浏览器插件，可以分析历史访问记录。 Scheme 语言官网 Should I learn Scheme or Racket? Lisp: Common Lisp, Racket, Clojure, Emacs Lisp 比较 Precursor is the best way to collaborate on early prototypes with your team. 用 Clojure/Script, Datomic, advanced CSS 等写成的原型设计工具，据说相当于 Sketch + Skype + Slack，可以团队协同头脑风暴设计、语音聊天等。 与 Scheme 的区别和比较What are the differences between Clojure, Scheme/Racket and Common Lisp? The languages have somewhat different design philosophies. Scheme was designed as a minimal dialect for understanding the Actor Model; it later became used for pedagogy. Clojure was designed for concurrency. As a result, Scheme has a reputation of being minimal and elegant, Common Lisp of being powerful and paradigm-agnostic (functional, OO, whatever), and Clojure of favoring functional programming. Scheme was designed to simplify the Lisp language, that was its only intent except it never really caught on. I think Clojure does something similar its meant to simplify Scheme for the JVM nothing more. Its just like every other JVM language just there to inflate the user experience, only to simplify writting boilerplate in Java land.]]></content>
  </entry>
  <entry>
    <title><![CDATA[百度地图使用相关资料]]></title>
    <url>%2F2016%2F08%2F28%2Fbaidu-map-usage%2F</url>
    <content type="text"><![CDATA[百度地图接口 MKMapViewListener地图显示事件监听器。 该接口监听地图显示事件，用户需要实现该接口以处理相应事件。 百度地图程序包 com.baidu.mapapi.map地图展示与操作相关方法，覆盖物相关方法]]></content>
      <categories>
        <category>devtech/js</category>
      </categories>
      <tags>
        <tag>baidu mapapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Learing]]></title>
    <url>%2F2016%2F08%2F28%2Fandroid-learing%2F</url>
    <content type="text"><![CDATA[Android 开发学习准备工作安装 JDK，Gradle，Android SDK 等；首先装 SDKMan，先别急去一个个下载，这里介绍就是安装其他开发工具的工具：这是专为开发人员准备的安装工具！网速好的话，一句话搞定： 1curl -s &quot;https://get.sdkman.io&quot; | bash 安装 Gradle，点击看一下最新的命令，本文书写时还是 3.0 版本，如下:1sdk install gradle 3.0 有用的库XCL-ChartsAndroid图表库(XCL-Charts is a free charting library for Android platform.) App Splash Screen Sizes{:target=”_blank”}]]></content>
      <categories>
        <category>devtech/android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2016%2F08%2F28%2Freact-native-learning%2F</url>
    <content type="text"><![CDATA[React Native 相关学习 layout: posttitle: “React Native Learning”description: “”category: devtech/reacttags: [react native]top: true React 相关 React 官网 Ant Design 蚂蚁金服ui库 Ant Design Pro 上手备忘录 Bi Sheng 转化 markdown 文档为静态单页面 React 应用 從零開始學 ReactJS React 中文文档 React 最佳实践——那些 React 没告诉你但很重要的事 基于 Jest + Enzyme 的 React 单元测试 How to debug Jest tests with VSCode react-motion React 动画效果库 redux-saga 实践总结 集成方案： React + Redux + RESTfulAPI React + Relay + GraphQL Relay： 全新的React数据获取框架 antizer ClojureScript library for Ant Design React UI components React Loadable A higher order component for loading components with promises. 用 promise 加载组件的高阶组件，可用于 React 显示加载、代码分离、服务端渲染等。 roadhog Cli tool for creating react apps, configurable version of create-react-app. 创建可配置的 React 应用的命令行工具，集成了 Jest, Enzyme 等。 在组件间共享函数的方法：参考此文：通过示例理解 React 的 render props 技巧 render props, 更适合只读的函数，例如跟踪滚动条、鼠标动作等； HOC(High order component), 更适合较复杂的方法，如 local storage 等； 相关文档资料 react-devtools React Developer Tools 比 React Native 更好的选择：Flutter 使用 Dart 语言编写 App。 React Native是原生开发的末日吗？ React Native: Is it the end of native development? Style 的笔记 alignItems ReactPropTypes.oneOf([ ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’ ]) stretch 向两边伸展 alignSelf ReactPropTypes.oneOf([ ‘auto’, ‘flex-start’, ‘flex-end’, ‘center’, ‘stretch’ ]) flexDirection ReactPropTypes.oneOf([ ‘row’, ‘row-reverse’, ‘column’, ‘column-reverse’ ]) flexWrap ReactPropTypes.oneOf([ ‘wrap’, ‘nowrap’ ]) justifyContent ReactPropTypes.oneOf([ ‘flex-start’, ‘flex-end’, ‘center’, ‘space-between’, ‘space-around’ ])]]></content>
  </entry>
  <entry>
    <title><![CDATA[收集的盒子]]></title>
    <url>%2F2016%2F08%2F26%2Fcollection-box%2F</url>
    <content type="text"><![CDATA[链接收集网页设计巅峰之作{:target=”_blank”}MDXMarkdown for the component era, 在 markdown 文档中加入 JSX 组件，可用于 React 项目。 为 Web 开发者提供的 16 本优秀的 E-BOOK{:target=”_blank”}语义化版本 2.0.0{:target=”_blank”}软件的版本号不是随便乱起的，这里有相应的说明和规范。 Publish Websites Like a BOSS B]{:target=”_blank”}发布静态网站、Blog 的系统，与 Jekyll-Bootstrap 类似吧~ Static - Static Site Generator{:target=”_blank”}用 Clojure 发布静态网站、Blog 的系统，有空可以试试。 StackEdit{:target=”_blank”}浏览器里的 markdown 编辑器，有点类似马克飞象的功能，可同步文件到Dropbox等，可写数学公式，可画UML图等。 作业部落 Cmd Markdown在线 markdown 文档发布站，类似马克飞象，功能较全面，支持 vim 编辑模式。 Ferret - A Hard Real-Time Clojure for Lisp Machines{:target=”_blank”}Ferret 可以编译 Clojure 文件到嵌入式机器中。 Boost Note An open source markdown editor. The intuitive and stylish note taking tool for developers.木匠的世界{:target=”_blank”}里面有全球各种木头的玩儿法，木头齿轮什么的~ WiX{:target=”_blank”}在网站上直接修改模板、文字、图片等内容生成网站的服务。 IDEA+Tomcat+JRebel热部署{:target=”_blank”}在IDEA上开发Tomcat一类的javaEE项目的姿势。 nylas/N1{:target=”_blank”}一个Electron框架做的桌面应用，邮件工具。 Devcards{:target=”_blank”} aims to provide ClojureScript developers with an interactive visual REPL.给ClojureScript开发，提供一个方便的界面效果测试功能。 PhxSQL{:target=”_blank”}PhxSQL是一个通过Paxos保证强一致和高可用的的MySQL集群。 A high availability MySQL cluster that guarantees data consistency between a master and slaves. data-scope{:target=”_blank”}将数据格式化，或变成图形的clojure库，支持pretty print系列、graph viz系列和chart系列。 g9.js{:target=”_blank”} (github{:target=”_blank”})automatically interactive graphics 交互式图形svg生成库 Leaflet.js{:target=”_blank”}an open-source JavaScript library for mobile-friendly interactive maps 移动端友好的交互式地图开源js库 细说 webpack 之流程篇{:target=”_blank”}详细说明了 webpack 的流程。 Element 网站快速成型工具{:target=”_blank”}Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助你的网站快速成型。（饿了么推出） Spacemacs for vim{:target=”_blank”}Vim 上的 Spacemacs ELPA镜像-EmacsChina{:target=”_blank”} DNSmasq – 配置DNS和DHCP DNSmasq是一个小巧且方便地用于配置DNS和DHCP的工具，适用于小型网络。它提供了DNS功能和可选择的DHCP功能可以取代dhcpd(DHCPD服务配置)和bind等服务，配置起来更简单，更适用于虚拟化和大数据环境的部署。 Brainfuck BF 语言 Brainfuck是一种极小化的计算机语言 Brainfuck 在线演示、调试工具 Brainfuck 在线转换工具 Brainfuck 和 Ook 语言在线加密解密工具 Brainfuck 在线运行工具 里面有个 fib 函数很厉害。]]></content>
      <categories>
        <category>scrap</category>
      </categories>
      <tags>
        <tag>static blog website version Clojure todo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Back to the blog]]></title>
    <url>%2F2016%2F08%2F26%2Fback-to-the-blog%2F</url>
    <content type="text"><![CDATA[回归 Blog有一段时间没有更新Blog了，有些时候用Lofter，因为方便而且容易分享，而技术、思路的收集则用Evernote，本来用得还挺好的，但Evernote加了限制，只能支持两个客户端什么的，于是转用有道云笔记，有道云笔记升级到2.x版，结果里面的查询太烂了，查到关键字在某些文章中，但不知道具体位置，反思了一下自己的选择，发现还是不科学，github的版本控制，markdown的纯文本，这不才应该是程序员最佳的选择吗？所以决定回归了，慢慢地搬运那些资料到这里吧，以后维护也方便，用vi编辑也快速，github保存也自由，搜索纯文本对于程序员来说也不是事儿~ 慢慢来，急也没有用…… 升级 jekyll 到 3.x，解决了几个问题： 留言 duoshuo 报个 js 警告 warning，提示需要添加 data-thread-key，于是在 comments-providers/duoshuo 文件中添加了如下代码： 1&lt;div class="ds-thread" data-thread-key="&#123;&#123;page.id&#125;&#125;" data-title="&#123;&#123;page.title&#125;&#125;"&gt;&lt;/div&gt; 另外，每次编译 jekyll 会报些 warning 警告：A call to ‘\{\{ post_url /path/to/some/post }} 之类的，一大堆，查看了这个讨论，想了一会才想到，是链接的问题，原来的链接要写 path，现在不需要了，直接就是 id 就可以了。 123\&#123;\&#123; post_url /devtech/git/2013-12-23-oftenused &#125;&#125;// 修改为：\&#123;\% post_url 2013-12-23-oftenused %&#125; 再就是 atom.xml 和 rss.xml 在 jekyll 编译时报了两个 warning 警告如下，查了一下，把 nil 改为 null 就好了，详见 Issue #2712。 1Build Warning: Layout &apos;nil&apos; requested in atom.xml does not exist. 看来这回归也不容易啊~！]]></content>
      <categories>
        <category>scrap</category>
      </categories>
      <tags>
        <tag>essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Mac OS X 开发环境和 Vim 的设置]]></title>
    <url>%2F2014%2F05%2F13%2Fmy-macosx-vimrc%2F</url>
    <content type="text"><![CDATA[系统设置 需要将CapsLock键改为Esc键，以方便Vi习惯。方法：安装 PCKeyboardHack，将CapsLock键的值从51改为53即可。 Eclipse 设置 添加Vrapper插件，以便使用Vi习惯。update url: http://vrapper.sourceforge.net/update-site/stable 添加Js的编辑环境，使用nodeclipse插件，update url: http://www.nodeclipse.org/updates/ 添加Html的编辑环境，在Eclipse的Marketplace中查找Html Editor，安装即可。 添加Html的快捷编辑方式Emmet，在Eclipse的Marketplace中查找Emmet，安装即可（似乎Nodeclipse包含这项）。 添加UML的绘制工具，参考这里的列表，我选择了AmaterasUML，下载zip文件解压后将三个jar文件放到eclipse/plugin/目录下即可。 Vim 设置 添加Pathogen插件，以便管理其他插件。 添加NERDTree插件，以便使用目录树功能。 添加Airline插件，在下面会出现一个漂亮的状态栏。 添加Emmet-vim插件，以便快捷编辑html代码。]]></content>
      <categories>
        <category>devtech vim</category>
      </categories>
      <tags>
        <tag>vim vimrc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backbone 路向何方？]]></title>
    <url>%2F2014%2F05%2F07%2Fmigrate-backbone-to%2F</url>
    <content type="text"><![CDATA[情况背景使用 Backbone 开发 Web App 之后，特别是较大型的项目，会发现因为缺少一些关键的功能（如：双向绑定等）代码越来越多且复杂，从而导致后期扩展和更新越来越困难，因此从基本框架层面需要考虑改善，以便使整个框架更有条理，更易组织，更易扩展、复用、重构等…… 目前可以想到的有三个方向： 在 Backbone 基础上结合如下一些增强框架实现双向绑定、易用的模板等机制，从而带来整个框架底层的改善。 Marionette Backbone.Marionette 组合应用库，用于简化大型 Javascript 应用。 TroraxJS 将 Backbone 和 Handlebars 结合的框架，适合大型可扩展的 Web 应用。 RivetsJS 轻量强大的数据模板绑定的解决方案，可与 Backbone 等合用。 ChaplinJS 可与 Backbone 结合使用，也可以与Exoskeleton（可替代 Backbone 系列，仅 8k） 结合使用。 Backbone.stickit Backbone的一个双向绑定插件。 Backbone.databinding npmjs 开发的双向绑定插件。 PubNub 可在整个应用及所有客户端上同步Model和Collections的解决方案。 转移到 EmberJS 上，使用 Handlebar 的模板机制。 转移到 AngularJS 上，全新的理念和编程思路。 转移前的分析 Migration from Backbone to AngularJS - how difficult it is? 这个讨论中提到一个5000行的 backbone 应用转移到 angular 要5天，估计还要对两个框架都很熟悉的情况下吧。所有的 Backbone 的 model 和 collection 都要转成 angular 的 services ，转移 html 和 Mustache 模板相对简单些，转移 jquery plugin 会比较麻烦，但如果简单的话就可以转到 angular-ui 上了。 Migrating from Backbone JS to AngularJS 这个讨论中提到Angular 可以使用 POJO 式的 Model，是双向绑定的，model 是放在 scope 中的，如 $scope.model.foo = bar 这样。 How do I “think in AngularJS” if I have a jQuery background? 这里有个精彩的回答，关于如何避免 jQuery 式的思考而改用 AngularJS 式的思考。 Using Backbone models with AngularJS 这里讨论了在 AngularJS 中如何使用 Backbone 的 model 的问题，其中给出了一些解决方案的思路。可以用于项目从 Backbone 转型到 AngularJS 的一个思路，平滑过渡？！：） Backbone 和 AngularJS 共用的示例 Backbone 和 AngularJS 共存于项目是可行的 另一个通过继承结合 Backbone 和 Angular 的方案示例 使用 Restangular 与 REST 的资源后台连接，是否真的比 Angular 的方法更好呢？这里有个示例，需要再研究，使用了 MongoLab 线上 MongoDB 数据服务实现了简单的项目增删改查功能。]]></content>
      <categories>
        <category>devtech js</category>
      </categories>
      <tags>
        <tag>javascript backbone angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 使用思路、最佳实践再整理]]></title>
    <url>%2F2014%2F04%2F30%2Fvim-best-practices%2F</url>
    <content type="text"><![CDATA[以下是初入门时的姿势，现在完全不用这么麻烦，直接用dot-vimrc即可。 在 Mac OS X 上使用 Vim 真的是很享受，所以决定要用好这个工具，以下记录下本人的最佳实践： 首先面临一个选择，是用 MacVim 还是 终端（Terminate）？我的选择是终端，不过我进一步选择了 iTerm2，功能强大些，界面漂亮些，再加上 Tomorrow 的主题，就更爽了，呵呵……选择原因如下： MacVim 下载安装后，没觉得有什么特别的功能，Vim 本身主要是在终端界面使用，所以菜单、工具等一切东西都会感觉多余，况且我打开 NERD_tree 时发现在 MacVim 中显示中文不正确，标识为一个框里面一个“字”的特殊字符，默认界面是白色的，找了半天不知道怎么换成暗色主题，于是放弃，想了一下多数情况还是习惯在终端直接 vim 使用，同时还会结合一些命令 shell 来使用，那么在终端中会更方便些。而 iTerm2 就成了很好的选择，替代了默认的终端，加强了各方面的功能，换上一个 Tomorrow Night Bright 的主题，便心旷神恰了:P。iTerm2 可以开多个标签，通过 Ctrl+左/右 或 Ctrl + {/}（即 Shift + [ 或 ]） 键来切换，这样一会儿运行 shell 命令，比如启动服务、监控日志什么的，一会再切换到 Vim 编程代码就很方便了。 其次是 Vim 的插件管理，这里个人觉得比较好的有两种：Vundle 和 Pathogen，我选择了 Pathogen，因为熟悉 git ，所以没什么压力，很自然也很喜欢这种方式。 主要插件，目前使用 NERD_Tree、Vim-markdown、Vim-Mou、Vim-airline 等，Command-T 安装的时候出错（make: Nothing to be done for ‘all’.），今天 google 了一通，大概知道原因是因为系统的 ruby 版本和 vim 里面的 ruby 版本不一致导致编译 Command-T 与 vim 不能兼容使用，中间尝试重装了一两次，还会报出这个错误 或这个 1234Vim: Caught deadly signal SEGVVim: Finished.Segmentation fault~ 解决方法参考此文： 先将 Command-T 已经安装的删除掉。 在 vim 中执行 :ruby p RUBY_VERSION 可以看到 vim 中的 ruby 编译版本为1.8.7，而系统 Mac OS X 10.9 中的 ruby 是2.0，可执行 ruby –version 看到，因此才会出现之前所述的编译错误。 在 Mac OS X 系统中实际上是有 ruby1.8.7 的，因此做个软链接就方便使用了。 执行sudo ln -s /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby /usr/bin/ruby1.8 建立 ruby1.8的软件链接。 再重新 clone Command-T 到~/.vim/bundle/目录（因为我使用 Pathogen）下：git clone https://github.com/wincent/Command-T.git 。 进入~/.vim/bundle/Command-T/ruby/command-t 目录，运行：ruby1.8 extconf.rb 会创建Makefile 。 再运行 make 编译后就好了！ Vim-airline 的颜色需要在.vimrc中设置：set t_Co=256，theme的更换可设置：let g:airline_theme=”molokai” 一篇 Vim diff 比较文档的用法，技巧：Vimdiff 使用 一些使用 Vim 进行 Scala 编程的参考文档： My Vim setup for Scala Coding Scala with Vim Editing Scala with vim Vim Scala IDE (VimSIde) built upon ENSIME 最新技能： Vim motion on speed! VIM插件: EASYMOTION[快速跳转] VIM插件: VIM-SIGNATURE[快速标记跳转]]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>vim iterm2 tomorrow-theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Play2/Scala 相关]]></title>
    <url>%2F2014%2F04%2F25%2Fplay2x-links%2F</url>
    <content type="text"><![CDATA[Scala 课堂 Scala Tutorial: Getting Started with Scala Play2开发的CMS系统]]></content>
      <categories>
        <category>play2x</category>
      </categories>
      <tags>
        <tag>play2 scala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2014%2F03%2F31%2Fproject-site%2F</url>
    <content type="text"><![CDATA[项目管理的网站服务 layout: postcategories : manage agiletitle: 项目管理的网站服务tagline: “Git is Great!”tags : [scurm, git, project, agile, free]lang: zh 分享一些项目管理的网站： 敏捷软件开发思想的项目管理网站服务： teambition：可免费创建有限数量的项目，界面友好。 trello.com：永久免费，但空间有限（10MB），界面友好。 Git 托管的网站服务： Github：程序界无人不知，无人不晓，免费创建公有库，私有库要收费。 Bitbucket： 免费创建公有库， 同时可免费创建有限的私有 Git 库。 Git.oschina：开源中国社区提供的 Git 库服务，可免费创建最多1000个公有或私有库。]]></content>
  </entry>
  <entry>
    <title><![CDATA[UML tools of Mac OSX 苹果系统下的建模工具]]></title>
    <url>%2F2014%2F03%2F27%2Fuml-tools-of-mac-osx%2F</url>
    <content type="text"><![CDATA[今天工作时需要设计一下程序的架构，即建模工作，这件事用纯文本似乎较难完成（本人是纯文本的 funs）。用手绘软件（Gimp, SketchBookExpress）也不太方便，失量图软件（Inkscape，LibreOfficeDraw）也要从画方框开始也不方便，毕竟是模块化的图形，还是用专用的建模工具比较方便。 这方面工具不少，很多还有生成代码的功能，这个功能个人倒是不太需要，只是有个示意图可以引导思路就好了，毕竟有了思路后写代码时还会有很多变化，其实也就跟原图不太一致了，非要同步图与代码倒是给自己增加了很多麻烦和顾虑。 之前用过 StarUML 工具，还不错，简单易用，生成的图样也比较美观，不过那个是在 Window 系统上的（见12款相关工具），现在用 Mac 了，当然应该找一款适合的工具了！ 大概看到所列的工具分为几类，一类是独立的工具，基于某个系统或跨平台系统，另一类是基于 Java 平台而可以跨平台使用，第三类就是 Eclipse 或 NetBean 的插件。 首先选择尝试 ArgoUML 工具，官网上直接有针对 Mac 的下载链接，下载下来解压运行，居然提示已损坏，无法使用，郁闷，重新下载再试一次，结果还是一样，只好放弃。 其次选择尝试 MDT-UML2Tools 插件，在Update页面使用 update 链接 http://download.eclipse.org/modeling/mdt/uml2tools/updates/releases/ 用 Eclipse 的 Install new software 功能无法下载，于是另外找到了下载地址（Eclipse 的官网组织确实有点混乱），下载了 zip 压缩包，直接在 Eclipse 里安装，也许是网络速度慢的原因，整个安装和下载过程超级慢！一个小时有没有？安装完在 Eclipse 中找不到在哪儿，郁闷，放弃。 另外，国内的一款工具 Trufun Plato UML2 有免费版，也有商业版，个人还是倾向使用完全免费的工具比较省心，也就没再尝试了。 法国一款 BOUML 也是商业软件，无限时版居然要150欧元，还是算了。 这个 Papyrus UML 看介绍不错，但是官网进不去，难道是停止维护了？ 这个 Umbrello UML 看介绍也不错，不过是基于 KDE 技术的，不知道 Mac 方便安装不，未尝试。 这个 TinyUML 开源 Java 工具，特别小巧，jar 文件启动，界面功能都非常简单，只支持画类图，感觉更适合作为实现方式的源代码研究。 在开源中国社区可以找到120多种UML建模工具。 有人提到 astah 不错，于是下载（社区免费版 72.5 MB）尝试，结果下载失败放弃。 在 Eclipse 里面的 Marketplace 搜索到更多的 UML 插件，选择尝试 UML Designer，在这里安装似乎方便很多，但是也安装了很长时间，这网速还能再慢点吗？因为 Eclipse 插件通常都要引用 EMF 等模块，因此如果 Eclipse 之前没有安装过这些模块，那么下载过程将极其漫长，最终由于安装时间过长放弃。 还发现 yEd Graph Editor，这个流程图绘制工具，有 Mac 版本，于是下载尝试，结果下载失败放弃。 还有 Diagramo 这个 HTML5 实现的，可以在线试用，也可以下载轻量的本地运行，还有可以部署到 Web 服务器上的 LAMP 版本，区别在于是否能保存、导出图片等功能。是个学习 HTML5 的好案例。 后找到 AmaterasUML，似乎看起来正是我想要的，简洁明快，于是下载试用，发现这个项目2012年7月后就再没有维护了，安装方式还是古老的将 jar 文件拷贝到 plugin 目录，需要 JDT 和 GEF 模块的支持，试用了一下还就是我想要的效果：简洁明快，这么好的项目怎么不再继续发展了呢！ 类似的还有 GreenUML，也是一样2011年后似乎也没再维护了，放弃。 最终找到了 CodeUML 这个在线 UML 工具，发现原来是基于 PlantUML 实现的，去它的官网一看，发现了 Eclipse 的插件，安装尝试，通过输入文本生成 UML 图形，这个思路太合我的胃口了，纯文本控嘛！同时这个项目是组件式的，可用于多种语言开发，极具参考学习价值！ 参见：Lofter 上的博文]]></content>
      <categories>
        <category>devtech uml</category>
      </categories>
      <tags>
        <tag>Mac osx</tag>
        <tag>uml</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Play!技巧问答]]></title>
    <url>%2F2014%2F02%2F26%2Fplayqaindex%2F</url>
    <content type="text"><![CDATA[Play!中如何用module组织多个相关项目 FunctionTest测试中如何取得Session值 Xml域名空间（WS.(url).get().getXml()无法取得带命名空间Document对象）识别问题 在Play!中如何实现类似过滤器的功能 如何同时使用http和https协议 在Play!中是否支持Comet-style或long-polling的请求？ 在Linux系统中，Fat32盘下无法执行play eclipsify命令 移除Cache可以设置时间吗？ 关于独立对像的存储报错问题validateAndSave(); 分离实体持久化出错（PersistentObjectException: detached entity passed to persist）问题 Play框架深层问题讨论 Play在Windows的cmd窗口中中文乱码的解决办法 一个Hql中count判断的写法 无法加载pdf等Module的问题 Hql中 left join 的写法]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>QA</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2014%2F02%2F26%2Fhqlleftjoin%2F</url>
    <content type="text"><![CDATA[数据库相关HQL 中 left join 的写法用 Play 查询数据时，遇到关联对象的查询时，需要使用 left join 的语句，但与我们习惯的 SQL 语句不同，HQL 的写法和思路是面向对象的，所以下面就记录一些可用的例句供实际使用时参考： 查询教的学生中有年龄大于30的老师 hql = &quot;select distinct o from Teacher o, Student r left join r.teacher h where r.age&gt;=?&quot;;Datomic 信息模型]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[罗辑思维听后记录]]></title>
    <url>%2F2014%2F01%2F10%2Fluojisiwei%2F</url>
    <content type="text"><![CDATA[2013年罗辑思维第19期：在一起 有后代在线优酷观看 如果你不知道学一个知识有什么用，没有学习它的动力时，可以听一下这一讲，世间万物的知识其实是相互关联的，不要刻意将自己局限在某个专业的思维之中。 第36期：大家都有拖延症在线优酷观看 如果你感觉自己总是会拖延一些重要的事情，听听这一讲，也许会找到灵感并有一些适怀。 自己整理了一下缓解拖延的答案： 将许多自己想做、要做的重要的事情列在自己的名单上，感觉拖延（不想做）一件事的时候，去这个名单上找另一件想做的事情来做。 将大而模糊、创造性的事情分解成机械性、具体的小事情去完成。 让种子飞一会儿，即提前先了解清楚一件事情的情况，然后可以先放下酝酿它，到时机成熟时就会快速完成。 把事情放到群体压力中完成，可以让虚荣心等督促自己完成。 因为人类的底层需求更关注当下的享受，所以会造成对未来重要的事情的拖延。 现代社会从手段到目的很遥远（农夫晒太阳的故事） 现实生活中很多目的是被强加上的（老大爷巧治儿童踢球的故事） 很多的目的是想象虚拟的（选择看电影的实验） 人在追求一个虚无飘渺的目的（1、目的是想象的；2、目的是强加的；3、目的和手段之间相隔很远）时，就会出现拖延，这也就是拖延症的主要原因。 未来的解决方向： 每个人做自己感兴趣的事情。 人在不同的年龄段下不断提升自己的境界，不断修炼，等待人格的成熟。 顺其自然，不必为其烦恼，甘于做个平凡人（Loser）即可。 第51期：怎么当个明白人在线优酷观看 知史而鉴今，你真的懂得因果逻辑吗？看一下我们经常出现的逻辑中的误区，让自己从另外的角度警惕陷入这样的逻辑错误中。 第54期：阴谋，是可能的吗？在线优酷观看 价格的本质：是指你要购买的一整套配套服务。 历史上的所有价格联盟都是无效的，你可以限制价格，但无法完全规定购买到的服务细节。 自由世界是所有人分散决策涌现出来的一个现象。总想控制价格是人类从过去走过来的一个妄念。 越往回追溯历史，你会发现人类社会是由权力来主导，由中心来控制的这样一种社会样态，但越往后、越往未来，人类社会越是以自由为前提，以市场来协同，由分散的节点来分头决策的这样一种社会样态。 1、空间上看，阴谋永远会存在，但规模会越来越受控。2、越往回追溯历史，阴谋得逞的可能越大，而相反越往未来，阴谋得逞的可能越小。 未来发展的趋势是“去中心化”，推荐一本书《市场的力量》。 2014年罗辑思维第5期 致终将逝去的隐私在线优酷观看 恐惧和贪婪令现代人不快乐，面对巨大贪婪和巨大付出的恐惧时，现代人该如何破呢？ 通过多维的“交叉复现”形成信息的高价值判断。 《信息简史》大数据时代，隐私不再，象一个绝望的守城战，是热武器对冷兵器的战争。 《智慧政府》大数据令政府有善治。 人性制造的不确定性和机器制造的确定性在无始无终的赛跑。]]></content>
      <categories>
        <category>manage</category>
      </categories>
      <tags>
        <tag>罗辑思维</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2014%2F01%2F09%2Fubuntueclipse%2F</url>
    <content type="text"><![CDATA[Ubuntu下Eclipse完美安装方案Ubuntu下直接apt-get安装Eclipse的问题 直接安装的版本较低，我用Ubuntu13.10安装的是Eclipse3.8，而要用ScalaIDE，最好是4.x以上版本。 其次是Eclipse的菜单显示问题，点击后看不到下拉菜单。 完美解决方案 直接从eclipse.org官方网站下载自己喜欢的版本，欲Java编程可选择Eclipse IDE for Java Developers。 解压到个人喜欢的软件目录即可。 使用此命令 sudo vim /usr/share/applications/eclipse.desktop 建立应用启动如下： [Desktop Entry] Name=Eclipse Comment=c project manage software Exec=/home/sam/develop/eclipse/eclipse Icon=/home/sam/develop/eclipse/icon.xpm Terminal=false Type=Application Categories=GNOME;GTK;Office;Eclipse 注意替换你自己的路径，这样就ok了，在Dash主页主就可以找到eclipse的图标启动了。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2014%2F01%2F09%2Fmodulemissing%2F</url>
    <content type="text"><![CDATA[无法加载pdf等module的问题简单地加载pdf的Module，如官网所述： play -&gt; pdf 1.0然而却提示无法加载。 尝试运行： play install pdf-1.0提示：Cannot fetch the modules list from %%http://www.playframework.org/modules%% 后在playframework群中找到答案，是因为要用.com域名才能获取。 需要修改此文件：{PLAY_HOME}/framework/dependencies.yml将最后面库路径的.org改为.com即可。 另外也可以自建仓库，如下： require - play - play1 -&gt; pdf 1.0 repositories - play1modules: type: http artifact: &quot;http://module.yourcompany.com/play1/modules/[module]-[version].zip&quot; contains: - play1 -&gt; *之后就是从官网下载相应的zip文件放到你的网站相应目录%%http://module.yourcompany.com/play1/modules/%%下即可。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程技术相关]]></title>
    <url>%2F2014%2F01%2F09%2Fotherrelay%2F</url>
    <content type="text"><![CDATA[Java 相关 String类型 格式 yyyy-MM-dd HH:mm:ss 转为 Date类型 java 类对象初始化顺序 JavaScript相关 JavaScript框架 easyui 相关 easyui中form表单的ajax实现 版本1.2.5改进说明 自动化测试（抓数据）相关 关于HtmlUnitDriver无法支持所有javascript效果的问题 Git相关 常用Git命令说明 git 与 svn 命令对比 电脑相关 电脑知识问答 联想C461M安装Ubuntu13.10问题 Ubuntu下Eclipse完美安装方案 持续集成 CI CircleCI 一个容器免费 License介绍]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F29%2Fc461mubuntusteup%2F</url>
    <content type="text"><![CDATA[联想C461M安装Ubuntu13.10问题本人的笔记本：联想旭日C461M，买来后安装的是Vista系统，用起来很不习惯，速度也慢，现在喜欢上了Linux的系统， 不喜欢Windows系统，WinXP微软也放弃维护了，于是前一年安装Fedora系统，使用还算正常，但是发现软件升级总是出 现问题，老是不顺利，19升20时直接失败。所以前两天尝试安装Ubuntu系统，发现界面、软件升级等都很爽，但是…… 安装Ubuntu112.04LTS系统后发现几个问题： 一、没有无线网络： http://mikezero.blog.163.com/blog/static/17527658320131161054480/ 首先查看网卡状态，终端命令： sudo lshw -C network 再查看网卡型号： sudo lspci -vnn | grep 802.11b 或： sudo lspci -vnn | grep BCM4311 下载：http://zh-cn.broadcom.com/support/802.11/linux_sta.php 解压：/home/sam/download/hybrid-v35-nodebug-pcoem-6_30_223_141 执行：make 再执行：sudo insmod wl.ko 结果没有反应，一直执行不动的样子。 于是再下载了readme.txt：http://zh-cn.broadcom.com/docs/linux_sta/README.txt 运行以下语句： On Ubuntu, you will need headers and tools. Try these commands: # apt-get install build-essential linux-headers-generic # apt-get build-dep linux 二、看不到输入法图标： 使用以下两句： killall ibus-daemon ibus-daemon -d 即可显示，但现在问题是启动后不显示。 三、找不到五笔输入法： sudo apt-get install ibus-table-wubi 然后重启可以找到海峰五笔。 四、未升级到LibreOffice4，默认是3，看到网上有升级方法： sudo add-apt-repository ppa:libreoffice/libreoffice-4.0 sudo apt-get update sudo apt-get dist-upgrade 不过因为无线网络这个致命问题，而没有解决，纠结下一步做何打算。 ======================================================== 第二天，决定安装了Ubuntu13.10，结果还是无法连接wifi，五笔输入法没有找到 killall ibus-daemon ibus-daemon -d 后，重启正常了。 另外 LibreOffice默认就是4，这点很开心。 而尝试修复无线网络时，下载的hybrid-v35-nodebug-pcoem-6_30_223_141.tar.gz文件， 在解压时提示：设置所有者出错，不允许的操作。 后尝试重启，重新下载文件后，可以正常解压。但运行make报错，失败。 再次查阅本机自带的帮助文件，找到无线网络驱动的内容，看到这个网址链接： http://wireless.kernel.org/en/users/Drivers/b43#supported 其中尝试运行了以下命令： sudo apt-get install firmware-b43-installer 似乎下载安装了：http://www.lwfinger.com/b43-firmware/broadcom-wl-5.100.138.tar.bz2 尝试重启后依然无效。 最后再尝试使用ndiswrapper调用windows的驱动程序的方法： sudo apt-get install ndisgtk 查看这个文档：https://help.ubuntu.com/community/WifiDocs/Driver/Ndiswrapper#bcm43xx 将/etc/modprobe.d/blacklist 中的bcm43xx相关语句屏蔽，尝试是否可以运行。 下载了官网的驱动Broadcom802.11_Wlan_XP.exe文件，按装文档所说解压该文件失败，即使是安装了cabextract 和 unshield也都不行。 ============================================================ 第二天 下午 ～ 再次查询google，发现此文： http://linuxg.net/how-to-fix-broadcom-bcm4311-wireless-driver-on-ubuntu-and-linux-mint/ 参考此文：http://blog.chinaunix.net/uid-22002627-id-3478362.html 执行相关命令： 1.进入驱动所在目录，即bcmwl5.inf和bcmwl5.sys所在目录 ndiswrapper –I bcmwl5.inf 2.查看驱动是否安装 ndiswrapper –l 3.写入配置文件 ndiswrapper –m ndiswrapper –ma ndiswrapper –mi 4.加载模块 modprobe ndiswrapper 当运行modprobe时，卡死，郁闷，每次运行这个命令就卡死～ 不过，好在重启之后，搞定了，识别了无线网络！！！折腾了两天终于好了。 最终应该正解是：http://blog.chinaunix.net/uid-22002627-id-3478362.html ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝ 另外，还有个问题：点重启时不能自动重启，停在“Ubuntu”的Logo界面很久不动，只好手工关机再开机。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F28%2Fplaywebsites%2F</url>
    <content type="text"><![CDATA[国内使用Play!框架的网站 拼车群 土椒网 泡椒网 中国地质大学 美之家家居网 雷猴（据说是） 吃得易 CNSPOC云课程平台 取号啦]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript框架及相关知识]]></title>
    <url>%2F2013%2F12%2F24%2Fjsframework%2F</url>
    <content type="text"><![CDATA[综合框架 arale.js{:target=”_blank”} 支付宝的前端基础类库 Arale 基于 SeaJS 和 jQuery 等，目前新构建 2.0 版本。 demo: 计算器{:target=”_blank”} KISSY{:target=”_blank”} 是由淘宝前端攻城师们发起创建的一个开源 JS 类库。 Ender.js{:target=”_blank”} - Ender is a full featured package manager for your browser. 作者 Dustin Diaz{:target=”_blank”} 模块加载框架 Javascript模块化{:target=”_blank”} Seajs{:target=”_blank”} 由支付宝团队开源，基于（CommonJS{:target=”_blank”}的一种实现，类似的模块加载框架：,,）和jquery的前端框架 BravoJS Require.js{:target=”_blank”} FlyScript AlmondJS{:target=”_blank”} A minimal AMD API implementation for use after optimized builds Amdjs{:target=”_blank”} The Asynchronous Module Definition (AMD) API specifies a mechanism for defining modules such that the module and its dependencies can be asynchronously loaded. ozjs{:target=”_blank”} 土豆网的开源模块加载js库 npmjs{:target=”_blank”} 后端依赖加载工具，包管理工具 Yarn{:target=”_blank”} 后端依赖加载工具，包管理工具 Yarn vs npm：你需要知道的一切 UMD{:target=”_blank”} 模板框架 Handlebars.js{:target=”_blank”} provides the power necessary to let you build semantic templates effectively with no frustration. mustache.js{:target=”_blank”} - Logic-less templates with Javascript. Eco{:target=”_blank”}: Embedded CoffeeScript templates Jade{:target=”_blank”}: Node Template Engine MVXX框架 （初步选择Emberjs，Knockoutjs 和 Canjs） The Top 10 Javascript MVC Frameworks Reviewed{:target=”_blank”} TodoMVC{:target=”_blank”} 「官网{:target=”_blank”}」A common learning application for popular JavaScript MV* frameworks 最佳实践之 Javascript MVC{:target=”_blank”} Regular.js a concise, flexible framework for creating data-driven component. 前端框架Regularjs的设计与选型之路 Vue.js v2.0 中文{:target=”_blank”} 官网{:target=”_blank”} Nuxt.js 是一个基于 Vue.js 的通用应用框架。 类似于 Next.js 之于 React.js。 2018年最值得关注的30个Vue开源项目 NUXT Vue.js 通用应用框架 Rant about VueJS + ClojureScript + Pug 一次 Vue 与 ClojureScript 结合的尝试记录。 Backbone.js{:target=”_blank”} Backbone.js vs Ember.js{:target=”_blank”} What are the key differences between Ember.js (formerly SproutCore 2.0) and Backbone.js?{:target=”_blank”} Marionette{:target=”_blank”} Backbone.Marionette 组合应用库，用于简化大型 Javascript 应用。 TroraxJS{:target=”_blank”} 将 Backbone 和 Handlebars 结合的框架，适合大型可扩展的 Web 应用。 RivetsJS{:target=”_blank”} 轻量强大的数据模板绑定的解决方案，可与 Backbone 等合用。 ChaplinJS{:target=”_blank”} 可与 Backbone 结合使用，也可以与Exoskeleton{:target=”_blank”}（可替代 Backbone 系列，仅 8k） 结合使用。 Emberjs{:target=”_blank”} 学习心得{:target=”_blank”} Ember/Handlebars template precompilation with Play{:target=”_blank”} Ember data{:target=”_blank”} 与RubyOnRails结合较好 ember-rest{:target=”_blank”} Simple RESTful resources in Ember.js Beginning Ember.js on Rails{:target=”_blank”} The architecture of Ember.js apps - data{:target=”_blank”} ember.js and the server{:target=”_blank”} AngularJS vs Emberjs{:target=”_blank”} 英文贴，讨论哪个更好，其中提到AngularJS的机制有2000个绑定的限制，做大型系统更应该选Emberjs。 Fire Up Ember.js{:target=”_blank”} 代码实例录像，需购买？ EMBLR, THE EMBER.JS TUMBLR{:target=”_blank”} Experimenting with the Architecture of Ember.js{:target=”_blank”} knockoutjs{:target=”_blank”} Simplify dynamic JavaScript UIs by applying the Model-View-View Model (MVVM) pattern 优点：HTML中的data-binding属性可以方便地与其他模板框架并用。如：Django合用的比较案例{:target=”_blank”} 在线练习学习网站{:target=”_blank”} BootStrap网站使用 knockoutjs的文章{:target=”_blank”} ，说明了Knockoutjs比Emberjs更适合改造网站的原因。 AngularJS{:target=”_blank”} HTML enhanced for web apps! MIT-licensed, Super-powered by Google! angularui{:target=”_blank”} 一篇从Ember.js迁移到AngularJS的文章{:target=”_blank”}。介绍了AngularJs更加可扩展的好处。 基于jQuery UI Autocomplete Widget的ui-autocomplete{:target=”_blank”} Ember.js or Angular.js?{:target=”_blank”} 英文论坛一贴 Choosing a JS MVC Framework: Angular.js vs Ember.js{:target=”_blank”} Canjs{:target=”_blank”} is a MIT-licensed, client-side, JavaScript framework that makes building rich web applications easy. 与其他框架共用性最佳，据评测性能也最佳{:target=”_blank”} 还有这个测试{:target=”_blank”} 这项显示knockoutjs在Live binding方面更好些{:target=”_blank”}。 Batman.js{:target=”_blank”} is a framework for building rich web applications with CoffeeScript or JavaScript. JavaScriptMVC{:target=”_blank”} is an open-source framework containing the best ideas in jQuery development. It guides you to successfully completed projects by promoting best practices, maintainability, and convention over configuration. PureJS{:target=”_blank”} effortless. javascript.The missing API for Javascript. http://obvious.github.com/matador/ http://derbyjs.com/ interesting http://flatironjs.org/ interesting http://railwayjs.com/ pretty bad. 服务器端（并客户端）框架 Nodejs{:target=”_blank”} Node.js Framework Comparison: Express vs. Koa vs. Hapi 三大主流 Node.js Web 服务框架比较 Node.js performance 2017: v7.9.0 vs. Hapi, Express.js, Restify and Koa and more 性能比较 三种Javascript(NodeJS)异步编程代码模式比较{:target=”_blank”} 在Node.js 中用 Q 实现Promise – Callbacks之外的另一种选择{:target=”_blank”} Meteor{:target=”_blank”} is a full stack framework 基于 Node.js，服务端与客户端都使用 javascript。 Yahoo! Mojito{:target=”_blank”} is the JavaScript library implementing Cocktails, a JavaScript-based on-line/off-line, multi-device, hosted application platform. Wakanda{:target=”_blank”} 服务器，开发工具studio和框架。 辅助工具及测试框架 Puppeteer 谷歌最新的大招，替代了 PhantomJS 等。 译文：Puppeteer 与 Chrome Headless —— 从入门到爬虫 Try Puppeteer online Puppeteer之爬虫入门 Headless Chrome入门 Puppeteer: 更友好的 Headless Chrome Node API 我终于弄懂了各种前端build工具{:target=”_blank”} Jasmine{:target=”_blank”} QUnit{:target=”_blank”} is a powerful, easy-to-use, JavaScript test suite. YEOMAN{:target=”_blank”} 脚手架工具，与下面的 Grunt 和 Bower 工具合并使用。 GruntJS{:target=”_blank”} 自动化任务的工具，可以压缩脚本、编译 coffescript、单元测试等。是一个基于任务的 JavaScript 项目命令行构建工具。 Bower{:target=”_blank”} 依赖管理工具 JSHint{:target=”_blank”} 是一个 JavaScript 的代码质量检查工具，主要用来检查代码质量以及找出一些潜在的代码缺陷。 Phantom JS{:target=”_blank”} 是一个服务器端的 JavaScript API 的 WebKit。其支持各种Web标准： DOM 处理, CSS 选择器, JSON, Canvas, 和 SVG。主要用于无首自动化测试、网页抓图或转 pdf 等、操控网页自动化、网络监控（类似YSLow）等方面。 自从 Puppeteer 发布后，停止维护了。 函数式编程 Ramda 函数库参考教程 Ramda for reactive streams Ramda 函数式编程： 自动柯里化 “函数优先，数据最后” 函数式组合使用 UI框架 Ant Design 这个是蚂蚁金服前端样式解决方案小组的项目代称。Alice Css书写规范{:target=”_blank”} 支付宝CSS样式架构{:target=”_blank”} 样式库构建规范{:target=”_blank”} D3.js{:target=”_blank”} is a JavaScript library for manipulating documents based on data. 二维图像生成框架 Wijmo{:target=”_blank”} 商业全面控件UI，包含类似Excel控件图表控件SpreadJS等企业级UI控件，价格：$895。 iView 官网 基于 Vue 的 UI 框架 Joint.js 关系图类库，国外，高级收费。 G6 关系图类库，国内蚂蚁金服旗下，免费。 绘图报表 jQuery Sparklines{:target=”_blank”} 很特别的在一行内显示一个小曲线或柱状图等的功能。 Peity{:target=”_blank”} 也是一行内的小图形功能。 RGraph{:target=”_blank”} 功能很全面，对公益或个人使用免费，有商业授权。 Highcharts JS{:target=”_blank”} 功能强大，对公益或个人使用免费，有商业授权，单网站$80。 jQuery HighchartsTable{:target=”_blank”} 免费MIT授权，但基于Highcharts JS，基本的线图、柱图等。 canvasXpress{:target=”_blank”} 使用HTML5的&lt;canvas&rt;标签实现，功能全面，LGPL免费授权。 JointJs{:target=”_blank”} 用于创建完全互动式图表，如组织架构图、UML状态图、UML类图等。 Elycharts{:target=”_blank”} 是一个易于使用的，可定制的JavaScript图表绘制组件。这个组件可用于绘制大部分常用的图表类型包括：line, column, are, bar, pie, sparklines and combinations。图表利用SVG/VML技术生成，基于jQuery + Raphaël开发。 脚本压缩打包工具 TUICompiler{:target=”_blank”} 土豆网的js打包工具 Webpack 2 入门教程{:target=”_blank”} 脚本牛人博客 Evan Wallace{:target=”_blank”} HTML5和 Javascript 高手，擅长 WebGL 等技术。 其他相关 Bootstrap中文官网{:target=”_blank”} 指令式Callback和函数式Promise：对nodejs的一声叹息{:target=”_blank”} 七个富应用JavaScript框架{:target=”_blank”} UIBox{:target=”_blank”} 一个方便搜索Javascript UI 框架的网站。 TodoMVC{:target=”_blank”}各种js框架写的TODO示例，帮助选择适合自己的js框架。 Yahoo开放的Json资源{:target=”_blank”} JSONP详解{:target=”_blank”} jQuery的deferred对象详解{:target=”_blank”} 桌面应用，NodeJS 打包编译 NodeJs中用node-webkit开发多平台的桌面客户端{:target=”_blank”} Node.js Packer 编译打包服务端 Node.js 代码最佳方案，文档下方列出了与其他类似项目的区别，间接说明了它的先进性。 Nexe is a command-line utility that compiles your Node.js application into a single executable file. ~ Depracted EncloseJS Compile your Node.js project. No sources aboard. Recommand Pkg below. Pkg Single-Command Node.js binary compiler. Electron Build cross platform desktop apps with JavaScript, HTML, and CSS CoffeeScript 《Smooth CoffeeScript》{:target=”_blank”} 脚本示例收集 图片选择框{:target=”_blank”} 布仿真特效{:target=”_blank”} 数字用英文怎么读{:target=”_blank”} 粒子系统{:target=”_blank”} 水滴下流系统{:target=”_blank”} 机械手臂系统{:target=”_blank”} 字母雨系统{:target=”_blank”} 正则表达式在线测试： REGex TESTER{:target=”_blank”} JavaScript 正则表达式在线测试工具{:target=”_blank”} regexpal{:target=”_blank”} 0.1.4 — a JavaScript regular expression tester 常用的正则表达式 CSS 相关 PostCSS{:target=”_blank”} A tool for transforming CSS with JavaScript CSSNext{:target=”_blank”} Use tomorrow’s CSS syntax, today.]]></content>
      <categories>
        <category>devtech js</category>
      </categories>
      <tags>
        <tag>javascript framework angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fcomputerqa%2F</url>
    <content type="text"><![CDATA[电脑使用及编程知识问答网易闪电邮和网易邮箱助手有什么区别，如何选择？ 网易闪电邮是功能比较全面的邮箱客户端，可以同时支持其他邮箱的邮件收发，类似Foxmail和Outlook这样的邮箱软件。而网易邮箱助手则是个轻客户端，只能连接网易的邮箱，提供来信提醒和桌面预览等功能。如果你还想用客户端收发其它邮箱，那就只能选择网易闪电邮了，如果你只有网易的邮箱，又不想安装个太大的软件，只想要个轻巧的来信提醒小工具，那么网易邮箱助手是不错的选择。 比较好的邮件客户端软件是什么？ 最常见的是Foxmail，其他还有很多，网易闪电邮也比较简洁好用。但个人最推荐的还是Thunderbird，跨平台Windows和Linux系统都通用，安装上Thunderbird Conversations插件，Lightning插件和Provider for Google Calendar插件，这个邮件客户端软件就变得非常实用，让人爱不释手了。有日历、任务功能，邮件组织象gmail一样舒服，同时日历还可以跟google日历同步，这样你的手机什么的终端只要连上google日历就是一套非常好的GTD工具了！ Html5实现多文件上传的方法？ 基于html5的可预览多图片ajax上传使用HTML5实现多文件上传 升级Fedora后启动不了报File not found错怎么办？ 一般情况是grub2未设置好，启动不了。可先用 Fedora16 LiveCD 或 Fedora16 DVD 启动进入shell，然后找到升级了的Fedora 16的挂载盘，如果是DVD修复的话，会挂在 /mnt/syslinux（记不清了）下，则执行： chroot /mnt/syslinux 执行以下命令可修复grub2： grub2-mkconfig -o /boot/grub2/gub.cfg grub2-install /dev/sda 如果执行第二句时报：Your embedding area is unusually small…，则一般是因为引导区被占用了，比如安装了Win7等，则可执行： grub2-install --force /dev/sda 这样就强制写入grub2的引导信息了，一般情况重启就正常了！ 主流代码仓库的选择，主要有哪些？ Subversion 集中式（目前还在大量使用的，熟悉的人员较多） Git 分布式（更先进些，特别适用于开源项目，如 github 网站） 从Subversion转到Git有相应的工具和方法，参考：转换你的 Subversion 到 Git 和 如何将SVN仓库转换为Git仓库 CentOS下使用Gitolite架构Git服务的步骤]]></content>
      <categories>
        <category>pc</category>
      </categories>
      <tags>
        <tag>pc</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fdateformat%2F</url>
    <content type="text"><![CDATA[String类型 格式 yyyy-MM-dd HH:mm:ss 转为 Date类型通常情况下可用Date.valueOf(String)直接转换; String类型格式：”yyyy-MM-dd”Date.valueOf(“yyyy-MM-dd”) 例： :::java String sd = &quot;2012-01-12&quot;; Date sdate = Date.valueOf(sd);但当String类型格式为”yyyy-MM-dd HH:mm:ss”时 则需使用： :::java SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); sdf.parse(String); 需要添加try/catch例： :::java String sd = &quot;2012-01-12 11:20:21&quot;; try { SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date sdate =sdf.parse(sd); } catch (ParseException e) { e.printStackTrace(); }SimpleDateFormat支持的其它格式: &quot;yyyy.MM.dd G &apos;at&apos; HH:mm:ss z&quot; 2001.07.04 AD at 12:08:56 PDT &quot;EEE, MMM d, &apos;&apos;yy&quot; Wed, Jul 4, &apos;01 &quot;h:mm a&quot; 12:08 PM &quot;hh &apos;o&apos;&apos;clock&apos; a, zzzz&quot; 12 o&apos;clock PM, Pacific Daylight Time &quot;K:mm a, z&quot; 0:08 PM, PDT &quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot; 02001.July.04 AD 12:08 PM &quot;EEE, d MMM yyyy HH:mm:ss Z&quot; Wed, 4 Jul 2001 12:08:56 -0700 &quot;yyMMddHHmmssZ&quot; 010704120856-0700 &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot; 2001-07-04T12:08:56.235-0700]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>devtech java</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fhtmlunitdriverjavascript%2F</url>
    <content type="text"><![CDATA[HtmlUnitDriver中javascript的支持问题参见：http://code.google.com/p/selenium/issues/detail?id=371#c4，看不到的元素或ajax异步更新的元素，都可能遇到无法取得或取得旧数据的问题。 和：http://code.google.com/p/selenium/wiki/FrequentlyAskedQuestions#Q:WebDriver_fails_to_find_elements/_Does_not_block_on_page_loads 因为HtmlUnitDriver默认的javascript引擎是Rhino，所以很多的脚本动作可能无法和在浏览器中一样，不过基本的是以Firefox为准的。 另：How_do_I_handle_authentication_with_the_HtmlUnitDriver? 如何在HtmlUnitDriver中加上用户密码验证的方法。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[easyui中form表单的ajax实现]]></title>
    <url>%2F2013%2F12%2F23%2Feasyuiform%2F</url>
    <content type="text"><![CDATA[示例代码如下： :::java $(&apos;#ff&apos;).form({ url:$(this).attr(&quot;&quot;action&quot;&quot;), onSubmit:function(){ return $(this).form(&apos;validate&apos;); }, success:function(data){ alert(data); } });其中url的值是取的form中的action属性，故需注意填写form的相应属性，当然也可以为’/controller_name/action_name’。]]></content>
      <categories>
        <category>devtech js</category>
      </categories>
      <tags>
        <tag>easyui</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fgitolitesetup%2F</url>
    <content type="text"><![CDATA[CentOS下使用Gitolite架构Git服务的步骤 在服务端创建专用用户，如：git，可考虑不设置密码，从而无法用密码登录服务器。 在管理员电脑上创建管理员密钥对，并（通过U盘或root账号）拷贝到服务器上，之后添加到git用户目录的.ssh/authorized_keys文件中。从而达到无需密码从管理员电脑直接ssh到服务器git上的效果。 使用git clone下载Gitolite。 运行gl-system-install安装到服务器，此时会看到git用户目录中多出了bin, share, repositories等目录。 从客户端下载git clone 管理目录：gitolite-admin。 添加用户公钥*.pub到keydir目录，配置用户权限在conf/gitolite.conf文件中。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery EasyUI 1.2.5 ChangeLog]]></title>
    <url>%2F2013%2F12%2F23%2Fversion1.2.5%2F</url>
    <content type="text"><![CDATA[Bug tabs: When add a new tab panel with href property, the content page is loaded twice. fixed. form: Failed to call ‘load’ method to load form input with complex name. fixed. draggable: End drag in ie9, the cursor cannot be restored. fixed. Improvement panel: The tools can be defined via html markup. tabs: Call ‘close’ method to close specified tab panel, users can pass tab title or index of tab panel. Other methods such ‘select’,’getTab’ and ‘exists’ are similar to ‘close’ method. tabs: Add ‘getTabIndex’ method. tabs: Users can define mini tools on tabs. tree: The mouse must move a specified distance to begin drag and drop operation. resizable: Add ‘options’,’enable’ and ‘disable’ methods. numberbox: Allow users to change number format. datagrid: The subgrid is supported now. searchbox: Add ‘selectName’ method to select searching type name.]]></content>
      <categories>
        <category>devtech js</category>
      </categories>
      <tags>
        <tag>easyui</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fconfession214%2F</url>
    <content type="text"><![CDATA[情人节程序员经典表白我能把整个世界都抽象成一个类…… 但是没办法把你变成我的对象…… 想让你成为私有常量，外部函数无法访问你…… 又想让你变成全局常量，在整个生命周期随时随地都可以调用你…… 因为世界上没有这样的常量…… 所以我无法定义你…… 我可以重载甚至覆盖任何一种方法…… 但是我却不能重载对你的思念…… 也许命中注定了 你在我的世界里永远的烙上了静态的属性…… 而我不慎调用了“爱你”这个方法…… 当我义无返顾的把自己作为参数传进这个方法时…… 我才发现方法”爱你”里面执行是一个死循环…… 她不停的返回我对你的思念，并存入我心里的堆栈…… 在这无穷无尽的循环中…… 我的内存资源很快消耗殆尽…… 而我却依然不停的向系统申请空间换取我对你的想念…… 终于我受不了“爱你”的煎熬…… 调用了”表白”这个Public方法…… 将字符串“如果你爱我，我将用尽一生去爱你，你爱我吗？”传递给你…… 我却捕获一个异常－－－内存溢出，我爱的人不爱我…… 为了解决这个异常…… 我偷偷地修改了”表白”的方法…… 加上了异常处理finally块…… 并且将返回值设为真…… 心想这样万无一失了吧…… 鼓起勇气再一次调用”表白”…… 我却依然捕获到同样的异常…… 仔细调试代码，原来在方法中有一段是这样的…… “如果没房没车则执行System.exit()”…… 欲哭无泪，身心破碎，终于我的系统崩溃了…… 留下一句“OutOfMemory 内存溢出”的提示……]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Fcoolguydontlookatexplosions%2F</url>
    <content type="text"><![CDATA[Cool Guys Don’t Look At Explosions纯爷们儿从不围观爆炸！Cool guys don&apos;t look at explosions They blow things up and then walk away Who&apos;s got time to watch an explosion? Because cool guys have errands that they have to walk to.. Keep walkin&apos;, keep shinin&apos; Don&apos;t look back keep on walkin&apos; Keep struttin&apos; slow motion The more you ignore it, the cooler you look Samberg: Ladies &amp; gentlemen, please join me in welcoming.. Mr. Neil Diamond! Will Ferrell: ha ha ha....Where are we?! Cool guys don&apos;t look at explosions They stride for it in their diamond covered boots They wear jumpsuits with glitter and rhinestones And walk away in slow motion.. Keep walkin, you&apos;re cruisin.. Cherry Cherry...Sweet Caroline.. Denzel walks... Will Smith walks... Mark Wahlberg is wearin a hat! Samberg: Going solo....JJ Abrams! JJ Abrams solo Yeah! Okay. Because,Cool guys don&apos;t look at explosions, The flames are hot, but my heart is chill Walk fast from the roaring explosion, And don&apos;t think about the people you killed这首歌专门为 The 2009 MTV Movie Awards而制作的里面穿插了很多大片的画面 0:12 墨西哥往事2 Desperado 0:29 地狱骑士 Hell Ride 0:40 丛林奇兵 Welcome to the Jungle 0:57 幸运数字斯莱文 Lucky Number Slevin 1:08 钢铁侠 Ironman 1:12 杀出个黎明 From Dusk Till Dawn 1:14 老无所依 No Country for Old Man 1:21 全民超人 Hancock 1:24 生死狙击 Shooter 1:47 辛瑞那 Syriana 1:50 铁甲威龙 RoboCop 1:54 蝙蝠侠前传2 黑暗骑士 Batman 2:00 空中监狱 Con Air 2:13 X战警前传: 金刚狼 X-Men Origins: Wolverine 英文原版：http://v.ku6.com/show/rQb7VJTU5aHGspjWA3mLvw...html 中文改编版：http://v.youku.com/v_show/id_XMjI2OTQ1NjM2.html]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F23%2Ftracinterfacecustomization%2F</url>
    <content type="text"><![CDATA[定制Trac界面原文地址 介绍该页面旨提供有关如何定制Trac界面的建议. 话题涵盖了编辑HTML模板和CSS文件, 但不包含程序代码本身. 这些话题想要向用户展示如何更改Trac的外观来满足他们特定的要求. 项目Logo和图标定制Trac界面最简单的部分是logo和站点的图标. 他们都可以通过trac.ini的设置进行配置. logo或者图标应放在项目环境目录中的一个’’htdocs’’目录中(注意: 用Trac0.9之前的版本创建的项目, 你需要创建该目录). ‘’注意: 实际上你可以把logo和图标放在服务器的任何地方(只要通过服务器能访问到就可以), 并且在配置中使用他们的绝对URL或服务器的相对URL.’’ 在你的trac.ini中的配置相应的段: Logo将src设置改为site/, 后面跟着你的图像文件的名字. 应修改’’宽度’’和’’高度’’设置来匹配你的图像的尺寸(Trac的chrome处理器用””site/“”对应位于项目目录的””htdocs””, 用””common/“”对应普通文件). [header_logo] src = site/my_logo.gif alt = My Project width = 300 height = 100图标图标应该是.gif或.ico格式的大小16x16的图像. 将icon选项修改为site/, 后面跟着你的图标文件的名称. 在你的Web浏览器中, 图标一般会显示在站点的URL旁边或者在’’书签’’菜单中. [project] icon = site/my_icon.ico‘’’注意’’’, 该图标会被 IE 忽略, 它只接受主机根路径下名为’’favicon.ico’’的文件. 要使项目图标在IE和其他浏览器中都起作用的话, 你可以将图标储存在主机的根路径中, 并按照下列方法在trac.ini中引用它: [project] icon = /favicon.ico站点页眉和页脚在每个Trac项目的环境目录中, 应该有个叫templates的目录. 该目录包含文件site_header.cs和site_footer.cs. 用户可以通过添加所需的HTML标记到这些文件中, 来定制他们的Trac站点. 这两个文件的内容分别放在网站中每页的开始的标签&lt;body&gt;和结尾的标签&lt;/body&gt;中. 这些文件可以包含静态HTML, 当然, 如果用户想要有动态的内容, 他们可以使用页面内部的ClearSilver模板语言. 当你需要查看模板中有哪些可用变量, 将查询串’’?hdfdump=1’’添加到你的Trac站点的URL中. 这样将显示出模板数据的结构化视图. 站点样式表调整一个Trac网站的布局的主要方法是添加CSS样式规则来覆盖默认的规则. 最好是通过编辑项目环境的templates目录下的site_css.cs文件来实现. 该模板中的内容会插入到Trac生成的每个HTML页面的&lt;style type=&quot;text/css&quot;&gt;``&lt;/style&gt;中. 虽然你可以将定制样式规则直接添加到site_css.cs文件中, 我们建议你只引用一个外部样式表, 以便使浏览器能缓存此CSS文件, 而不是每次都传输这些样式规则. 下面的例子会导入一个位于根style目录下的样式表: @import url(/style/mytrac.css);你可以使用一个!ClearSilver变量来引用存储在项目环境的htdocs目录中的样式表: @import url(`&lt;?cs var:chrome.href ?&gt;`/site/style.css);项目列表如果你在使用Trac执行多个项目时, 你可以用一个定制!ClearSilver模板来显示项目的列表. 下面是Trac用来显示各项目链接的列表的基本模板. 对于不能加载的项目, 它会显示一个错误信息. 你可以将它作为你自己的索引模板的一个起点. :::html #!text/html `&lt;html&gt;` `&lt;head&gt;``&lt;title&gt;`Available Projects`&lt;/title&gt;``&lt;/head&gt;` `&lt;body&gt;` `&lt;h1&gt;`Available Projects`&lt;/h1&gt;` `&lt;ul&gt;`&lt;?cs each:project = projects ?&gt;`&lt;li&gt;`&lt;?cs if:project.href ?&gt; `&lt;a href=&quot;&quot;&lt;?cs var:project.href ?&gt;`&quot;&quot; title=&quot;&quot;`&lt;?cs var:project.description ?&gt;`&quot;&quot;&gt; `&lt;?cs var:project.name ?&gt;``&lt;/a&gt;`&lt;?cs else ?&gt; `&lt;small&gt;``&lt;?cs var:project.name ?&gt;`: `&lt;em&gt;`Error`&lt;/em&gt;` `&lt;br /&gt;` (`&lt;?cs var:project.description ?&gt;`)`&lt;/small&gt;`&lt;?cs /if ?&gt; `&lt;/li&gt;`&lt;?cs /each ?&gt; `&lt;/ul&gt;` `&lt;/body&gt;` `&lt;/html&gt;`一旦你创建了自己的定制模板, 你需要配置Web服务器, 来告诉Trac该模板的具体位置: 对于 FastCGI: FastCgiConfig -initial-env TRAC_ENV_PARENT_DIR=/parent/dir/of/projects \ -initial-env TRAC_ENV_INDEX_TEMPLATE=/path/to/template对于 mod_python: PythonOption TracEnvIndexTemplate /path/to/template对于 CGI: SetEnv TRAC_ENV_INDEX_TEMPLATE /path/to/template主要模板!ClearSilver也可以使用自己修改的Trac !ClearSilver模板. 注意, 不推荐使用该技术, 因为它使得升级Trac有很多问题: 很不幸的是, 在模板和程序代码间存在几个依赖关系, 例如表单域的名称, 模板数据的结构等, 这些在不同版本的Trac中都可能有变化. 如果你一定要使用修改的模板, 将默认模板目录(通常是在$prefix/share/trac/templates中)中的模板文件复制到项目环境中的templates目录中. 然后修改这些副本, 达到你想要的效果。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令说明]]></title>
    <url>%2F2013%2F12%2F23%2Foftenused%2F</url>
    <content type="text"><![CDATA[参考：史上最浅显易懂的Git教程！ 进入你的工作目录 cd yourworkpath 列出所有branch，当前所在branch前面有“*”号。 git branch -a 切换工作库 git checkout v1.5.1 合并另一个branch，通常是master git merge master 再切换回来 git checkout master 查看当前目录情况 git status 将当前目录中的修改提交到相应的库（branch）中 git commit -m “”此处添加修改说明”” 从远程库中合并最新状态 git pull 注：当使用git pull命令的时候如果提示有本地文件修改了，无法合并的时候，我们可以放弃本地修改（注意放弃的修改将不可恢复），然后再更新；如果不想放弃本地修改，可以先提交，然后再合并更新。如果要放弃本地修改后更新： git reset –hard git pull 将合并后的状态并入远程库中。 git push origin master 如果是在分支上开发则为： git push origin v1.5.1 取消某个文件的版本控制，但实际不删除这个文件： git rm –cached somefile.txt 然后再修改目录下的.gitignore文件，添加上这个文件的相应忽略即可。 查看每一行的改动： git blame &lt;filename&gt; git 查看一个文件的所有修改历史 git log –pretty=oneline &lt;filename&gt; 创建一个分支并切换到这个分支工作，通常可用于临时进行一些测试性的开发，如果要保留这个dirty的分支内容，可以commit上去，随时再切换回master就象一切没发生过。 git checkout -b dirty 如果这个测试性的开发需要被接受合并到主干master，只要切换到master再合并即可： git checkout mastergit merge dirty 丢弃加入缓存区（即git add的准备提交的文件）的修改，分别退回到当前版本、上一个版本、上上一个版本、前99个版本、某特定 id 版本： git reset –hard HEAD git reset –hard HEAD^ git reset –hard HEAD^^ git reset –hand HEAD~99 git reset –hard 322542re342 查看过去和未来的版本 id 等信息： git log git reflog 丢弃某个文件的修改，和SVN的revert命令一样 git checkout – comefile.txt 丢弃本地所有文件的修改，和SVN的revert命令一样 1git checkout -- *.* 查看当前路径下的远程库情况： 1git remote -v 添加远程库路径 1git remote add origin https://github.com/wind13/xxx.git 快速本地复制一个库到另一个目录，不带多余的文件： 1git fast-export --all | (mkdir ../repobackup &amp;&amp; cd ../repobackup &amp;&amp; git init &amp;&amp; git fast-import &amp;&amp; git reset --hard HEAD) 分拆代码库 12git filter-branch --prune-empty --subdirectory-filter ./folder/to/subrepo/ branch-namegit filter-branch --prune-empty --subdirectory-filter ./folder/to/subrepo/ -- --all 如果分拆有误，想退回 1git reflog 查看到具体要回到哪个点，记住HEAD{n}里面那个数字n；然后再执行 reset 回到那个位置： 1git reset --hard HEAD@&#123;n&#125; 使用GIT SUBTREE集成项目到子目录 第一次添加子目录，建立与git项目的关联 12git remote add -f ai https://github.com/aoxu/ai.git git subtree add --prefix=ai ai master --squash 从远程仓库更新子目录 12git fetch ai master git subtree pull --prefix=ai ai --squash 从子目录push到远程仓库 1git subtree push --prefix=ai ai master Git 工具 - 子树合并]]></content>
      <categories>
        <category>devtech</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fdetachedpersist%2F</url>
    <content type="text"><![CDATA[分离实体持久化出错（PersistentObjectException: detached entity passed to persist）问题在Play!使用中，会用到Job来异步执行一些耗时的操作，此时很容易犯这样的错误： :::java public class SomeLongJob extends Job`&lt;Void&gt;` { private SomeModel model; public SomeLongJob(SomeModel model) { this.model = model; } @Override public void doJob() { model.someprop = &quot;new value&quot;; model.save(); } }此时执行后，会在save()方法处抛出异常：PersistentObjectException: detached entity passed to persist 这是因为对象是从外面传进来的，而（我想）doJob是另外一个新启动的线程，所以这里可能只是一个引用，而真正的对象在原来那个主线程中，这边可能就只是个分离的拷贝或只是个引用，所以无权进行持久化操作。尝试过使用 model.merge()，好像不报错了，但又好像没有真正保存了值，猜想是因为没有在主线程中再次执行真正的save()去持久化。 因此，为了彻底避免这样的复杂问题，还是采用比较简单的解决方案吧： :::java SomeLongJob extends Job`&lt;Void&gt;` { private Long id; public SomeLongJob(Long id) { this.id = id; } @Override public void doJob() { SomeModel model = SomeModel.findById(id); model.someprop = &quot;new value&quot;; model.save(); } }这样一来，只传入id即可，所有的操作都在doJob内部，应该说是统一的一个线程中，这样就没有问题了。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fdeepqa%2F</url>
    <content type="text"><![CDATA[Playframework热情交流群里的邮件讨论Freewind@play23月17日 10:21昨天有感于play源代码里的一些强大功能和精巧实现，提出了以下问题，这些问题在群里和几位朋友简单讨论过，但我觉得整理一下会有用。 play的一些打破常规的做法，让我非常欣赏和赞叹。希望大家不要仅满足于使用play，在有余力的情况下，多看看play的源代码，对自己java能力的进一步提高非常有帮助。当你能读懂甚至能独立实现一个类似play的框架时，就是真牛人了：） 有一些问题我也不知道答案，我有时间也会去读，共勉。 问题列表： play的hot reload是怎么实现的 有的库不能直接在play中使用，必须写一个插件以解决classloader的问题，为什么 action中向view中传参数时，可以render(a,b,c)，就直接过去了，不用专门传参数名””a””,””b””,””c””，这是怎么实现的 javabean不用写getter/setter，自动生成，是怎么实现的 其它类中调用javabean中的public field，但是最终将被转为getter/setter，怎么实现的 play中的template用的是groovy的gsp，但增加了自己的东西，比如tag等，是怎么实现的 User类继承Model后，可以使用findXxx这样的静态方法，这个方法是父类提供的，却能返回正确的子类类型，是怎么实现的 Action中直接调用另一个类，不用写return，但后面的代码就不再执行了，这是怎么实现的 play的session是基于cookie的，是怎么实现的 play中可以支持大量客户端的ajax应用，在action里，当接收到一个请求但没有取得需要的数据时，会暂停它的执行让出线程，等到有数据时再回到线程，发给客户端，是怎么实现的 public static void action(String name, String password)，play能根据name和password的名字，到request中取对应的数据，是怎么实现的？默认情况下，java程序编译后，参数名都会变，比如变成action(String a,String b) play的request,response,cookie等类，都是自己定义的，为什么却可以打包为war，部署到tomcat下？那边传过来的可是j2ee里的类 green@使用中3月17日 11:07很好的问题。谈谈自己的一些认识： play的hot reload是怎么实现的 Play 会尝试使用Java instrument来做类的热替换，不过这个过程成功率不高，因为限制很大，包括类方法的签名不能改变如果java instrument替换失效，play会重启，这样会重新装载application class loader，以便获得最新的应用类字节码参见 play.classloading.ApplicationClassloader.detectChanges() 有的库不能直接在play中使用，必须写一个插件以解决classloader的问题，为什么？ 能举例吗？ action中向view中传参数时，可以render(a,b,c)，就直接过去了，不用专门传参数名””a””,””b””,””c””，这是怎么实现的？ play使用本地变量名增强器对应用类进行增强，这个过程会获得参数名字信息并保存到线程变量（ThreadLocal）当中。同时控制器的render方法会尝试获得线程变量中的变量名字，将其放入renderArgs参见 play.classloading.enhancers.LocalvariablesNamesEnhancer 和 play.mvc.Controller.render() javabean不用写getter/setter，自动生成，是怎么实现的 参见 play.classloading.enhancers.PropertiesEnhancer另外不是不用写getter/setter，而是当你没有提供getter/setter方法的时候，play帮你提供一个默认的 其它类中调用javabean中的public field，但是最终将被转为getter/setter，怎么实现的 参见 play.classloading.enhancers.PropertiesEnhancer play中的template用的是groovy的gsp，但增加了自己的东西，比如tag等，是怎么实现的？ tag的实现有两种，一种是定义tag模板（/play/framework/templates），另一种是定义Java类/play/framework/src/play/templates/(FastTags.java|GroovyInlineTags.java))。调用机制在play.templates.GroovyTemplateCompiler.startTag()可以找到 User类继承Model后，可以使用findXxx这样的静态方法，这个方法是父类提供的，却能返回正确的子类类型，是怎么实现的？ 这是通过Java Generic机制实现的，如下代码所示： :::java public static `&lt;T extends Model&gt;` T findById(Object id) { throw new UnsupportedOperationException( &quot;&quot;Embedded entity does not support this method&quot;&quot;); } 其实Java编译器无法判断具体返回类型，只能说是Model的子类。这个机制也有缺陷，导致下面代码编译出错： :::java return (id == null) ? null : MyModel.findById(id); 你只能用一下代码替换： :::java if (null == id) return null; else return MyModel.findById(id); 另外在Model的各种find方法中很多都会抛出UnsupportedOperationException异常，之所以运行的时候没有抛出异常，也是因为通过增强器进行了代码注入。 Action中直接调用另一个类，不用写return，但后面的代码就不再执行了，这是怎么实现的？Controller的各种render方法最后都会抛出play.mvc.results.Result类型的异常 play的session是基于cookie的，是怎么实现的？很简单，在回应请求的时候play的session对象会被写入cookie，而读取请求的时候会从cookie生成session对象 play中可以支持大量客户端的ajax应用，在action里，当接收到一个请求但没有取得需要的数据时，会暂停它的执行让出线程，等到有数据时再回到线程，发给客户端，是怎么实现的？通过await()调用实现的。具体过程比较复杂，如果愿意探究，需要仔细研究Controller和ActionInvoker代码 public static void action(String name, String password)，play能根据name和password的名字，到request中取对应的数据，是怎么实现的？默认情况下，java程序编译后，参数名都会变，比如变成action(String a,String b)与问题3同理，不过使用LocalVariablesNamesTracer的换成了ActionInvoker，这个过程不仅仅是变量名传递，同时还有很复杂的变量类型绑定。具体参见ActionInvoker.getActionMethodArgs的代码 play的request,response,cookie等类，都是自己定义的，为什么却可以打包为war，部署到tomcat下？那边传过来的可是j2ee里的类不熟悉这方面的，大概是play.server.ServletWrapper做转换工作，参见play.server.ServletWrapper.service方法。 Freewind@play23月17日 11:27 比如使用Ebean，如果不写一个插件来处理classloader的问题，在play中无法使用。 Play在dev模式下，编译java源代码后，生成的字节码是放在内存中的，而不是以.class文件形式保存在硬盘上。这给其它一些库带来了麻烦。比如在Ebean的config中，需要传入Model类，Ebean会设法导入对应的.class文件。此时必须写一个插件，让Ebean能从play的classloader中找那些类。不然找不到会报错。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Play!中如何实现类似过滤器的功能？]]></title>
    <url>%2F2013%2F12%2F13%2Ffilterallcontroller%2F</url>
    <content type="text"><![CDATA[如果是单个Controller要实现过滤，只需写一个public static 的方法，加上@Before注解即可达到执行所有action前先执行这个方法的目的。 如果想实现全局即整个站点的action都被过滤，就需要写个BaseController（名字随便起，如SuperController，Application等）继承 Controller，在这里面写@Before的方法。然后其他的Controller都继承自BaseController即可。”]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>filter</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FunctionTest中如何取得session的值]]></title>
    <url>%2F2013%2F12%2F13%2Ffunctiontestsession%2F</url>
    <content type="text"><![CDATA[原文摘抄自：https://groups.google.com/d/msg/play-framework/-/iQLX-uLwHWsJ （可能因墙访问不了……我是在邮件列表中收集的） 需求和问题原问及简单翻译说明如下： Given a simple action:【简单给一个action如下：】 :::java public static void testAction() { session.put(&quot;worked&quot;, &quot;yes&quot;); }I want to test that the session is set:【我试着测试这个session是否被设置：】 :::java @Test public void setsTheSession() { Response response = GET(&quot;/test&quot;); assertEquals(&quot;yes&quot;, Scope.Session.current().get(&quot;worked&quot;)); }But Scope.Session.current() always returns an empty map. Any clues?【但Scope.Session.current()总是返回一个空的Map。有什么办法吗？】 关键回答原答及简单翻译如下： I don’t think that works because you are not in the context of a server request when in a test. You are just acting as a regular browser making a GET request.【我不认为可以那样写，因为在一个test中你不在服务请求的上下文中。你只是象一个普通的浏览器那样发送了一个GET请求。】If you want to set a cookie from a Controller you do this:【如果你想在Controller中设置cookie，你可以象这样：】response.setCookie(&quot;mycookie&quot;, &quot;myvalue&quot;, &quot;1d&quot;);{java}Then in your test you can do:【然后在你的测试中，你可以这样：】 :::java Http.Response response = GET(&quot;/home/cookie&quot;); assertEquals(&quot;myvalue&quot;, response.cookies.get(&quot;mycookie&quot;).value);For sessions you should take a look at this first:【而session方面，你就应该先看一下这个：】http://www.playframework.org/documentation/1.2.3/controllers#session “It’s important to understand that Session and Flash data are not stored in the server but are added to each subsequent HTTP Request, using the Cookie mechanism. So the data size is very limited (up to 4 KB) and you can only store String values.”【理解这点很重要：Session和Flash的数据并不是保存在服务端，而是通过Cookie的机制加在每一次的HTTP请求中。所以数据的大小是受限制的（最多到4KB）并且你只可以保存String字串值。】They are of course signed so they can’t be changed. If I write session.put(“testcookie”, “brian”) I get this in the response header:【它们当然是被加密的，所以你不能修改。如果我写session.put(“testcookie”, “brian”)，那么我将在response的header中得到：】&quot;PLAY_SESSION=31a4e4777b5950d78b9f3f88b02dfdb2361b5699-%00testcookie%3Abrian%00;Path=/&quot; This makes the job of testing actual session variables a little harder. I haven’t seen anything in the test code that does this for you. You have to go back to the play code to decode the session cookie to check for what you originally wanted to do. The function in playframework\framework\src\play\mvc\Scope.java restore() isn’t accessible so it looks like you have to either use reflection of some sort to call it or write your own session parse function like this (uses the secret from the application.conf to decode):【这使得在测试中使用session值变得有点困难。我在测试的代码中没找到什么可以帮你做这件事的办法。你必须回到Play!的代码去解码那个session cookie以便得到原本的值。这个方法就在playframework\framework\src\play\mvc\Scope.java restore()是不可访问的，所以可能你只好使用类似反射的方法去调用它或者照着写一个你自己的session parse 方法（使用application.conf中的secret码来解码），参考：】https://gist.github.com/1224015 Then you can assert your session code pretty much as you were doing:【然后你就可以用类似下面的办法校验你的session值了：】 :::java @Test public void setsTheSession() throws UnsupportedEncodingException { Http.Response response = GET(&quot;/home/cookie&quot;); Scope.Session session = parseSession(response.cookies.get(&quot;PLAY_SESSION&quot;).value); assertEquals(&quot;yes&quot;, session.get(&quot;worked&quot;)); }On a side note I have switched my functional tests to JWebUnit using the HtmlUnit driver. It has more assert helpers, xpath html parsing and uses rhino for js parsing… but alas you still have to “decode” the PLAY_SESSION either way.【另，我已经将我的functional test转到使用HtmlUnit driver的JWebUnit了。它有更多的校验工具，xpath的html解析工具和rhino的js解析工具等……当然，你还是可以使用”decode”去处理PLAY_SESSION的问题。】 个人建议：在Play!中最好还是只做Model层的单元测试即可，在Controller层中尽量少写业务逻辑代码，方法都往Model层集中，如果项目需要可加上Selenium的Web测试就足够了，实际感觉Functional Test有点鸡肋，不用也罢！]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Flongpolling%2F</url>
    <content type="text"><![CDATA[Play!支持Comet-style或Long-polling这样的请求 参考官方文档 核心实现思想：通过在action中使用await(…);可以使http请求暂停在服务端，直到有符合的结果才返回。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fcacheremovetime%2F</url>
    <content type="text"><![CDATA[移除Cache可以有时间参数吗？是的，可以，使用下面这样的语句即可： :::java Cache.set(&quot;some&quot;, null, 0)其中最后一个参数是时间，单位是秒。详见源代码。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fhqlcount1%2F</url>
    <content type="text"><![CDATA[一个Hql中count判断的写法:::java public static void test() { String hql = &quot;select o.teacher.id, o.teacher.goodStudentCount from Student o&quot; + &quot; group by teacher having count(*)&gt;o.teacher.goodStudentCount&quot;; List&lt;Long[]&gt; idCounts = Teacher.find(hql).fetch(); for (Long[] idCount:idCounts) { Logger.debug(&quot;id: %s, %s&quot;, idCount[0], idCount[1]); Long id = idCount[0]; } renderText(&quot;ok!&quot; + idCounts.size()); }]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xml 域名空间识别问题]]></title>
    <url>%2F2013%2F12%2F13%2Fxmldomainbug%2F</url>
    <content type="text"><![CDATA[相关文档见：官方ticket任务#823 Yes, this is correct. In the .getXML function the namespace ness is not set.是的，有这个问题。在.getXML方法中允许命名空间（namespace）没有设置。 This line should be changed from:这一行应该从这样： :::java DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();to:变成： :::java DocumentBuilderFactory xmlFact = DocumentBuilderFactory.newInstance(); xmlFact.setNamespace(true); DocumentBuilder builder = xmlFact.newDocumentBuilder();The same problem exists in the XML lib in the getDocument function:同样的问题在XML的包里的getDocument方法中也存在： :::java DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespace(true); //Add this line!]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>xml</tag>
        <tag>namespace</tag>
        <tag>getXML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何同时使用http和https协议]]></title>
    <url>%2F2013%2F12%2F13%2Fuserhttps%2F</url>
    <content type="text"><![CDATA[首先看官方文档 用openssl命令生成自己的签名文档 openssl genrsa 1024 &gt; host.key openssl req -new -x509 -nodes -sha1 -days 365 -key host.key &gt; host.cert生成签名时需回答类似这样的问题： Country Name (2 letter code) [XX]: State or Province Name (full name) []: Locality Name (eg, city) [Default City]: Organization Name (eg, company) [Default Company Ltd]: Organizational Unit Name (eg, section) []: Common Name (eg, your name or your server&apos;s hostname) []: Email Address []:最终会得到两个文件：host.key和host.cert 然后在application.conf文件中配置如下： http.port=9000 https.port=9443 # X509 certificates certificate.key.file=conf/host.key certificate.file=conf/host.cert # In case your key file is password protected certificate.password=secret trustmanager.algorithm=JKS原问题及回答 You just need to have both http.port and https.port in the application.conf file. For the links you want to be different from the normal site, use the @@ notation: 你只需要在application.conf文件中配置http.port和https.port，然后在页面上使用如下链接即可： @@{Controller.action().secure()} =&gt;https://... @@{Controller.action()} =&gt; http://]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Foperationnotpermitted%2F</url>
    <content type="text"><![CDATA[Operation not permitted 执行权限的问题在Linux系统中，正好项目放在原Windows的Fat32盘上，于是在执行play eclipsify的时候会报 Operation not permitted的错。 临时使用的话，只要使用root权限就可以正常执行。而Fat32的盘在Linux下是无法进行权限设置的，好像设置后还是无法记录下权限信息，所以要彻底解决这个问题就要将Fat32转为NTFS才行。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Play!中如何用module组织多个相关项目？]]></title>
    <url>%2F2013%2F12%2F13%2Fmultiproject%2F</url>
    <content type="text"><![CDATA[首先按业务需求划分为多个应用，应用就是用 play new xxx来创建的。 其次将公用部分划分为多个子项目或称子模块，就是用 play new-module创建的。 这些项目均并列导入eclipse中，应用引用相应需要的子项目，需要在application.conf中添加，有多个就添加多行： module.base=../base module.common=../common 在eclipse的项目属性中添加引用的子项目即可。 注：关键在于项目规划合理，子项目或公用项目中model层可以分包，如：com.xxx.pack，而controllers和views也可以分包，但要慎重使用，在引用时也有一点小特殊写法。]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fvalidateandsave%2F</url>
    <content type="text"><![CDATA[对像存储报错 validateAndSave问题问题：在存储对像时，同时存储该对像的关联对像，则会报错。\ 例：room为hotel的关联对像。 :::java public class Room { @ManyToOne public Hotel hotel; } :::java Hotel hotel = new Hotel(); Room room = new Room(hotel); room.validateAndSave();会报错。这是因为在保存room对象的时候，hotel对象还没有持久化，所以room对象里面要保存一个hotelId就无法取得了，故必须要先保存父对象，再保存子对象。 必须先将对像hotel存储，再存储一遍room对像。 :::java Hotel hotel = new Hotel(); hotel.validateAndSave(); Room room = new Room(hotel); room.validateAndSave();]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F12%2F13%2Fcmdchinese%2F</url>
    <content type="text"><![CDATA[Play在Windows的cmd窗口中中文乱码的解决办法play在cmd 下，system.out()输出的中文都是乱码 首先，可参考：cmd chcp命令切换字符格式 或参考：在Windows的CMD中如何设置支持UTF8编码? 如果 chcp 65001 / chcp 936 改变cmd字符集都不行 参考：http://www.oschina.net/news/19463/play-framework-1-2-2 方法如下： 安装目录下找到C:\Program Files\play-1.2.3\framework\pym\play 目录下的application.py 修改245行中的java_args.append(‘-Dfile.encoding=utf-8’)为 java_args.append(‘-Dfile.encoding=GBK’)（play-1.2.4中在258行，需要用带行号自动分行的编辑打开。） 保存之后重新运行]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F10%2F26%2Ffunnyclassic%2F</url>
    <content type="text"><![CDATA[有趣经典收集 纯爷们从不围观爆炸（英文歌词） 情人节程序员经典表白 一个不错的塔防Flash游戏]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F10%2F26%2Fbetterplan%2F</url>
    <content type="text"><![CDATA[如何制定和落实一项有效的改善方案？一、问题和参考答案1、是否感觉公司在推行一个变革甚至一个简单的任务时，都会遇到员工的阻力或是简单应付？参考答案： 是的，存在而且很多时候会是这样。 2、他们为什么会阻止或仅仅是应付公司的改善方案呢？参考答案： 人不抗拒改变，只是他没有看到改变后的好处。可以用TOC“鳄鱼和美人鱼”的故事反思员工抗拒或应付改善的原因。 3、是什么造成了今天员工的这种应对公司改善方案的状态？参考答案： 之前公司做了错误的决策，导致不良的结果现状。 之前公司让员工做了无用的、无效的、甚至负作用的任务。 之前的改善过程中，员工没有本质的（薪酬）提升和（能力）改善。 之前的改善，形式大于实质，员工并不认可具体的执行和结果。 之前的改善，付出远大于受益，员工疲惫，公司收效甚微。 4、公司的改善方案要员工做的事情，是他们认为有用、有意义、有价值、会有改善的事情吗？参考答案： 公司的改善方案可能太空洞而不实际，员工心理上期待的改善方案可能更实际一些。 公司的改善方案可能要求过多的形式主义的工作，如开会、报表、标准规范制定等，而员工期待的是具体怎么改进业务流程中长期存在的难题和困惑。 公司认为有价值的事：制定标准、制定绩效考核政策、详尽的数据报表……；员工认为有价值的事：公司盈利、员工奖金、工作环境更舒适、业务流程更顺畅、工作更轻松、压力更小、紧急困难的任务更少、工作更有成就感、公司进入行业领先（自己更有面子）、工作内容更具创新性、更能发挥和提升自己的才能、工作中更有成长和学习……仔细想想，难道这些不正也是公司想要的吗？员工会拒绝这些改善吗？ 5、公司的改善方案真的是可行和有效的吗？参考答案： 不能保证，毕竟通常这类方案只是几个高层在讨论和会议中决策出来的，真正落实到具体细节时，会有很多的问题。 改善方案通常只是指出大的方向，能否成功，更多地在于执行和落实，而这个过程将主要信赖于员工的支持程度。 6、如何制定一个可行、有效的改善方案？如何制定一个员工支持的改善方案？参考答案： 首先基于这样的事实：员工在会议上不太可能把实际中各种的问题总结得很好，包括一些根源性的问题和障碍也不一定能够发现和表达清楚，需要管理者深入实际工作现场去观察和分析。所以仅靠会议上收集的信息不足以做出正确的决策和分析，况且太多人的大型会议效率也不高，不适合讨论过于细节的问题，会议常会陷入应付过程、急于结束的状态。 由上事实给出建议：深入实际现场，尝试从员工眼下最困惑的问题和困难着手，不急于采取较大的行动，试验性地进行一些改善措施，把改善方案先放在文档里，不急于公开和大面积实施，以便在试验过程中随时修正实施细节。 过程中实践一些措施，总结可能的问题和障碍，分析实际现场真正的问题和原因，完善方案细节甚至修改原定方案以适应实际情况。 待各方面考虑周全，试验性的措施收到明显效果后，公开改善方案，开动员会鼓舞士气，此时这个方案将是一个更可行、有效的、全员支持的改善方案。 7、员工会拒绝真正对他有好处的改善吗？参考答案： 当然不会，员工用简单的常识都可能判断一项改善方案是否会对他们有好处，是否真的是个有效的改善，管理者要重视这种直觉和判断，仔细分析和深挖背后的原因来修正手上的改善方案。 8、员工为什么总是怀疑公司的改善方案呢？这种怀疑是负面的吗？参考答案： 怀疑是正常的，且甚至是正面的，应该被重视和鼓励的。深入了解员工怀疑的原因和障碍可以更好地帮助管理者做出真正正确的决策。还有一方面原因是因为之前的失败经历造成的，所以管理者要非常慎重地推进一次改善，因为一次错误的决策可能完全毁掉之前多个正确措施所积累的成果和士气，甚至不如完全不做改善来得效果好。深入的调查分析，多次的、小范围的试验验证，严谨科学的理论推演验算等都是避免错误的有效手段。 9、员工心理上会拒绝哪些改善中要做的事情？参考答案： 员工心理上最拒绝的事情如：冗长低效的会议讨论、空洞抽象的理论宣讲、制作繁杂的报表文档、异想天开的方案指导、不切实际的行动要求和标准规范、重罚轻奖的绩效考核、机械无趣的重复工作、违反常识和经验的操作标准等。 10、怎么样达成一种双赢的状态，让员工积极响应，并全力支持公司快速推进改善呢？参考答案： 深入员工基层，不急于去“管理”和“行动”，先多了解实际情况并分析问题，更多地参与到业务流程中，更多地与员工深入沟通，再运用先进的管理思想（如TOC等）来进行全面系统地分析，找寻最佳的切入点，谨慎操作，小量多次地试验以反复验证方案的可行性和个中利弊，最终再确定一个全面实施的改善方案，这样的方案一定可以得到员工的认可和积极响应，在推行过程中也会更快落实、更快见效。 二、公司应该如何推行TOC的管理改善《第3选择》一书中有句话：“当人们的思想处于防御状态时，既不会有创造性，也不会有合作性”。个人感觉目前公司的中层管理人员甚至基层员工，都已经形成了一种对公司改革变化的防御状态，从平衡计分卡到TOC，每一次的变革都被认为是一次新的折腾，在这样的防御状态下，推行新的变革或执行改善措施都将是事倍而功半的，所以我们目前首先应该解决的是人员的一种思想状态问题，需要化解这种防御的状态，打消人员的担忧和顾虑，疏导人员的情绪和心态，不需要刻意地强调使用了一种新的管理思想，不需要刻意地把TOC的名词挂在嘴边当做金科玉律，不可挑战或质疑。 TOC的理论之所以强大，就是因为它根本来自于基本的常识和严谨的逻辑，不需要特别地强调TOC的知识体系，它也是存在于现实生活和工作当中的，因此我的建议是公司在推行TOC时，将TOC的名词和工具“隐藏”起来，只是让中层管理人员和基层员工感受到严谨的逻辑推理，全面系统的分析即可，这样才能真正让人员关注在具体的业务问题的解决，较顺畅地认可公司的改善方向，协助公司完成关键时期的改善行动。例如，我们在用CRT图分析现状问题时，不需要讲解有关TOC理论中CRT图的方方面面，只需要展现我们绘制的CRT图，标题不要用CRT英文，而是使用类似“公司现状分析图”这样普通的文字，然后告诉大家这就是我们分析的公司的现状，箭头是表示一种充分条件的因果关系（此处可以稍做解释充分条件和因果关系），大家可以看看是不是这样？ 例如，我们在使用“六阶阻抗”或“5F”等工具时，只需要巧妙地引导大家一步步进行即可，不需要将这些步骤说明并强调出来，以免令所有参与者感觉自己是被套上了一个模子或是在一条生产线上一步步被加工，这样的形式主义是会给参与者非常不好的感受，产生抗拒或应付的状态。另外，在具体推行之前，个人觉得还需要首先树立一种公司的形象，改变以往“折腾”的不良印象，那就是“务实”的形象，不讲理论或少讲理论，将理论巧妙地融入到每一次沟通和实践过程中，用一句诗意的话来形容就是：“润物细无声”。那么“务实”的形象为什么会有效呢？因为几乎所有人员都是不反对公司改善的，反而一定是希望公司改善的，很多时候出现抗拒就象六阶阻抗所说的情况一样，某一阶出现了不认同的问题，然而在具体进行过程中，却不能简单地、形式化地用理论来套用，因为要与他人达成“协同”（《第3选择》所强调的一个词），需要行为模式这方面的知识和能力，正如《高效能人士的七个习惯》和《第3选择》这两本书中提到的原则和方法一样，需要考虑对方的“意愿”、“知识”和“技能”等因素，而不是简单地走一下六阶阻抗的流程就能达成共识的。]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F09%2F29%2Fdevlinks%2F</url>
    <content type="text"><![CDATA[编程知识链接收集 Java 相关 java.util.logging.Logger使用详解 10 Java Regular Expression Examples You Should Know Java Regex cheat sheet]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Regex</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[停止SSH，用Play!吧]]></title>
    <url>%2F2013%2F09%2F29%2Fstopsshgoplay%2F</url>
    <content type="text"><![CDATA[Created 星期六 25 二月 2012 先看一段Playframework热情交流群（QQG：168013302）里的聊天记录： 木马@学生 09:59:13 实现个功能..要调用service接口的方法, 方法又在他的impl里面实现, impl里面又是调用dao层接口, dao层接口又是在dao的impl里面实现, dao的impl实现又是由hibernate访问的数据库,木马@学生 09:59:28 真心蛋都碎了Freewind@play2 10:00:29 为什么要这么多接口？木马@学生 10:00:41 学校的项目…SSH2Freewind@play2 10:01:04 话说我前公司也是这样的，看着都累木马@学生 10:01:25 对了, 还没说上层的 action,拦截分配 do了返回,木马@学生 10:01:31 头都大了木马@学生 10:01:57 还前端的 jquery, ajax访问数据库, 再经过这些框架的时候Snake 10:01:59 ssh2是这样的Snake 10:02:13 冠名弱耦合木马@学生 10:02:14 那叫一个个都要问候到啊…Freewind@play2 10:03:01 你能不能改代码，能删的都删了木马@学生 10:03:25 我就写个登陆功能, 就要搞这么多世风十三@用中 10:06:12 我公司也是实现个简单的java app，用了无数接口，我重构时都删了。Freewind@play2 10:07:18 都是当年spring惹的祸Snake 10:09:00 大项目是有需要的Snake 10:09:29 小项目用ssh有点小题大作木马@学生 10:10:09 学校总是搞最大的框架, 做最小的项目世风十三@用中 10:10:22 算不算是接口滥用木马@学生 10:10:34 说出来能唬人啊木马@学生 10:10:41 写出来, 全是英文啊Snake 10:11:11 ssh熟悉精通，所以学校也只能这样 应该说使用接口主要是基于开放封闭原则，即对扩展开放，而对修改封闭。而实际项目中，通常的开发是不断地修改完善，最终达到理想效果。所以开放封闭原则应该说不适用于项目内部，而是针对于打包对外服务的情况，所谓“接口”也正是对外来说的，如果你的项目是对外提供公用类库或是框架包等的，那就要严格定义准确的接口规范，并且尽量保持对外接口的稳定，在做系统分析时就要深入调研，考虑周到，对未来的变化有充分的预估。而相反如果是整个项目仅用于对内的应用，而所有代码都是自己控制，未来也没有与其他组群的协同问题，那就没有必要做到层层都接口，直接实现也未尝不可。 多数时候，初学者都是在对着SSH的框架照猫画虎，画的时候也不太深思为什么要这样做，只道是一种开发规范罢了，遵守便是，没什么好说，然而实际上SSH框架的创造者是思考了太多的可能性和各种问题后总结出的经验结晶，这其中考虑遇到最为复杂的情况类似大型企业复杂应用的开发等，而对于大多数中、小型项目而言，多少有点用牛刀杀鸡的感觉。 相对的，Play framework 则是从一开始就是针对Web应用开发来设计的，借鉴了其他很多优秀框架（如ROR）的思想，直接解决了中小型项目快速开发的问题，同时也提供了Module的机制，给予了无限的扩展空间，当然也适用于大型的企业应用项目，只要架构师在具体应用上掌握了一定的技巧和经验，开发起来还是相当敏捷和舒爽的！:) 所以，如果你们的团队是擅长Java这门语言的，你们的应用是基于Web的应用系统，你们有权决定使用什么样的技术路线和框架的话，那么强烈建议使用Playframework，放弃SSH的繁杂和冗余吧，在Playframework的世界里，你会接触到最新的技术思想，最敏捷的开发理念，最高效的代码实现！Welcome to Playframework world!]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F09%2F29%2Flearnself%2F</url>
    <content type="text"><![CDATA[编程自学之路很多爱好编程，喜欢Play框架的朋友，开始的时候找不到门道，这里抛砖引玉，给大家分享一些经验…… 首先，心要正。没错，如同武侠小说中的上乘武功一样，必须讲究心法，心术不正者必定会走火入魔。 其次，道要高。所谓魔高一尺，道高一丈，老子的道家思想的智慧，时至今日，如果每个人都能理解其中的道意，世界也就不会有这么多问题了。 函数式编程思维Turn imperative code into functional code. Introduce higher-order functions. 引入高阶函数 Convert existing methods into pure functions. 将已有方法转为纯函数 Convert loops over to recursive/tail-recursive methods (if possible). 将循环转为递归或尾递归方法 Convert mutable variables into immutable variables. 将可变类型转为不可变类型 Use pattern matching (if possible). 尽量使用模式匹配 最后，Born for program!某一天，当你发现你天生就是做程序的料，你就算是入道了！]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2013%2F09%2F29%2Ftocterm%2F</url>
    <content type="text"><![CDATA[TOC 术语 TOC：Theory Of Constraints 约束理论（限制理论）瓶颈理论 F5：Focus Five Step 聚焦五步骤 I-E-S-E-GB识别Identify，挖尽Exploit， 迁就Subordinate，松绑Etevate，重返Go Back TA：Throughput Account 有效产出会计 T: Throughput 生产量，有效产出 I（1）：Inventory 库存 I（2）：Investment 投资 OE：Operational Expensive 营运开支，营运费用 NP：Net Profit 纯利润 ROI：Return On Investment 投资收益率 CF：Cash Flow 现金流量 P&amp;L：Profit and Loss Statement (P&amp;L) 损益表 BS：Balance Sheet 资产负债表 BS：Batch Size 批量大小 TP：Thinking Process 思维流程 T/CU：瓶颈单位时间有效产出 CCR：Capacity Constrain Resource 产能制约资源 M(1)：Murphy 墨非 M(2)：Measurement 衡量 APMB：Assumption，Policy，Measurement，behavior 假设——政策（典范）——衡量——行为 CWR：Convergence，Win-Win，Respect 内敛（收敛），双赢，尊重 CRT：Current Reality Tree 当前现实树 CRD：Conflict Resolution Diagram 冲突消除图 FRT：Future Reality Tree 未来现实树 PRT：Pre-requisite Tree 前提条件树 TT：Transition Tree 转变树 S&amp;T：Strategy &amp; Tactics Tree 战略战术树 NBR：负面效应 OB：Obstacle 障碍 RC：Root Cause 根本原因 CP：Core Problem 核心问题 UDE：Undesirable Effects 不满意效应 DE：Desirable Effects 满意效应 INJ：Injection 注入，激发方案 IO：Inter-mediate Objectives 中间（中程）目标 SA：Specific Action 特别行动 IE：Inter-mediate Effect 中间效应 R：Requirements 需求，必要条件 PR：Pre-requisite 前提条件 CLR：Categories of Legimitate Reseration 逻辑（分类）测试 CCPM：Critical Chain Project Management 关键链（项目管理） PB：Project Buffer 项目缓冲 FB：Feeding Buffer 接驳缓冲 RB：Resource Buffer 资源缓冲 OPT：Optimized Production Technology，最优生产技术 DBR：Drum,Buffer,Rope 鼓——缓冲——绳子 S-DBR：S-DBR 简单DBR DBR-BM ：Drum,Buffer,Rope- Buffer Management 鼓——缓冲——绳子—缓冲管理 POOGI：Process Of On Going Improvement 持续改善程序 GC：高德拉特机构 MTS：Make to Stock 面向库存生产 MTO：Make to Order 面向定单生产 ATO：Assemble to Order 面向定单装配 ETO：Engineering to Order 面向定单设计 NEB（NBR）：Negative Effect Branches负效应枝条 The buy-in process：说服的流程 MO：Mafia Offer 黑手党方案 VV：Viable Vision 可行愿景 TOS：Throughput based Operating Strategy基于有效产出战略 TDD ：Throughput Dollar Day 有效产出/元/天 IDD：Inventory Dollar Day 库存/元/天 OP：Objection Prevention 异议预防 CWM：Central Warehouse Management 中央库存管理 TLT：Transportation Lead Time 运送提前期 PLT：Production Lead Time 生产提前期 OLT：Order Lead Time 订货提前期 RRO：Rapid Response Order 快速响应订单 Retailer：retailer模板（零售商模板） Consumer goods：consumer goods模板（生活消费品模板） TOCICO：Theory of Constraints International Certification Organization——TOC国际认证组织 CSS：Common Sense Solution 常识解决方案 SKU：单位库存 MBO ：Management by Objectives 目标管理 PL： Parkinson’s Law 帕金森定律 CL：Cannikin Law 木桶定律 ML： Murphy’s Law 墨菲定律 BE： Butterfly Effect 蝴蝶效应 DE：Domicile Effect 多米诺效应 LO：Learning Organization 学习型组织 Ever Flourishing 基业长青 Exponential Growth 指数性之成长 Sales Approach 销售方式 Profitability And Sales Volume 利润率和销售额 CRM ：Customer Relationship Management客户关系管理 TE：Throughput Effectiveness有效产出率（T与OE的比率） Student Syndrome 学生综合征 Parkinson’s Law 帕金森定律 不良多工 不良多任务 APS：Advanced Planning and Scheduling 高级计划排程 →APS：Advanced Production Scheduling 高级生产排程 FCS：Finite-Capacity Scheduling 有限产能排程 MRP：Material Requirements Planning 物料需求计划 →（MRP：More Reams of Papers 更多令的纸） →（MRP：More Ridiculous Priorities 更荒缪的优先顺序） ERP：Enterprice Resource Planning 企业资源计划 Justification 价值认证 Distribution Center 分销中心 Right-Sizing 适当规模 PMS：Performance Measurement System 绩效衡量系统 MS：Master Schedule 主排程 MPS：Master Production Schedule 主生产排程 SC：Safety Capacity 备用产能 SB模型：Shipping Buffer出货缓冲模型 DV：Dependent Events 依存关系 SF：Statistical Fluctuations 统计波动 OEM：Original Equipment Manufacturer 原始设备制造商，贴牌生产，代工 ODM：Original Design Manufacturer原始设计制造商，设计生产（OEM升级） OBM：Original Brand Manufacturer 原始品牌制造商 1、A方看中B方的产品，让B方生产，用A方商标，对A方来说，这叫OEM； 2、A方自带技术和设计，让B方加工，这叫ODM； 对B方来说，只负责生产加工别人的产品，然后贴上别人的商标，这叫OBM. 某企业生产的产品没有自己的品牌，专门接受其他企业的OEM或ODM要求为其他企业定牌生产。 WIP：Work In Process在制品 DDP: Delivered Duty Paid (named place of destination) 完税后交货（指定目的地） DDP：Due Date Performance 交（货）期绩效 NA：Necessary Assumption 必要假设 PA： Parallel Assumption 并行假设 SA： Sufficient Assumption充份假设 DCE：Decisive Competitive Edge决定性竞争优势 EOQS：end-of-quarter syndrome季末症候群 ABP时间：Aggressive，But Possible 积极但是有可能 CCM： Critical Chain Method 关键链方法 CDC ：Central Distribution Center 中央仓库，中央分销中心 RDC：Region Distribution Center 区域仓库，区域分销中心 TPS：Throughput Per Shelf （每个，每平方米的）货架的有效产出 PERT： Program Evaluate Review Technique 计划评核术，项目评估检查技术]]></content>
      <categories>
        <category>playscala</category>
      </categories>
      <tags>
        <tag>playscala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xml 域名空间识别问题]]></title>
    <url>%2F2013%2F09%2F26%2Fxmlawarenamespace%2F</url>
    <content type="text"><![CDATA[相关文档见：官方ticket任务#823 Yes, this is correct. In the .getXML function the namespace ness is not set.是的，有这个问题。在.getXML方法中允许命名空间（namespace）没有设置。 This line should be changed from:这一行应该从这样： :::java DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();to:变成： :::java DocumentBuilderFactory xmlFact = DocumentBuilderFactory.newInstance(); xmlFact.setNamespace(true); DocumentBuilder builder = xmlFact.newDocumentBuilder();The same problem exists in the XML lib in the getDocument function:同样的问题在XML的包里的getDocument方法中也存在： :::java DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); dbf.setNamespace(true); //Add this line!]]></content>
      <categories>
        <category>play1x</category>
      </categories>
      <tags>
        <tag>play1x</tag>
        <tag>xml</tag>
        <tag>namespace</tag>
      </tags>
  </entry>
</search>
